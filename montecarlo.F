      LOGICAL FUNCTION LISNAN(W)
         IMPLICIT NONE
         REAL*8 W
         LISNAN=.FALSE.
         IF(W.EQ.0.AND.W*1.EQ.1) LISNAN=.TRUE.
         RETURN
      END

      REAL*8 FUNCTION GETNAN()
         A=1
         B=1
         GETNAN=LOG(A-2*B)
         RETURN
      END


       REAL*8 FUNCTION DMONTECARLO(I_P,NDET,RHOIJROWS,RHOIJ,RHOIJ1,
     &         RHOIJ2,BETA,DBETA,RHOIJLAB,NRHOMAXWIDTH,I_HMAX,IMCSTEPS,
     &         G1,NMRKS,NEL,NBASISMAX,NBASIS,BRR,IEQSTEPS,NWHTAY,
     &         ILOGGING)
         use SystemData, only: BasisFN
         use global_utilities
         IMPLICIT REAL*8 (A-H,O-Z)
         INTEGER NDET,NRHO
         INTEGER RHOIJLAB(*),RHOIJROWS(NDET+1)
         REAL*8 RHOIJ(*),RHOIJ1(*),RHOIJ2(*)
         INTEGER IPATH(I_P+1)
         INTEGER ISEED
         INTEGER II,IJ
         INTEGER NI(NEL), NJ(NEL)
C         INTEGER NI(4,NEL), NJ(4,NEL)
         LOGICAL LACC
         INTEGER BRR(NBASIS)
         TYPE(BasisFN) G1(NBASIS)
         INTEGER NMRKS(NEL,NDET),nBasisMax(5,*)
         INTEGER,ALLOCATABLE :: LSTI(:,:) ! (3,*)
         REAL*8,ALLOCATABLE :: DLWDBS(:),WLRIS(:),WLSIS(:)
         integer, save :: tagLSTI=0,tagDLWDBS=0,tagWLRIS=0,tagWLSIS=0
         LOGICAL LISNAN
         REAL*8 RAN2
         type(timer), save :: proc_timer
         character(*), parameter :: thisroutine='DMONTECARLO'

C.. NI, NJ are the quantum numbers of 
         proc_timer%timer_name=thisroutine
         call set_timer(proc_timer)
C.. Randomize the seed:
         ISEED=-70001
CINT(SECNDS(0.0))
         IF(MOD(ISEED,2).EQ.0) ISEED=ISEED-1
C.. THe seed must be odd
C.. Allocate some memory
         LISTMAX=IMCSTEPS+1
         NFIRST=1
         allocate(LSTI(3,LISTMAX))
         allocate(DLWDBS(LISTMAX))
         allocate(WLRIS(LISTMAX))
         allocate(WLSIS(LISTMAX))
         CALL LogMemAlloc('LSTI',3*LISTMAX,4,thisroutine,tagLSTI)
         CALL LogMemAlloc('DLWDBS',LISTMAX,8,thisroutine,tagDLWDBS)
         CALL LogMemAlloc('WLRIS',LISTMAX,8,thisroutine,tagWLRIS)
         CALL LogMemAlloc('WLSIS',LISTMAX,8,thisroutine,tagWLSIS)
         LSTI(3,NFIRST)=0
         LSTI(2,NFIRST)=1

C.. Hard code the start position as the NEL lowest energy basis fns
         DO I=1,NEL
            NI(I)=BRR(I)
         ENDDO
C.. NI will not now be in order of basis fn, so we need to sort it
         CALL SORTI(NEL,NI)
C.. Now find which number determinant this corresponds to
         II=IFINDDET2(NI,NEL,G1,NMRKS,NBASIS,NDET)
         LSTI(1,NFIRST)=II
C.. Calculate RHO_II
         CALL MCPATHSR(II,I_P,NDET,RHOIJROWS,RHOIJ,RHOIJLAB,
     &               NRHOMAXWIDTH,I_HMAX,NWHTAY,ILOGGING,WLRI,WLSI)
         CALL MCPATHSR(II,I_P,NDET,RHOIJROWS,RHOIJ1,RHOIJLAB,
     &               NRHOMAXWIDTH,I_HMAX,NWHTAY,ILOGGING,WLRI1,WLSI1)
         CALL MCPATHSR(II,I_P,NDET,RHOIJROWS,RHOIJ2,RHOIJLAB,
     &               NRHOMAXWIDTH,I_HMAX,NWHTAY,ILOGGING,WLRI2,WLSI2)
         DLWDB=-(I_P*(WLRI2-WLRI1)+(WLSI2-WLSI1))/(2*DBETA)
         WLRIS(NFIRST)=WLRI
         WLSIS(NFIRST)=WLSI
         DLWDBS(NFIRST)=DLWDB
         WRITE(6,*) "DLWDB(1)=",DLWDB
         TOT=0.D0
         OPEN(17,FILE="MC",STATUS="UNKNOWN")
         IEQS=IEQSTEPS          
         DO IT=1,IEQSTEPS+IMCSTEPS
C.. Pick a random new determinant
            IJ=0
C            DO I=1,NEL
C               DO J=1,4
C                  NJ(J,I)=NI(J,I)
C               ENDDO
C            ENDDO
            CALL ICOPY(NEL,NI,1,NJ,1)

            DO WHILE (IJ.EQ.0)
              CALL GENNEWDET2(NJ,NJ,NEL,NBASIS,NBASISMAX,G1,ISEED,1,BRR)
C               CALL GENNEWDET(NJ,NJ,NEL,NBASISMAX,ISEED)
               IJ=IFINDDET2(NJ,NEL,G1,NMRKS,NBASIS,NDET)
C               IF(IJ.EQ.0) WRITE(10,*) "Another IJ"
C.. There's no guarantee that the new determinant will obey the symmetry
C.. constraints, so we keep on generating them until we find a good one
            ENDDO

C.. Calculate RHO_JJ
            IND=IFINDRII(IJ,LSTI,1,NFIRST)
            NIND=0
            WRITE(17,"(2I7)",advance='no') IT,IT-IEQSTEPS
            IF(IND.EQ.0) THEN
               CALL MCPATHSR(IJ,I_P,NDET,RHOIJROWS,RHOIJ,RHOIJLAB,
     &               NRHOMAXWIDTH,I_HMAX,NWHTAY,ILOGGING,WLRJ,WLSJ)

               NIND=ISTORERII(IJ,WLRJ,WLSJ,GETNAN(),LSTI,WLRIS,WLSIS,
     &               DLWDBS,LISTMAX,NFIRST,1)
            ELSE
               WLRJ=WLRIS(IND)
               WLSJ=WLSIS(IND)
            ENDIF
           WRITE(17,"(2E25.16)",advance='no')
     &                            EXP(WLRI*I_P+WLSI),EXP(WLRJ*I_P+WLSJ)
            WRITE(17,"(A,I3,A,I3,A)",advance='no')
     &                                          "  (",II,"),(",IJ,")->"
C..  At this stage we have decomposed ln W_I = p ln RHO_II + ln S_I
C..  Although S_I should be >0, our approximation to it may be 0 or <0,
C..  which leads to ln S_I (=WLSI) = -NaN.
C..  As our acceptance probabilities are W_J/W_I, a value of W_J that is
C..  <=0 (caused by an S_J<=0) would never be accepted, so we reject W_J
C..  where ln S_I=NaN
C..  NB - this NaN test may not be portable
            IF(LISNAN(WLSJ)) THEN
               LACC=.FALSE.
            ELSE
               DLRAT=I_P*(WLRJ-WLRI)+(WLSJ-WLSI)
C               RAT=WJ/WI
               IF(DLRAT.LT.0.D0) THEN
                  RAT=EXP(DLRAT)
                  LACC=.TRUE. 
                  IF(RAN2(ISEED)*1.0.GT.RAT) LACC=.FALSE.
               ELSE
                  LACC=.TRUE.
C.. use up a random number to keep consistency.
                  TT=RAN2(ISEED)
                  TT=TT+1
               ENDIF
            ENDIF
            IF(LACC) THEN
               DLWDB=GETNAN()
               IF(IND.NE.0) DLWDB=DLWDBS(IND)
               IF(LISNAN(DLWDB)) THEN
                  CALL MCPATHSR(IJ,I_P,NDET,RHOIJROWS,RHOIJ1,RHOIJLAB,
     &               NRHOMAXWIDTH,I_HMAX,NWHTAY,ILOGGING,WLRI1,WLSI1)
                  CALL MCPATHSR(IJ,I_P,NDET,RHOIJROWS,RHOIJ2,RHOIJLAB,
     &               NRHOMAXWIDTH,I_HMAX,NWHTAY,ILOGGING,WLRI2,WLSI2)
                  DLWDB=-(I_P*(WLRI2-WLRI1)+(WLSI2-WLSI1))/(2*DBETA)
                  IF(IND.NE.0) DLWDBS(IND)=DLWDB
               ENDIF
C.. if there's space, we store
               IF(NIND.NE.0) DLWDBS(NIND)=DLWDB
C               DLWDB=-(LOG(WI2/WI1))/(2*DBETA)
C               WI=WJ
               WLRI=WLRJ
               WLSI=WLSJ
               II=IJ
               CALL ICOPY(NEL,NJ,1,NI,1)
            ENDIF      
            IF(IEQS.EQ.0) THEN
               TOT=TOT+DLWDB
            ELSE
               IEQS=IEQS-1
            ENDIF
            WRITE(17, "(A,I3,A,2E25.16)") "  (",II,")",DLWDB,TOT
            IF(MOD(IT,100).EQ.0) WRITE(6,*) IT
         ENDDO
         CLOSE(17)
         DMONTECARLO=TOT/IMCSTEPS
         call halt_timer(proc_timer)
         deallocate(LSTI)
         deallocate(DLWDBS)
         deallocate(WLRIS)
         deallocate(WLSIS)
         CALL LogMemDealloc(thisroutine,tagLSTI)
         CALL LogMemDealloc(thisroutine,tagDLWDBS)
         CALL LogMemDealloc(thisroutine,tagWLRIS)
         CALL LogMemDealloc(thisroutine,tagWLSIS)
         LSTI(3,NFIRST)=0
         LSTI(2,NFIRST)=1
      END FUNCTION DMONTECARLO


      SUBROUTINE GENNEWDET(NI,NJ,NEL,NBASISMAX,ISEED)
         IMPLICIT REAL*8 (A-H,O-Z)
         INTEGER nBasisMax(5,*),NI(4,NEL),NJ(4,NEL)
         REAL*8 RAN2
         DO I=1,NEL
            DO J=1,4
               NJ(J,I)=NI(J,I)
             ENDDO
         ENDDO
         IEL=INT(RAN2(ISEED)*NEL)+1
         IQN=3+(NBASISMAX(4,2)-NBASISMAX(4,1))/2
C.. Sometimes spin there is no spin freedom (fully polarized)
         IQN=INT(RAN2(ISEED)*IQN)+1
         ISGN=INT(RAN2(ISEED)*(NBASISMAX(NQN,2)-NBASISMAX(NQN,1)+1))
     &         +NBASISMAX(NQN,1)
         IF(IQN.EQ.4) THEN
C.. change the spin
            NJ(4,IEL)=-NJ(4,IEL)
         ELSE
            NJ(IQN,IEL)=NJ(IQN,IEL)+ISGN
            IF(NJ(IQN,IEL).GT.NBASISMAX(IQN,2))
     &         NJ(IQN,IEL)=NBASISMAX(IQN,1)
            IF(NJ(IQN,IEL).LT.NBASISMAX(IQN,1))
     &         NJ(IQN,IEL)=NBASISMAX(IQN,2)
         ENDIF
         RETURN
      END

C.. NJ is a list of Quantum numbers of basis fns for each electron
      INTEGER FUNCTION IFINDDET(NJ,NEL,G1,NMRKS,NBASIS,NDET)
         use SystemData, only: BasisFN
         IMPLICIT REAL*8 (A-H,O-Z)
         INTEGER NJ(4,NEL),NMRKS(NEL,NDET)
         TYPE(BasisFN) G1(*)
         LOGICAL TFOUND
         TFOUND=.FALSE.
         DO I=1,NDET
            DO J=1,NEL
               DO K=1,4
                  IF(NJ(K,J).NE.G1(NMRKS(J,I))%k(K)) GOTO 10
               ENDDO
            ENDDO
            TFOUND=.TRUE.
            IFINDDET=I
10          IF(TFOUND) GOTO 20
         ENDDO
C.. We couldn't find it
         IFINDDET=0
20       RETURN
      END

C.. NJ is a list of basis fns - one for each electron
      INTEGER FUNCTION IFINDDET2(NJ,NEL,G1,NMRKS,NBASIS,NDET)
         IMPLICIT REAL*8 (A-H,O-Z)
         INTEGER NJ(NEL),G1(*),NMRKS(NEL,NDET)
         LOGICAL TFOUND
         TFOUND=.FALSE.
         DO I=1,NDET
            DO J=1,NEL
               IF(NJ(J).NE.NMRKS(J,I)) GOTO 10
            ENDDO
            TFOUND=.TRUE.
            IFINDDET2=I
10          IF(TFOUND) GOTO 20
         ENDDO
C.. We couldn't find it
         IFINDDET2=0
20       RETURN
      END

       REAL*8 FUNCTION DMONTECARLO2(MCDET,I_P,BETA,DBETA,I_HMAX,I_VMAX,
     &      IMCSTEPS,G1,NEL,NBASISMAX,NBASIS,BRR,IEQSTEPS,
     &         NMSH,FCK,NMAX,ALAT,UMAT,NTAY,RHOEPS,NWHTAY,ILOGGING,
     &         ECORE,BETAEQ)

         use global_utilities
         IMPLICIT REAL*8 (A-H,O-Z)
         include 'irat.inc'
         INTEGER IPATH(I_P+1)
         INTEGER ISEED
         INTEGER NI(NEL), NJ(NEL),MCDET(NEL)
         LOGICAL LACC,LISVALID
         INTEGER BRR(NBASIS),RHOEPS
         INTEGER G1(*),nBasisMax(5,*)
         CHARACTER*50 STR

         INTEGER, ALLOCATABLE :: LSTE(:)
CNEL,0:NBASIS*NBASIS*NEL*NEL,0:I_HMAX-1)
         INTEGER, ALLOCATABLE :: ICE(:)
         REAL*8, ALLOCATABLE :: RIJLIST(:)
C0:NBASIS*NBASIS*NEL*NEL,0:I_HMAX-1)
         INTEGER,ALLOCATABLE :: LSTDET(:,:)
         REAL*8,ALLOCATABLE :: DLWDBS(:),WLRIS(:),WLSIS(:)

         integer, save :: tagLSTE=0,tagICE=0,tagRIJLIST=0,tagLSTDET=0
         integer, save :: tagDLWDBS=0,tagWLRIS=0,tagWLSIS=0

         INTEGER I_HMAX,I_VMAX
         LOGICAL LISNAN
         REAL*8 SUMSQ,BETAEQ,BETAC,DBETAC
         INTEGER IEQ1,IEQ2
         INTEGER NCH
         REAL*8 DLWDBC
         REAL*8 RAN2
         type(timer), save :: proc_timer
         character(*), parameter :: thisroutine='DMONTECARLO2'
         SUMSQ=0.D0
C.. NI, NJ are the quantum numbers of 
         proc_timer%timer_name=thisroutine
         call set_timer(proc_timer)
C.. Randomize the seed:
         ISEED=-70001
CINT(SECNDS(0.0))
         IF(MOD(ISEED,2).EQ.0) ISEED=ISEED-1
C.. THe seed must be odd
         ILMAX=(NBASIS-NEL)**2*NEL*NEL/4
C.. We don't need to store these lists for I_HMAX=-8
         IF((I_HMAX.GE.-10.AND.I_HMAX.LE.-7).OR.I_HMAX.LE.-12) ILMAX=1
C.. Allocate some memory
         IF(I_VMAX.GT.0) THEN
            allocate(LSTE(NEL*(ILMAX+1)*I_VMAX))
            CALL LogMemAlloc('LSTE',size(LSTE),4/IRAT,thisroutine,
     &                                                          tagLSTE)
            allocate(ICE((ILMAX+1)*I_VMAX))
            CALL LogMemAlloc('ICE',size(ICE),4/IRAT,thisroutine,tagICE)
            allocate(RIJLIST((ILMAX+1)*I_VMAX*2))
            CALL LogMemAlloc('RIJLIST',size(RIJLIST),8,thisroutine,
     &                                                       tagRIJLIST)
         ELSE
            allocate(LSTE(NEL*(ILMAX+1)*I_HMAX))
            CALL LogMemAlloc('LSTE',size(LSTE),4/IRAT,thisroutine,
     &                                                          tagLSTE)
            allocate(ICE((ILMAX+1)*I_HMAX))
            CALL LogMemAlloc('ICE',size(ICE),4/IRAT,thisroutine,tagICE)
         ENDIF
         LISTMAX=IMCSTEPS+1
         IF(LISTMAX.GT.10000) LISTMAX=10000
         NFIRST=1
         allocate(LSTDET(NEL+2,LISTMAX))
         call LogMemAlloc('LSTDET',size(LSTDET),4,thisroutine,tagLSTDET)
         allocate(DLWDBS(LISTMAX))
         call LogMemAlloc('DLWDBS',LISTMAX,8,thisroutine,tagDLWDBS)
         CALL MEMORY(IP_DLWDBS,LISTMAX,"DLWDBS")
         allocate(WLRIS(LISTMAX))
         call LogMemAlloc('WLRIS',LISTMAX,8,thisroutine,tagWLRIS)
         allocate(WLSIS(LISTMAX))
         call LogMemAlloc('WLSIS',LISTMAX,8,thisroutine,tagWLSIS)
         LSTDET(NEL+2,1)=0
         LSTDET(NEL+1,1)=1


C.. Hard code the start position as the NEL lowest energy basis fns
         DO I=1,NEL
            NI(I)=MCDET(I)
         ENDDO
         DO I=1,NEL
            LSTDET(I,NFIRST)=NI(I)
         ENDDO
        IF(NTAY.GE.0) THEN 
         WRITE(6,*) '<D0|H|D0>=',GETHELEMENT2(NI,NI,NEL,NBASISMAX,
     &              G1,NBASIS,BRR,NMSH,FCK,NMAX,ALAT,UMAT,IC,ECORE)
         WRITE(6,*) '<D0|T|D0>=',CALCT(NI,NEL,G1,NBASIS)
        ENDIF

      IF(IEQSTEPS.GT.0.AND.BETAEQ.NE.0.D0) THEN
         IF(NTAY.LT.0) STOP 'CANNOT MC with annealing with NTAY<0'
         BETAC=BETAEQ
         DBETAC=DBETA*BETAC/BETA
         IEQ1=IEQSTEPS/8
         IEQ2=(IEQSTEPS*3)/4
      ELSE
         BETAC=BETA
         DBETAC=DBETA
         IEQ1=0
         IEQ2=0
      ENDIF

C.. Now find which number determinant this corresponds to
C.. Calculate RHO_II
      IF (NTAY.LT.0) THEN
C..     NTAY<0 => Exact new method
C..     FCK->RHOIJ
C..     ZIA->RHOIJLAB
C..     UMAT->RHOIJROWS
C..     NMSH->NMRKS
C..     NMAX->RHOIJ1
C..     ALAT->RHOIJ2
C..     BETA->NHG
               DLWDB=GETNAN()
        CALL MCPATHSR3(NI,BETA,I_P,I_HMAX,I_VMAX,NEL,NBASISMAX,G1,
     &      NBASIS,BRR,NMSH,FCK,NMAX,ALAT,UMAT,NTAY,RHOEPS,LSTE,ICE,
     &      RIJLIST,NWHTAY,ILOGGING,ECORE,ILMAX,WLRI,WLSI,DBETAC,DLWDB)
         IF(LISNAN(DLWDB)) THEN
        CALL MCPATHSR3(NI,BETA,I_P,I_HMAX,I_VMAX,NEL,NBASISMAX,G1,
     &     NBASIS,BRR,NMSH,NMAX,NMAX,ALAT,UMAT,NTAY,RHOEPS,LSTE,ICE,
     &     RIJLIST,NWHTAY,ILOGGING,ECORE,ILMAX,WLRI1,WLSI1,DBETAC,DLWDB)
        CALL MCPATHSR3(NI,BETA,I_P,I_HMAX,I_VMAX,NEL,NBASISMAX,G1,
     &     NBASIS,BRR,NMSH,ALAT,NMAX,ALAT,UMAT,NTAY,RHOEPS,LSTE,ICE,
     &     RIJLIST,NWHTAY,ILOGGING,ECORE,ILMAX,WLRI2,WLSI2,DBETAC,DLWDB)
         ENDIF
      ELSE
               DLWDB=GETNAN()
        CALL MCPATHSR3(NI,BETAC,I_P,I_HMAX,I_VMAX,NEL,NBASISMAX,G1,
     &      NBASIS,BRR,NMSH,FCK,NMAX,ALAT,UMAT,NTAY,RHOEPS,LSTE,ICE,
     &      RIJLIST,NWHTAY,ILOGGING,ECORE,ILMAX,WLRI,WLSI,DBETAC,DLWDB)
         IF(LISNAN(DLWDB)) THEN
      CALL MCPATHSR3(NI,BETAC+DBETAC,I_P,I_HMAX,I_VMAX,NEL,NBASISMAX,G1,
     &      NBASIS,BRR,NMSH,FCK,NMAX,ALAT,UMAT,NTAY,RHOEPS,LSTE,ICE,
     &     RIJLIST,NWHTAY,ILOGGING,ECORE,ILMAX,WLRI2,WLSI2,DBETAC,DLWDB)
      CALL MCPATHSR3(NI,BETAC-DBETAC,I_P,I_HMAX,I_VMAX,NEL,NBASISMAX,G1,
     &      NBASIS,BRR,NMSH,FCK,NMAX,ALAT,UMAT,NTAY,RHOEPS,LSTE,ICE,
     &     RIJLIST,NWHTAY,ILOGGING,ECORE,ILMAX,WLRI1,WLSI1,DBETAC,DLWDB)
         ENDIF
      ENDIF
         IF(LISNAN(DLWDB))
     &         DLWDB=-(I_P*(WLRI2-WLRI1)+(WLSI2-WLSI1))/(2*DBETAC)
         WLRIS(NFIRST)=WLRI
         WLSIS(NFIRST)=WLSI
         DLWDBS(NFIRST)=DLWDB
         DLWDBC=DLWDB
         WRITE(6,*) "DBETA=",DBETA
         WRITE(6,*) "APPROX DLWDB(D0)=",DLWDB
C         WRITE(6,*) "W(1)=",
         WRITE(STR,"(A,I3,A)") "(A,",NEL,"I3,A)"
         WRITE(6,STR) "  (",(NI(N),N=1,NEL),")"
         TOT=0.D0
         OPEN(17,FILE="MC",STATUS="UNKNOWN")
         IEQS=IEQSTEPS          
         DO IT=1,IEQSTEPS+IMCSTEPS

            IF(IT.GT.IEQ1.AND.IT.LE.IEQ2) THEN
               IF(MOD((IT-IEQ1)*10,IEQ2-IEQ1).EQ.0) THEN
C.. Now move from the equilibration temperature to the working temp
               BETAC=BETAEQ+(BETA-BETAEQ)*(IT-IEQ1)/(IEQ2-IEQ1)
               DBETAC=DBETA*BETAC/BETA
C.. Invalidate the cache
               CALL CLEARCACHE(LSTDET,NEL,NFIRST)
            CALL MCPATHSR3(NI,BETAC,I_P,I_HMAX,I_VMAX,NEL,NBASISMAX,G1,
     &          NBASIS,BRR,NMSH,FCK,NMAX,ALAT,UMAT,NTAY,RHOEPS,LSTE,
     &          ICE,RIJLIST,NWHTAY,ILOGGING,ECORE,ILMAX,WLRI,WLSI,
     &          DBETAC,DLWDB)
               ENDIF
            ENDIF               

C.. Pick a random new determinant
            IJ=0
            CALL ICOPY(NEL,NI,1,NJ,1)
C            DO I=1,NEL
C               NJ(I)=NI(I)
C            ENDDO
            TT=RAN2(ISEED)
C.. Pick how many electrons we need to change
C            IF(TT.LT.0.9) THEN
C               NCH=1
C            ELSEIF(TT.LT.0.97) THEN
C               NCH=2
C            ELSE
C               NCH=3
C            ENDIF
            NCH=INT(-NEL*LOG(1-RR))+1
C.. We cannot change more electrons than we have
            IF(NCH.GT.NEL) NCH=NEL
C.. Just one excitation for the moment
            NCH=1
            LISVALID=.FALSE.
            DO WHILE (.NOT.LISVALID)
C.. NCH is the number of electrons to change to get the new det
               CALL GENNEWDET2(NJ,NJ,NEL,NBASIS,NBASISMAX,
     &               G1,ISEED,NCH,BRR)
               LISVALID=.TRUE.
C.. We'll just assume the new det is valid for the moment
C.. There's no guarantee that the new determinant will obey the symmetry
C.. constraints, so we keep on generating them until we find a good one
            ENDDO

C.. Calculate RHO_JJ
            IND=IFINDRII(NJ,LSTDET,NEL,NFIRST)
            NIND=0
            WRITE(17,"(2I7)",advance='no') IT,IT-IEQSTEPS
            IF(IND.EQ.0) THEN
               IF (NTAY.LT.0) THEN
C..     NTAY<0 => Exact new method
C..     FCK->RHOIJ
C..     ZIA->RHOIJLAB
C..     UMAT->RHOIJROWS
C..     NMSH->NMRKS
C..     NMAX->RHOIJ1
C..     ALAT->RHOIJ2
C..     BETA->NHG
               DLWDB=GETNAN()
            CALL MCPATHSR3(NJ,BETA,I_P,I_HMAX,I_VMAX,NEL,NBASISMAX,G1,
     &          NBASIS,BRR,NMSH,FCK,NMAX,ALAT,UMAT,NTAY,RHOEPS,LSTE,
     &          ICE,RIJLIST,NWHTAY,ILOGGING,ECORE,ILMAX,WLRJ,WLSJ,
     &          DBETAC,DLWDB)
               NIND=ISTORERII(NJ,WLRJ,WLSJ,DLWDB,LSTDET,WLRIS,WLSIS,
     &               DLWDBS,LISTMAX,NFIRST,NEL)
               ELSE
               DLWDB=GETNAN()
            CALL MCPATHSR3(NJ,BETAC,I_P,I_HMAX,I_VMAX,NEL,NBASISMAX,G1,
     &          NBASIS,BRR,NMSH,FCK,NMAX,ALAT,UMAT,NTAY,RHOEPS,LSTE,
     &          ICE,RIJLIST,NWHTAY,ILOGGING,ECORE,ILMAX,WLRJ,WLSJ,
     &          DBETAC,DLWDB)
               NIND=ISTORERII(NJ,WLRJ,WLSJ,DLWDB,LSTDET,WLRIS,WLSIS,
     &               DLWDBS,LISTMAX,NFIRST,NEL)
               ENDIF
            ELSE
               WLRJ=WLRIS(IND)
               WLSJ=WLSIS(IND)               
            ENDIF
           WRITE(17,"(2E25.16)",advance='no') 
     &                            EXP(WLRI*I_P+WLSI),EXP(WLRJ*I_P+WLSJ)
            WRITE(STR,"(A,I3,A,I3,A)") "(A,",NEL,"I3,A,",NEL,"I3,A)"
           WRITE(17,STR,advance='no') "  (",(NI(N),N=1,NEL),") 
     &         (",(NJ(N),N=1,NEL),")->"
C..  At this stage we have decomposed ln W_I = p ln RHO_II + ln S_I
C..  Although S_I should be >0, our approximation to it may be 0 or <0,
C..  which leads to ln S_I (=WLSI) = -NaN.
C..  As our acceptance probabilities are W_J/W_I, a value of W_J that is
C..  <=0 (caused by an S_J<=0) would never be accepted, so we reject W_J
C..  where ln S_I=NaN
C..  NB - this NaN test may not be portable
            IF(LISNAN(WLSJ)) THEN
C.. if we've got a nan as our weight we don't accept
               LACC=.FALSE.
            ELSE
               DLRAT=I_P*(WLRJ-WLRI)+(WLSJ-WLSI)
               IF(DLRAT.LT.0.D0) THEN
                  RAT=EXP(DLRAT)
                  LACC=.TRUE. 
                  IF(RAN2(ISEED)*1.0.GT.RAT) LACC=.FALSE.
               ELSE
                  LACC=.TRUE.
C.. use up a random number to keep consistency.
                  TT=RAN2(ISEED)
                  TT=TT+1
               ENDIF
            ENDIF   
C.. We see if we've calculated DLWDB.  If not, a NaN is stored in its place,
C.. so we must calc it.


            IF(LACC) THEN
               IF(IND.NE.0) DLWDB=DLWDBS(IND)
               IF(LISNAN(DLWDB)) THEN
                  IF (NTAY.LT.0) THEN
C..     NTAY<0 => Exact new method
C..     FCK->RHOIJ
C..     ZIA->RHOIJLAB
C..     UMAT->RHOIJROWS
C..     NMSH->NMRKS
C..     NMAX->RHOIJ1
C..     ALAT->RHOIJ2
C..     BETA->NHG
                  CALL MCPATHSR3(NJ,BETA,I_P,I_HMAX,I_VMAX,NEL,
     &             NBASISMAX,G1,NBASIS,BRR,NMSH,NMAX,NMAX,ALAT,UMAT,
     &               NTAY,RHOEPS,LSTE,
     &             ICE,RIJLIST,NWHTAY,ILOGGING,ECORE,ILMAX,WLRI1,WLSI1,
     &             0.D0,0.D0)
                  CALL MCPATHSR3(NJ,BETA,I_P,I_HMAX,I_VMAX,NEL,
     &             NBASISMAX,G1,NBASIS,BRR,NMSH,ALAT,NMAX,ALAT,UMAT,
     &               NTAY,RHOEPS,LSTE,
     &               ICE,RIJLIST,NWHTAY,ILOGGING,ECORE,WLRI2,WLSI2,
     &             0.D0,0.D0)
                  ELSE
                  CALL MCPATHSR3(NJ,BETAC-DBETAC,I_P,I_HMAX,I_VMAX,NEL,
     &              NBASISMAX,G1,NBASIS,BRR,NMSH,FCK,NMAX,ALAT,UMAT,
     &               NTAY,RHOEPS,LSTE,
     &             ICE,RIJLIST,NWHTAY,ILOGGING,ECORE,ILMAX,WLRI1,WLSI1,
     &             0.D0,0.D0)
                  CALL MCPATHSR3(NJ,BETAC+DBETAC,I_P,I_HMAX,I_VMAX,NEL,
     &              NBASISMAX,G1,NBASIS,BRR,NMSH,FCK,NMAX,ALAT,UMAT,
     &               NTAY,RHOEPS,LSTE,
     &             ICE,RIJLIST,NWHTAY,ILOGGING,ECORE,ILMAX,WLRI2,WLSI2,
     &             0.D0,0.D0)
                  ENDIF
                  DLWDB=-(I_P*(WLRI2-WLRI1)+(WLSI2-WLSI1))/(2*DBETAC)
                  IF(IND.NE.0) DLWDBS(IND)=DLWDB
               ENDIF
C.. if there's space, we store
               IF(NIND.NE.0) DLWDBS(NIND)=DLWDB

               WLRI=WLRJ
               WLSI=WLSJ
               II=IJ
               DLWDBC=DLWDB
               CALL ICOPY(NEL,NJ,1,NI,1)
            ENDIF      
            IF(IEQS.EQ.0) THEN
               TOT=TOT+DLWDBC
               SUMSQ=SUMSQ+DLWDBC*DLWDBC
            ELSE
               IEQS=IEQS-1
            ENDIF
            WRITE(STR,"(A,I3,A)") "(A,",NEL,"I3,A,2E25.16)"            
            WRITE(17,STR) "  (",(NI(N),N=1,NEL),")",DLWDBC,TOT
            IF(MOD(IT,100).EQ.0) WRITE(6,*) IT
            IF(MOD(IT,10).EQ.0) CALL FLUSH(17)
         ENDDO
         CLOSE(17)
         DMONTECARLO2=TOT/IMCSTEPS
         WRITE(6,*) "MC STDEV=",
     &      SQRT(ABS(SUMSQ/IMCSTEPS-DMONTECARLO2**2))
         IF(I_VMAX.GT.0) then
             deallocate(RIJLIST)
             call LogMemDealloc(thisroutine,tagRIJLIST)
         end if
         deallocate(LSTE,ICE,LSTDET,DLWDBS,WLRIS,WLSIS)
         call LogMemDealloc(thisroutine,tagLSTE)
         call LogMemDealloc(thisroutine,tagICE)
         call LogMemDealloc(thisroutine,tagLSTDET)
         call LogMemDealloc(thisroutine,tagDLWDBS)
         call LogMemDealloc(thisroutine,tagWLRIS)
         call LogMemDealloc(thisroutine,tagWLSIS)

         call halt_timer(proc_timer)
      END

      SUBROUTINE GENNEWDET2(NI,NJ,NEL,NBASIS,NBASISMAX,G1,ISEED,NCH,BRR)
         use SystemData, only: BasisFN
         IMPLICIT NONE
         INTEGER nBasisMax(5,*),NI(NEL),NJ(NEL),NQN(5)
         TYPE(BasisFN) G1(NBASIS)
         INTEGER NCH,ND,NEL,BRR(NBASIS),NBASIS,ISEED
         LOGICAL L
         CHARACTER*20 STR
         INTEGER IEL,IQN,ISGN,I,IT
         INTEGER IFINDBASISFN
         REAL*8 RAN2
         IF(NBASISMAX(3,3).EQ.1) THEN
C.. Generic spatial basis
            CALL GENNEWDET3(NI,NJ,NEL,NBASIS,NBASISMAX,G1,ISEED,NCH,BRR)
            RETURN
         ENDIF
C.. Copy NI to NJ
         CALL ICOPY(NEL,NI,1,NJ,1)
         L=.TRUE.
         ND=NCH
C.. we need to keep on doing this until we make a valid choice
         DO WHILE(L)
            IEL=INT(RAN2(ISEED)*NEL)+1
            CALL ICOPY(4,G1(NJ(IEL)),1,NQN,1)
            IQN=3+(NBASISMAX(4,2)-NBASISMAX(4,1))/2
C.. Sometimes no spin freedom
            IQN=INT(RAN2(ISEED)*IQN)+1
            ISGN=INT(RAN2(ISEED)*(NBASISMAX(IQN,2)-NBASISMAX(IQN,1)+1))
     &         +NBASISMAX(IQN,1)
            IF(IQN.EQ.4) THEN
C.. change the spin
               NQN(4)=-NQN(4)
            ELSE
               NQN(IQN)=NQN(IQN)+ISGN
            ENDIF
            CALL PBC(NQN,NBASISMAX)
            IT=IFINDBASISFN(NQN,G1,NBASIS)
            IF(IT.EQ.0) THEN 
               L=.TRUE.
            ELSE
               L=.FALSE.
            ENDIF
C.. make sure the new basis fn isn't already in the det.  if so, go round again
            DO I=1,NEL
               IF(NJ(I).EQ.IT) L=.TRUE.
            ENDDO
            IF(.NOT.L) THEN
               ND=ND-1
               NJ(IEL)=IT
               CALL SORTI(NEL,NJ)
C.. if we've more electrons to change, we go round again
               IF(ND.GT.0) L=.TRUE.
            ENDIF
         ENDDO
         RETURN
      END
 

C.. gen a new det from this one in a generic spatial basis.
C.. We do this by exciting an electron into a spinorbital of close energy.
C.. This does not take into account any symmetries.
      SUBROUTINE GENNEWDET3(NI,NJ,NEL,NBASIS,NBASISMAX,G1,ISEED,NCH,BRR)
         IMPLICIT NONE
         INTEGER nBasisMax(5,*),NI(NEL),NJ(NEL),NQN(5),G1(*)
         INTEGER NCH,ND,BRR(NBASIS),NBASIS,NEL,ISEED
         LOGICAL L
         CHARACTER*20 STR
         REAL*8 RN
         INTEGER IGETENEIGHBOUR,IGETSNEIGHBOUR
         INTEGER IEL,ISGN,IT,I,IDIST
         REAL*8 RAN2
C.. Copy NI to NJ
         CALL ICOPY(NEL,NI,1,NJ,1)
         L=.TRUE.
         ND=NCH
C.. we need to keep on doing this until we make a valid choice
C.. We keep spin fixed here.
         DO WHILE(L)
            L=.FALSE.
            IEL=INT(RAN2(ISEED)*NEL)+1
            ISGN=INT(RAN2(ISEED)+0.5)*2-1
            IF(RAN2(ISEED).LT.0.25) THEN
C.. 1/4 prob of changing the spin
               IT=IGETSNEIGHBOUR(NI(IEL),NBASIS,BRR,ISGN,G1)
            ELSE
C.. change the energy level.  Have an exponential distribution of
C.. distance
               RN=0.D0
               DO WHILE(RN.EQ.0.D0)
                  RN=RAN2(ISEED)
               ENDDO
               IDIST=0
               DO WHILE(RN.LE.1)
                  RN=RN*2
                  IDIST=IDIST+1
               ENDDO
               IT=IGETENEIGHBOUR(NI(IEL),NBASIS,BRR,ISGN,G1,IDIST)
            ENDIF
C.. make sure the new basis fn isn't already in the det.  if so, go round again
            DO I=1,NEL
               IF(NJ(I).EQ.IT) L=.TRUE.
            ENDDO
            IF(.NOT.L) THEN
               ND=ND-1
               NJ(IEL)=IT
               CALL SORTI(NEL,NJ)
C.. if we've more electrons to change, we go round again
               IF(ND.GT.0) L=.TRUE.
            ENDIF
         ENDDO
         RETURN
      END
      INTEGER FUNCTION IFINDBASISFN(NQNS,G1,NBASIS)
         use SystemData, only: BasisFN
         IMPLICIT REAL*8 (A-H,O-Z)
         INTEGER NBASIS
         TYPE(BasisFN) G1(NBASIS),NQNS
         LOGICAL L
         DO I=1,NBASIS
            L=.TRUE.
            DO J=1,3
               IF(G1(I)%k(J).NE.NQNS%k(J)) L=.FALSE.
            ENDDO
            IF(G1(I)%Sym%s.NE.NQNS%Sym%s) L=.FALSE.
            IF(G1(I)%Ms.NE.NQNS%Ms) L=.FALSE.
            IF(L) THEN
               IFINDBASISFN=I
               RETURN
            ENDIF
         ENDDO
         IFINDBASISFN=0
         RETURN
      END

      SUBROUTINE CLEARCACHE(LSTDET,NEL,NFIRST)
         INTEGER LSTDET(NEL+2,*)
C.. Clear the first node, and end the chain
         LSTDET(NEL+2,NFIRST)=0
         LSTDET(1,NFIRST)=0
         RETURN
      END

C.. Store the dets in a linked list (sorted).
C.. Each record has N1,N2,...NN,INDEX,NEXTNODE
C.. where INDEX is the index of DLWDB, WLRI, and WLSI in various arrays
      INTEGER FUNCTION  IFINDRII(NI,LSTDET,NEL,NFIRST)
         INTEGER LSTDET(NEL+2,*),NI(NEL)
         LOGICAL LSAME
         NODE=NFIRST
         DO WHILE(NODE.NE.0)
            LSAME=.TRUE.
            DO I=1,NEL
               IF(LSTDET(I,NODE).NE.NI(I)) LSAME=.FALSE.
            ENDDO
            IF(LSAME) THEN
C               WRITE(6,*) "Found ",NODE
               IFINDRII=LSTDET(NEL+1,NODE)
               RETURN
            ENDIF
            NODE=LSTDET(NEL+2,NODE)
         ENDDO
         IFINDRII=0
         RETURN
      END

C.. Run through LSTDET, and if there's space, store NJ
      INTEGER FUNCTION ISTORERII(NI,WLRI,WLSI,DLWDB,LSTDET,WLRIS,WLSIS,
     &               DLWDBS,LISTMAX,NFIRST,NEL)
         INTEGER LSTDET(NEL+2,*),NI(NEL)
         REAL*8 WLRIS(*),WLSIS(*),DLWDBS(*)
C.. We need to go through the whole list to find the node before NJ, and the
C.. node after.  We continue and then find the end of the list.
         NODE=NFIRST
         NBEFORE=0
         NAFTER=0
         NCOUNT=0
         IF(LSTDET(1,NFIRST).NE.0) THEN
         DO WHILE(NODE.NE.0)
            I=1
            IF(NAFTER.EQ.0) THEN
               DO WHILE(I.LE.NEL)
                  NEWI=I
                  IF(LSTDET(I,NODE).LT.NI(I)) NEWI=NEL+2
                  IF(LSTDET(I,NODE).GT.NI(I)) NEWI=NEL
                  I=NEWI
                  I=I+1
               ENDDO
               IF(I.EQ.NEL+1) THEN
C.. all the N in the NODE are greater than NI's
C.  so this is NAFTER)
                  NAFTER=NODE
               ENDIF
            ENDIF
            NCOUNT=NCOUNT+1
            IF(NAFTER.EQ.0) NBEFORE=NODE
            NODE=LSTDET(NEL+2,NODE)
         ENDDO
         ENDIF         
C.. Create a new node if we can
         IF(NCOUNT.LT.LISTMAX) THEN
            NODE=NCOUNT+1
            CALL ICOPY(NEL,NI,1,LSTDET(1:NEL,NODE),1)
            LSTDET(NEL+1,NODE)=NODE
            LSTDET(NEL+2,NODE)=NAFTER
            IF(NBEFORE.NE.0) THEN
               LSTDET(NEL+2,NBEFORE)=NODE
            ELSE
               NFIRST=NODE
            ENDIF
            ISTORERII=NODE
            WLRIS(NODE)=WLRI
            WLSIS(NODE)=WLSI
            DLWDBS(NODE)=DLWDB
C            WRITE(6,*) "Store ",NODE
         ELSE
            ISTORERII=0
         ENDIF
         RETURN
      END

       REAL*8 FUNCTION DMONTECARLOEXWI(NDET,WLRIS,WLSIS,DLWDBS,I_P,
     &         IMCSTEPS,
     &         G1,NMRKS,NEL,NBASISMAX,NBASIS,BRR,IEQSTEPS,
     &         ILOGGING)
         use global_utilities
         IMPLICIT REAL*8 (A-H,O-Z)
         INTEGER NDET
         INTEGER ISEED
         INTEGER II,IJ
         INTEGER NI(NEL), NJ(NEL)
         LOGICAL LACC
         INTEGER BRR(NBASIS)
         INTEGER G1(*),NMRKS(NEL,NDET),nBasisMax(5,*)
         REAL*8 DLWDBS(NDET),WLRIS(NDET),WLSIS(NDET)
         LOGICAL LISNAN
         REAL*8 RAN2
         type(timer), save :: proc_timer

C.. NI, NJ are the quantum numbers of 
         proc_timer%timer_name='DMC       '
         call set_timer(proc_timer)
C.. Randomize the seed:
         ISEED=-70001
CINT(SECNDS(0.0))
         IF(MOD(ISEED,2).EQ.0) ISEED=ISEED-1
C.. THe seed must be odd
C.. Store the dets in a linked list (sorted).
C.. Each record has N1,N2,...NN,INDEX,NEXTNODE
C.. where INDEX is the index of DLWDB, WLRI, and WLSI in various arrays

C.. Hard code the start position as the NEL lowest energy basis fns
         DO I=1,NEL
            NI(I)=BRR(I)
         ENDDO
C.. NI will not now be in order of basis fn, so we need to sort it
         CALL SORTI(NEL,NI)
C.. Now find which number determinant this corresponds to
         II=IFINDDET2(NI,NEL,G1,NMRKS,NBASIS,NDET)
         WLRI=WLRIS(II)
         WLSI=WLSIS(II)
         DLWDB=DLWDBS(II)
         WRITE(6,*) "DLWDB(1)=",DLWDB
         WRITE(6,*) "WLRI(1)=",WLRI
         WRITE(6,*) "WLSI(1)=",WLSI
         TOT=0.D0
         OPEN(17,FILE="MC",STATUS="UNKNOWN")
         IEQS=IEQSTEPS          
         DO IT=1,IEQSTEPS+IMCSTEPS
C.. Pick a random new determinant
            IJ=0
            CALL ICOPY(NEL,NI,1,NJ,1)

            DO WHILE (IJ.EQ.0)
              CALL GENNEWDET2(NJ,NJ,NEL,NBASIS,NBASISMAX,G1,ISEED,1,BRR)
               IJ=IFINDDET2(NJ,NEL,G1,NMRKS,NBASIS,NDET)
C               IF(IJ.EQ.0) WRITE(10,*) "Another IJ"
C.. There's no guarantee that the new determinant will obey the symmetry
C.. constraints, so we keep on generating them until we find a good one
            ENDDO

C.. Calculate RHO_JJ
            IND=IJ
            WRITE(17,"(2I7)",advance='no') IT,IT-IEQSTEPS
            WLRJ=WLRIS(IND)
            WLSJ=WLSIS(IND)
           WRITE(17,"(2E25.16)",advance='no')
     &                            EXP(WLRI*I_P+WLSI),EXP(WLRJ*I_P+WLSJ)
            WRITE(17,"(A,I3,A,I3,A)",advance='no')
     &                                          "  (",II,"),(",IJ,")->"
C..  At this stage we have decomposed ln W_I = p ln RHO_II + ln S_I
C..  Although S_I should be >0, our approximation to it may be 0 or <0,
C..  which leads to ln S_I (=WLSI) = -NaN.
C..  As our acceptance probabilities are W_J/W_I, a value of W_J that is
C..  <=0 (caused by an S_J<=0) would never be accepted, so we reject W_J
C..  where ln S_I=NaN
C..  NB - this NaN test may not be portable
            IF(LISNAN(WLSJ)) THEN
               LACC=.FALSE.
            ELSE
               DLRAT=I_P*(WLRJ-WLRI)+(WLSJ-WLSI)
C               RAT=WJ/WI
               IF(DLRAT.LT.0.D0) THEN
                  RAT=EXP(DLRAT)
                  LACC=.TRUE. 
                  RNUM=RAN2(ISEED)*1.D0
                  IF(RNUM.GT.RAT) LACC=.FALSE.
               ELSE
                  LACC=.TRUE.
C.. use up a random number to keep consistency.
                  TT=RAN2(ISEED)
                  TT=TT+1
               ENDIF
            ENDIF
            IF(LACC) THEN
               DLWDB=DLWDBS(IND)
               WLRI=WLRJ
               WLSI=WLSJ
               II=IJ
               CALL ICOPY(NEL,NJ,1,NI,1)
            ENDIF      
            IF(IEQS.EQ.0) THEN
               TOT=TOT+DLWDB
               SUMSQ=SUMSQ+DLWDB*DLWDB
            ELSE
               IEQS=IEQS-1
            ENDIF
            WRITE(17, "(A,I3,A,2E25.16)") "  (",II,")",DLWDB,TOT
c            IF(MOD(IT,100).EQ.0) WRITE(6,*) IT
         ENDDO
         CLOSE(17)
         DMONTECARLOEXWI=TOT/IMCSTEPS
         WRITE(6,*) "MC STDEV=",SQRT(SUMSQ/IMCSTEPS-DMONTECARLOEXWI**2)
         call halt_timer(proc_timer)
      END

      SUBROUTINE PBC(NQN, NBASISMAX)
         INTEGER NQN(5), nBasisMax(5,*)
         INTEGER MPN,MMN,L,IQN,NMAXX
         LOGICAL TALLOW
         IF(NBASISMAX(1,3).EQ.0) THEN
C.. PBC non-tilted
            DO IQN=1,3
               IF(NQN(IQN).GT.NBASISMAX(IQN,2))
     &            NQN(IQN)=NBASISMAX(IQN,1)
               IF(NQN(IQN).LT.NBASISMAX(IQN,1))
     &            NQN(IQN)=NBASISMAX(IQN,2)
            ENDDO
         ELSEIF(NBASISMAX(1,3).EQ.1) THEN
C.. PBC tilted
            TALLOW=.FALSE.
            DO WHILE(.NOT.TALLOW)
               TALLOW=.TRUE.
               NMAXX=NBASISMAX(1,5)
               AX=NBASISMAX(1,4)
               AY=NBASISMAX(2,4)
C.. (XX,YY) is the position of the bottom right corner of the unit cell
               XX=((AX+AY)/2.D0)*NMAXX
               YY=((AY-AX)/2.D0)*NMAXX
               MX=XX*AX+YY*AY
               MY=XX*AY-YY*AX
               I=NQN(1)
               J=NQN(2)
               KX=I*AX+J*AY
               KY=I*AY-J*AX
               IF(KX.GT.MX) THEN
                  TALLOW=.FALSE.
                  NQN(1)=NQN(1)-AX*NMAXX
                  NQN(2)=NQN(2)-AY*NMAXX
               ENDIF
               IF(KY.GT.MY) THEN
                  TALLOW=.FALSE.
                  NQN(1)=NQN(1)-AY*NMAXX
                  NQN(2)=NQN(2)+AX*NMAXX
               ENDIF
               IF(KX.LE.-MX) THEN
                  TALLOW=.FALSE.
                  NQN(1)=NQN(1)+AX*NMAXX
                  NQN(2)=NQN(2)+AY*NMAXX
               ENDIF
               IF(KY.LE.-MY) THEN
                  TALLOW=.FALSE.
                  NQN(1)=NQN(1)+AY*NMAXX
                  NQN(2)=NQN(2)-AX*NMAXX
               ENDIF
            ENDDO
         ELSEIF(NBASISMAX(1,3).EQ.3) THEN
C.. non-PBC tilted
            NMAXX=NBASISMAX(1,2)
            NMINX=-NMAXX
            MPN=NQN(1)+NQN(2)
            MMN=NQN(1)-NQN(2)
            NQN(1)=(MPN+MMN)/2
            NQN(2)=(MPN-MMN)/2
         ELSEIF(NBASISMAX(1,3).EQ.4) THEN            
C.. non-PBC non-tilted - leave things as they are
         ENDIF
         RETURN
      END
      INTEGER FUNCTION IGETENEIGHBOUR(IEL,NBASIS,BRR,ISGN,G1,IDIST)
         use SystemData, only: BasisFN
         IMPLICIT NONE
         INTEGER IEL,NBASIS,BRR(NBASIS),ISGN
         TYPE(BasisFN) G1(NBASIS)
         INTEGER I,J,NQN4,IDIST,IDIST2
         DO I=1,NBASIS
            IF(BRR(I).EQ.IEL) J=I
         ENDDO
         IDIST2=IDIST
C.. make sure we have an orbital of the correct spin
         DO WHILE(IDIST2.NE.0)
            J=J+ISGN
            IF(J.LT.1) J=NBASIS
            IF(J.GT.NBASIS) J=1
            IF(G1(BRR(J))%Ms.EQ.G1(IEL)%Ms) IDIST2=IDIST2-1
         ENDDO 
         IGETENEIGHBOUR=BRR(J)  
         RETURN
      END

C.. Find a neighbour in a different degenerate manifold.
C.. THIS IS NOT ERGODIC
      INTEGER FUNCTION IGETENEIGHBOURDEG(IEL,NBASIS,BRR,ISGN,G1,ISEED)
         use SystemData, only: BasisFN
         IMPLICIT NONE
         INTEGER IEL,NBASIS,BRR(NBASIS),ISGN
         TYPE(BasisFN) G1(NBASIS)
         INTEGER I,J,NQN4,DEGS1,DEGS2,ODEG,NDEG,OJ,ISEED,J2
         REAL*8 RAN2
         DO I=1,NBASIS
            IF(BRR(I).EQ.IEL) J=I
         ENDDO
C.. Old degeneracy level
         ODEG=G1(IEL)%k(3)
C.. new degen level
         NDEG=ODEG+ISGN
C.. if we fall off the bottom or top, wrap round
         IF(NDEG.LT.1) NDEG=G1(BRR(NBASIS))%k(3)
         IF(NDEG.GT.G1(BRR(NBASIS))%k(3)) NDEG=1
         DEGS1=0
         DEGS2=0
         OJ=J
         DO WHILE(DEGS2.EQ.0)
            IF(DEGS1.EQ.0.AND.G1(BRR(J))%k(3).EQ.NDEG) THEN
C.. we've found the first of our new degen group
               DEGS1=J
            ENDIF
            IF(DEGS1.NE.0.AND.G1(BRR(J))%k(3).NE.NDEG) THEN
C.. we found the last of our degeneracy group
               DEGS2=OJ
            ENDIF
            OJ=J
            J=J+ISGN
C.. if we fall off the bottom or top, wrap round
            IF(J.LT.1) J=NBASIS
            IF(J.GT.NBASIS) J=1
         ENDDO
C.. Now pick these orbitals randomly until we find one of the right spin
         J=0
         I=0
         IF(ISGN.EQ.-1) I=1
         DO WHILE(J.EQ.0)
            J=DEGS1+I+RAN2(ISEED)*(DEGS2-DEGS1+ISGN)
C.. CHeck spin
            IF(G1(BRR(J))%Ms.NE.G1(IEL)%Ms) J=0
         ENDDO
         IGETENEIGHBOURDEG=BRR(J)  
         RETURN
      END
      INTEGER FUNCTION IGETSNEIGHBOUR(IEL,NBASIS,BRR,ISGN,G1)
         use SystemData, only: BasisFN
         IMPLICIT NONE
         INTEGER IEL,NBASIS,BRR(NBASIS),ISGN
         TYPE(BasisFN) G1(NBASIS)
         INTEGER I,J,NQN4
         DO I=1,NBASIS
            IF(BRR(I).EQ.IEL) J=I
         ENDDO
C.. make sure we have an orbital of the correct spin
C.. See if there's an orbital with the same energy
         DO WHILE(G1(BRR(J))%Ms.EQ.G1(IEL)%Ms.OR.IEL.EQ.BRR(J))
            J=J+ISGN
            IF(J.LT.1) J=NBASIS
            IF(J.GT.NBASIS) J=1
         ENDDO 
         IGETSNEIGHBOUR=BRR(J)  
         RETURN
      END


