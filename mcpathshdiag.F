
C.. 29/6/06  Based on FMCPR3B.
C.. This function does not calculate RHO elements, but instead calculates
C.. H elements.  These are then sent to a different diagonalizer, which allows
C.. a range of different values of beta to be used.

C.. A function to loop recursively over each node set choosing a different
C.. node for each set.  All nodes are distinct.  Paths IJIKJI etc.
C.. are generated by permutation from IJKI, and summed up to length I_HMAX
C.. using the appropriate weightings (Z-sums) from CALCPATH7.(26/01/04).

C.. This version doesn't need to generate excitation lists, so 
C.. calculates excitations on the fly.  Overheads are bigger, but
C.. scaling should be better. (9/3/05)

C.. Various flags are available in NWHTAY
C.. Bit 8 (512).  If set the lowest 8 bits of NWHTAY correspond to freezing data.
C..                  (which is no longer implemented)
C.. Bit 1 (2).  If 0, then allow connections to anywhere in a graph
C..             If 1, then only allow connections to the root
C.. Bit 2 (4).  If 0 allow all topologies.
C..             If 1, disallow a det if it's already connected to one in the graph
C.. Bit 3 (8).  If 0 allow all types of excitations
C..             If 1 only allow singles.
C.. Bit 4 (16)  If 0 allow all types of excitations
C.,             If 1, only allow doubles.
      RECURSIVE FUNCTION FMCPR3B2(NI,BETA,I_P,IPATH,I_V,NEL,
     &   NBASISMAX,G1,NBASIS,BRR,NMSH,FCK,TMat,NMAX,ALAT,UMAT,NTAY,
     &   RHOEPS,I_VIND,HIJ,NWHTAY,I_HMAX,LOCTAB,
     &   ILOGGING,TSYM,ECORE,DBETA,DLWDB,HIJS,L,LT,IFRZ,FSCALE,MP2E,
     &   NTOTAL,I_VMAX,EREF,WREF)
         USE HElement 
         IMPLICIT NONE
         INCLUDE 'basis.inc'
         INCLUDE 'vmc.inc'
         TYPE(BasisFN) G1(*)
         INTEGER I_V,NEL,I_P,NBASISMAX(*),NBASIS,BRR(*),NMSH,NMAX
         INTEGER NTAY,I_VIND,NWHTAY,ILOGGING,J,K,I_VMAX,ISYM(5),II
         INTEGER I
         COMPLEX*16 FCK(*)
         TYPE(HElement) TMat(*), UMAT(*),R
         REAL*8 ALAT(*),ECORE
         TYPE(HDElement) TOTAL,FMCPR3B2
         TYPE(HDElement) CALCPATHS_N
         INTEGER IPATH(NEL,0:I_V)
         TYPE(HElement) HIJ(0:I_V,0:I_V),RH
         TYPE(HDElement) DLWDB,DLWDB2,EREF,WREF
         INTEGER INODE(NEL)
         INTEGER NI(NEL),NJ(NEL)
         INTEGER I_HMAX
         REAL*8 BETA,RHOEPS
         LOGICAL TSYM,T
         LOGICAL TLOG,TLOG2,TLOG3,TLOG4,TLOG5,TLOG6
         REAL*8 DBETA
         TYPE(HElement) HIJS(0:I_V)
         INTEGER ICLS
         INTEGER NMEM(*),NMEMLEN
         POINTER(IP_NMEM,NMEM)
         POINTER(IP_CURGEN,CURGEN)
         POINTER(IP_OGEN,OGEN)
         INTEGER OGEN(*)
         INTEGER CURGEN(*)
         INTEGER LOCTAB(3,I_V)
         INTEGER LOCTAB2(3,I_V)
         LOGICAL TFAIL,TNEXT
         INTEGER L,LT,IVLEVEL,IEXFROM,IVLMAX,IVLMIN
         INTEGER ICMPDETS
         INTEGER IC
         INTEGER IFRZ(0:NBASIS,I_V),IFRZ2(0:NBASIS)
         INTEGER EX(2,2),ICIL,ICILMAX
         INTEGER STORE(6)
         REAL*8 FSCALE,FSC2
         TYPE(HDElement) MP2E,NTOTAL
         INTEGER EXFLAG

         REAL*8 GETHELEMENT
         REAL*8 BETADATA(0:1)
         LOGICAL ISCONNECTEDDET

         REAL*8 SumX, SumY, SumXY, SumXsq, SumYsq
         SAVE SumX, SumY, SumXY, SumXsq, SumYsq
         SELECT CASE (IAND(NWHTAY,24))
         CASE(0)
C.. Allow both singles and doubles
            EXFLAG=3
         CASE(8)
C.. only singles
            EXFLAG=1
         CASE(16)
            EXFLAG=2
         CASE(24)
            STOP "Invalid combination of flags in NWHTAY"
         END SELECT
         IF(I_VIND.EQ.0) THEN
C.. 1st time in
            CALL IAZZERO(IFRZ(0,1),NBASIS+1) 
            IF(IAND(NWHTAY,8).NE.0) THEN
C.. Force freexing
               IFRZ(0,1)=NWHTAY
            ELSE
               IFRZ(0,1)=0
            ENDIF
         ENDIF
         CALL ICOPY(NBASIS+1,IFRZ(0,I_VIND+1),1,IFRZ2,1) 
         
C            DO I=0,NBASIS
C               WRITE(10,"(I2,$)"),IFRZ2(I)
C            ENDDO
C         WRITE(10,*) "V_",I_VIND
C.. LOCTAB(1,1) is the address of the generator used to create node 1 in
C.. the path (i.e. J).  LOCTAB(1,2) is the length of the generator (i.e. 
C.. the amount of memory used to store it)
         TLOG=BTEST(ILOGGING,0)
         TLOG6=BTEST(ILOGGING,2)
         TLOG2=BTEST(ILOGGING,3)
         TLOG3=BTEST(ILOGGING,12)
         TLOG4=BTEST(ILOGGING,9)
         TLOG5=BTEST(ILOGGING,6)
         TLOG=TLOG.AND..NOT.TLOG4
         TOTAL=0.D0
         LT=LT+1
C.. This is the current node (set by our parent)         
         CALL ICOPY(NEL,IPATH(1:NEL,I_VIND),1,INODE,1)
         RH=GETHELEMENT2(INODE,INODE,NEL,NBASISMAX,
     &           G1,NBASIS,BRR,NMSH,FCK,TMat,NMAX,ALAT,UMAT,0,ECORE)
         HIJ(I_VIND,I_VIND)=RH
C.. we note that if this node has rho_II=0 (i.e. RH=0) then we just return
         IF(.NOT.(RH.AGT.0.D0)) THEN
            FMCPR3B2=0.D0
            RETURN
         ENDIF
         IF(I_VIND.EQ.(I_V-1)) THEN
C.. If we're at the last node we call CALCPATHS to generate all 
C.. the paths for it
            CALL ICOPY(NEL,NI,1,IPATH(1:NEL,I_V),1) 
            IF(TLOG6) THEN
               IF(.NOT.TLOG3) THEN
                  CALL WRITEPATH(10,IPATH,I_V,NEL,.FALSE.)
               ELSE
                  CALL WRITEPATHEX(10,IPATH,I_V,NEL,.FALSE.)
               ENDIF
            ENDIF
!            IF(TLOG2) CALL WRITERHOMAT(10,HIJ,I_V,NEL,.TRUE.)
C.. 
            ICLS=0
C.. Store beta in RHOII(1) (calling it BETADATA)
            BETADATA(0)=0.D0
            BETADATA(1)=BETA
            TOTAL=TOTAL+
     &         CALCPATHS_N(IPATH,BETADATA,HIJ,I_V,I_HMAX,
     &         I_P,FSCALE,NEL,I_VMAX,ILOGGING,DBETA,DLWDB2,HIJS,ICLS)
            NTOTAL=NTOTAL+TOTAL
C.. Sum up the components of <D|H exp(-b H)|D>
            DLWDB=DLWDB+DLWDB2
!        write (*,*) "from mcpathshdiag, EREF=",EREF
            If (TVARCALC(I_V)) Then
              Call CalcWriteGraphPGen(10,IPATH,I_V,nEl,LOCTAB,G1,
     &                                nBasisMax,UMat,NMAX,nBasis,R)
              !X are the terms in the numerator, Y are the terms in the denominator
              SumX  =SumX   + DLWDB2%v-EREF%v*TOTAL%v
              SumY  =SumY   + TOTAL%v+WREF%v*R%v
              SumXsq=SumXsq + (DLWDB2%v-(EREF%v*TOTAL%v))**2/R%v
              SumYsq=SumYsq + R%v*(TOTAL%v/R%v+WREF%v)**2
              SumXY =SumXY  + (TOTAL%v/R%v+WREF%v)
     &                                  *(DLWDB2%v-(EREF%v*TOTAL%v))
            End If

            IF(TLOG5) THEN
!  Log XIJS (usually for debugging), and the pgen
!  NMAX has Arr hidden in it
              CALL CalcWriteGraphPGen(10,IPATH,I_V,nEl,LOCTAB,G1,
     &            nBasisMax,UMat,NMAX,nBasis,R)
                  WRITE(10,"(3E25.16, I7)") TOTAL,R,DLWDB2,ICLS
            ELSE
               IF(TLOG) WRITE(10,"(2E25.16, I7)") TOTAL,DLWDB2,ICLS
            ENDIF
            L=L+1
            FMCPR3B2=TOTAL
C.. Calculate the MP2 Energy
C.. NMAX has ARR hidden in it.
!               CALL ADDMP2E(HIJS,NMAX,NBASIS,IPATH,NEL,TLOG,MP2E)
               CALL AddMPEnergy(Hij,i_V,i_vmax,NMAX,nBasis,
     &            iPath,nEl,tLog,ECORE,MP2E)
            IF(TLOG4.AND.MOD(L,1000).EQ.0) THEN
C.. log every 1000
               WRITE(10,"(I10,3E25.16)") L,NTOTAL,DLWDB,MP2E
               CALL FLUSH(10)
            ENDIF
            RETURN
         ENDIF
C.. We recurse over all possibilities for the next node:
C..  1) Nodes connected to us (excluding those connected to previous nodes)
C..     We perform this exclusion by looking at whether a newly
C..     generated node connected to us is connected to a previous node
C..     which existed before the one we were generated from.  (If we are
C..     connected to a node created after the one we were created from,
C..     we have been specifically excluded from that node's excitation
C..     list because we were connected to a prior node, so we, now being
C...    generated from that prior node, now need to be counted)
C..  2) Nodes connected to previous (i.e. before the one we're connected to )
C..         nodes which have not yet been processed
C..        (excluding those which are connected to further previous nodes. 
C..         NB: These may be connected to us, but will have been excluded
C..         in 1 as they are connected to previous nodes to 1
C..  3) Further recursions down the (direct) line from us back to I.  Previous 
C..        completed lines will have been entirely processed, so we don't
C..        need to attempt to add nodes to them (but we do need to ensure
C..        that new nodes don't connect to them)
C.. 
C..   All of this boils down to looking at all previous nodes (irrespective
C..   of which line they're in), and attempting to attach nodes to the
C..   positions after the parts which have been processed.

C.. We start by creating an excitation generator connected to the
C.. current node

C.. Initialiaze the excitation generators
         CALL GETSYM(INODE,NEL,G1,NBASISMAX,ISYM)
         STORE(1)=0
         CALL GENSYMEXCITIT2(INODE,NEL,G1,NBASIS,NBASISMAX,
     &         .TRUE.,NMEMLEN,NJ,IC,IFRZ(0,I_VIND+1),STORE,EXFLAG)
         CALL MEMORY(IP_NMEM,NMEMLEN,'NMEM')
         NMEM(1)=0
         CALL GENSYMEXCITIT2(INODE,NEL,G1,NBASIS,NBASISMAX,
     &         .TRUE.,NMEM,NJ,IC,IFRZ(0,I_VIND+1),STORE,EXFLAG)
C.. I_VIND is the node that has just been chosen (so LOCTAB(I_VIND) is a
C.. generator for that node.  We need to generate from that node, so we
C.. store at I_VIND+1

C.. We now choose the next node, attempting to generate from all the
C.. nodes in the direct line back to I

C.. We do this by taking a copy of LOCTAB (excluding the generator
C.. from this node, which we haven't put in yet)
         CALL ICOPY(I_VIND*3,LOCTAB,1,LOCTAB2,1)
C.. Now start at this node, and work backwards along the path to I.
C.. (This is equivalent to working through all previous nodes in the
C.. path, as those which are not on our direct route back to I will have 
C.. their generators exhausted, and thus a zero-entry in the LOCTAB.
         
         IF(IAND(NWHTAY,1).EQ.0) THEN
C.. Either a normal graph sum or a chain/star sum

C.. start the iterator at "us" (i.e. get all excitations connected to
C.. us) and then work back down the direct tree to the root.
C.. allow chain graphs
            IVLMAX=I_VIND+1
            IVLMIN=0
         ELSE
C.. only stars start at what remains from the iterator the last one
C.. was generated from (or just the root if there is none) 
            IVLMAX=I_VIND
            IF(IVLMAX.LT.1) IVLMAX=1
            IVLMIN=IVLMAX-1
         ENDIF
         IVLEVEL=IVLMAX

C.. Set these just in case
         IP_CURGEN=IP_NMEM
         LOCTAB(2,I_VIND+1)=NMEMLEN
         LOCTAB(3,I_VIND+1)=IVLEVEL-1
         
         DO WHILE (IVLEVEL.GT.IVLMIN)
C.. If we're at I_VIND+1, then we don't need to create a new copy of the 
C.. generator, as no other sub-recursion is using it yet
            TNEXT=.FALSE.
            CALL ICOPY(NBASIS+1,IFRZ(0,IVLEVEL),1,IFRZ2,1)
            IF(IVLEVEL.LE.I_VIND) THEN
C.. create a copy

               CALL MEMORY(IP_CURGEN,LOCTAB2(2,IVLEVEL),'CURGEN')
               IP_OGEN=LOCTAB2(1,IVLEVEL)
               CALL ICOPY(LOCTAB2(2,IVLEVEL),OGEN,1,CURGEN,1)
               IF(IAND(IFRZ(0,I_VIND+1),8).NE.0) THEN
C.. We need to reset the generator if we're only generating stars.
C.. Because we now have some frozen orbitals, the original excitation
C.. will not be re-generated.
                  CALL RESETEXIT2(IPATH(1,LOCTAB(3,IVLEVEL)),NEL,G1,
     &               NBASIS,NBASISMAX,CURGEN,IFRZ2)
               ENDIF
               LOCTAB2(2,I_VIND+1)=LOCTAB(2,IVLEVEL)
               LOCTAB2(3,I_VIND+1)=LOCTAB(3,IVLEVEL)
            ELSE
               IP_CURGEN=IP_NMEM
               LOCTAB2(2,I_VIND+1)=NMEMLEN
               LOCTAB2(3,I_VIND+1)=IVLEVEL-1
            ENDIF
            IEXFROM=LOCTAB2(3,I_VIND+1)
            LOCTAB2(1,I_VIND+1)=IP_CURGEN
            DO WHILE(.NOT.TNEXT)
C.. Now use the generator to make the next node,NJ
               CALL GENSYMEXCITIT2(IPATH(1,IEXFROM),NEL,G1,
     &         NBASIS,NBASISMAX,
     &         .FALSE.,CURGEN,NJ,IC,IFRZ2,STORE,EXFLAG)
C.. Check to see it's actually been generated
               IF(NJ(1).EQ.0) THEN
                  TFAIL=.TRUE.
                  TNEXT=.TRUE.
               ELSE
                  TFAIL=.FALSE.
               ENDIF
C.. Now make sure it's not already in the path
               IF(.NOT.TFAIL) THEN
                  DO J=0,I_VIND
                     IF(ICMPDETS(NJ,IPATH(1,J),NEL).EQ.0) THEN
                        TFAIL=.TRUE.
                     ENDIF
                  ENDDO
               ENDIF
                  
               IF(.NOT.TFAIL) THEN
C.. see if we're connected to what we were excited from
                 RH=GETHELEMENT2(IPATH(1,IEXFROM),NJ,NEL,NBASISMAX,
     &              G1,NBASIS,BRR,NMSH,FCK,TMat,NMAX,ALAT,UMAT,IC,ECORE)
                  IF(.NOT.(RH.AGE.RHOEPS)) THEN
C.. if we're not connected to this node, we fail now
                     RH=0.D0
                     TFAIL=.TRUE.
                  ENDIF
                  HIJ(I_VIND+1,IEXFROM)=DCONJG(RH)
                  HIJ(IEXFROM,I_VIND+1)=RH
               ENDIF
            
C.. Work out the connectivity of the new node
               DO II=0,I_VIND
C.. we don't need to calc the connection to the node we excited from
C.. because we've just done that
                  IF(.NOT.TFAIL.AND.II.NE.IEXFROM) THEN
                     RH=GETHELEMENT2(IPATH(1,II),NJ,NEL,NBASISMAX,
     &                  G1,NBASIS,BRR,NMSH,FCK,TMat,NMAX,ALAT,UMAT,-1,
     &                  ECORE)
                     IF(.NOT.(RH.AGE.RHOEPS)) RH=0.D0
                     HIJ(I_VIND+1,II)=DCONJG(RH)
                     HIJ(II,I_VIND+1)=RH
                   IF(IsConnectedDet(IPATH(1,II),NJ,nEl,LOCTAB(1,II),
     &                  G1,nBasisMax,nBasis)) THEN
!                     IF(RH.NE.0.D0) THEN
C.. If the node to which this node (NJ) is attached was known about at
C.. the time of node II, we are allowed to have a connection between
C.. node NJ and II.  Otherwise, this node must not be attached to II, as
C.. it will've already been counted as one of those attached to II

C.. We disallow this connection if IAND(IFRZ2(0),2) to require that there are
C.. no loops
                        IF(IAND(NWHTAY,2).NE.0.OR.IEXFROM.GT.II) THEN
C.. we're not allowed to count this node
                           TFAIL=.TRUE.                  
                        ENDIF
                     ENDIF
                  ENDIF
               ENDDO
               IF(.NOT.TFAIL) THEN
C.. If we've got a node we're allowed to count
C.. Deal with freezing orbitals if we have to
C..
                  ICIL=0
                  ICILMAX=1
                  FSC2=FSCALE
                  DO WHILE(ICIL.LT.ICILMAX)
                   IF(IAND(NWHTAY,8).NE.0.AND.I_VIND.LT.(I_V-2)) THEN
                     IF(ICIL.EQ.0) THEN
                        EX(1,1)=2
                        CALL GETEXCITATION(IPATH(1,IEXFROM),NJ,NEL,EX,T)
                        ICILMAX=2
                        IF(EX(1,2).NE.0) ICILMAX=ICILMAX+1
                     ENDIF
C.. We freeze the orbitals we're exciting from and to
                     CALL ICOPY(NBASIS+1,IFRZ2,1,
     &                  IFRZ(0,I_VIND+1),1)
C.. freeze full orbitals
C.. 0) second excited full (if there is one)
C.. 1) first excited full 
C.. 2) both excited full (and set to subtract this contrib)
                     IF(ICIL.EQ.ICILMAX-3) THEN
                        IFRZ(EX(1,2),I_VIND+1)=1
                     ELSEIF(ICIL.EQ.ICILMAX-2) THEN
                        IFRZ(EX(1,1),I_VIND+1)=1
                     ELSEIF(ICIL.EQ.ICILMAX-1) THEN
                        IFRZ(EX(1,1),I_VIND+1)=1
                        IF(EX(1,2).NE.0) IFRZ(EX(1,2),I_VIND+1)=1
                        FSC2=-FSC2
                     ENDIF
C.. freeze the empties
                     IFRZ(EX(2,1),I_VIND+1)=1
                     IF(EX(2,2).NE.0) IFRZ(EX(2,2),I_VIND+1)=1
                     CALL ICOPY(NBASIS+1,IFRZ(0,I_VIND+1),1,
     &                  IFRZ(0,I_VIND+2),1)
                   ELSE
                     CALL ICOPY(NBASIS+1,IFRZ(0,I_VIND+1),1,
     &                  IFRZ(0,I_VIND+2),1)
                   ENDIF
C.. Add it to the path, and recurse
                   CALL ICOPY(NEL,NJ,1,IPATH(1,I_VIND+1),1)
C.. Get the H element so we can calculate the energy
                   HIJS(I_VIND+1)=HIJ(0,I_VIND+1)
                   TOTAL=TOTAL+
     &                  FMCPR3B2(NI,BETA,I_P,IPATH,I_V,NEL,NBASISMAX,
     &                     G1,NBASIS,BRR,NMSH,FCK,TMat,NMAX,ALAT,UMAT,
     &                     NTAY,RHOEPS,I_VIND+1,HIJ,NWHTAY,
     &                     I_HMAX,LOCTAB2,ILOGGING,TSYM,ECORE,
     &                     DBETA,DLWDB,HIJS,L,LT,IFRZ,FSC2,MP2E,NTOTAL,
     &                     I_VMAX,EREF,WREF)
                   ICIL=ICIL+1
                  ENDDO
               ENDIF
            ENDDO
C            CALL MEMORY_CHECK()
C            CALL PRINT_MEMORY()
            IF(IVLEVEL.LE.I_VIND) THEN
C.. free the copy
               CALL FREEM(IP_CURGEN)
               IP_CURGEN=0
               LOCTAB2(1,IVLEVEL)=0
            ENDIF
C.. for the next iterator, we want to find the node to which we are
C.. connected, and continue from after where this node was excited
            IVLEVEL=LOCTAB2(3,IVLEVEL)
         ENDDO
C            CALL MEMORY_CHECK()
C            CALL PRINT_MEMORY()
         CALL FREEM(IP_NMEM)
         LOCTAB(1,I_VIND+1)=0
         FMCPR3B2=TOTAL

        If (TVARCALC(I_V).and.I_VIND.eq.0) Then
           write(6,"A, 5G26.15") "Terms in estimated variance:", 
     &        SumX, SumY, SumXsq, SumYsq, SumXY
           write(6,"(2A,I3,G25.16)") "Expected MC Variance for ratio ",
     &       "vertex level", I_V, (SumX/SumY)**2*(SumXsq/SumX**2
     &                      +SumYsq/SumY**2-2*SumXY/(SumX*SumY))
          SumX=0
          SumY=0
          SumXsq=0
          SumYsq=0
          SumXY=0
        End If
         
         RETURN
      END

      Subroutine WriteGraphEnergies(IPATH, I_V, nEl,nBasis,Arr,Weight)
        Use HElement
        Integer I_V, nEl, nBasis, IPATH(nEl,0:I_V), EX(2,2), T
        Real*8 Arr(nBasis, 2)
        Type(HDElement) Weight
        EX(1,1)=2
        Call GetEXCITATION(IPATH(1:NEL,0),IPATH(1:NEL,1),NEL,EX,T)
        If(Ex(1,2).eq.0) Then !we have a single excitation
          Write(56, "5G25.16") Weight, Arr(EX(1,1),2), 0,
     &                                 Arr(EX(2,1),2), 0
        Else
          Write(56, "5G25.16") Weight, Arr(EX(1,1),2), Arr(EX(1,2),2),
     &                                 Arr(EX(2,1),2), Arr(EX(2,2),2)
        End If
      End
