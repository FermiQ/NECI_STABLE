#############################################
############## Sort scalars #################
#############################################
[int]
type1 = integer(kind=int32)
extra_arrs = 
op_gt = >
op_lt = <
count = size(arr)
type2 = !
type3 = !
type4 = !
type5 = !
arr2_prefix = !
arr3_prefix = !
arr4_prefix = !
arr5_prefix = !

[int64]
type1 = integer(kind=int64)

[doub]
type1 = real*8

[sym]
type1 = type(Symmetry)

[sympairprod]
type1 = type(SymPairProd)

[starwalker]
type1 = type(star_walker)

##############################################
############### Sort arrays ##################
##############################################
[arr_int]
type1 = integer(kind=int32), dimension(:)
op_gt = .arrgt.
op_lt = .arrlt.
count = size(arr(1,:))

[arr_int64]
type1 = integer(kind=int64), dimension(:)

[arr_doub]
type1 = real*8, dimension(:)

##############################################
############ Sort by scalars #################
##############################################
[int_int]
type1 = integer(kind=int32)
type2 = integer(kind=int32)
arr2_prefix = 
extra_arrs = arr2,
op_gt = >
op_lt = <
count = size(arr)

[int_doub]
type2 = real*8

[int_arr_int]
type2 = integer(kind=int32), dimension(:)

[int_arr_doub]
type2 = real*8, dimension(:)

[int_arr_helem]
type2 = type(helement), dimension(:)

[doub_int]
type1 = real*8
type2 = integer(kind=int32)

[doub_doub]
type2 = real*8

[doub_arr_int]
type2 = integer(kind=int32), dimension(:)

[doub_arr_doub]
type2 = real*8, dimension(:)

[sym_arr_int]
type1 = type(Symmetry)
type2 = integer(kind=int32), dimension(:)

###############################################
########## Sort by integer array ##############
###############################################
[arr_int_arr_int]
type1 = integer(kind=int32), dimension(:)
type2 = integer(kind=int32), dimension(:)
op_gt = .arrgt.
op_lt = .arrlt.
count = size(arr(1,:))

[arr_int_arr_doub]
type2 = real*8, dimension(:)

[arr_int_int]
type2 = integer(kind=int32)

[arr_int_doub]
type2 = real*8

#################################################
############# Sort by double array ##############
#################################################
[arr_doub_doub]
type1 = real*8, dimension(:)

[arr_doub_int]
type2 = integer(kind=int32)

[arr_doub_arr_doub]
type2 = real*8, dimension(:)

[arr_doub_arr_int]
type2 = integer(kind=int32), dimension(:)

################################################
############ More specific sorts ###############
################################################
[int_arr_int64_logical]
type1 = integer(kind=int32)
type2 = integer(kind=int64), dimension(:)
type3 = logical
arr3_prefix = 
extra_arrs = arr2, arr3,
op_gt = >
op_lt = <
count = size(arr)

[int_arr_int_doub]
type2 = integer(kind=int32), dimension(:)
type3 = real(kind=dp)

[hel_hel_hel]
type1 = type(helement)
type2 = type(helement)
type3 = type(helement)

[doub_doub_doub]
type1 = real(kind=dp)
type2 = real(kind=dp)
type3 = real(kind=dp)

[doub_arr_doub_int]
type2 = real(kind=dp), dimension(:)
type3 = integer(kind=int32)

[int_int_int64_int]
type1 = integer(kind=int32)
type2 = integer(kind=int32)
type3 = integer(kind=int64)
type4 = integer(kind=int32)
arr4_prefix = 
extra_arrs = arr2, arr3, arr4,

[doub_doub_doub_int]
type1 = real(kind=dp)
type2 = real(kind=dp)
type3 = real(kind=dp)
type4 = integer(kind=int32)

[int64_int_int_int]
type1 = integer(kind=int64)
type2 = integer(kind=int32)
type3 = integer(kind=int32)
type4 = integer(kind=int32)

[int64_int64_int_int_int]
type1 = integer(kind=int64)
type2 = integer(kind=int64)
type3 = integer(kind=int32)
type4 = integer(kind=int32)
type5 = integer(kind=int32)
arr5_prefix = 
extra_arrs = arr2, arr3, arr4, arr5,


===================

#define srt_ind(i) (((i)*nskip_)+1)

module sort_mod
    use util_mod, only: operator(.arrlt.), operator(.arrgt.), swap
	use constants
    use helem
	use SystemData, only: Symmetry, operator(.eq.), operator(.ne.), &
	                      operator(.gt.), operator(.lt.), assignment(=)
	use symdata, only: SymPairProd, operator(.eq.), operator(.ne.), &
	                   operator(.gt.), operator(.lt.), assignment(=)
    use StarDiagData
	implicit none
	
	private
	public :: sort

    interface sort
        module procedure sort_%(name)s
    end interface

contains
    subroutine sort_%(name)s (arr, %(extra_arrs)snskip)

        ! Perform a quicksort on an array of integers, arr(n). Uses the 
        ! sample code in NumericalRecipies as a base.
        ! Optionally sort arr2 in parallel (in the routines it is enabled)

        ! sort needs auxiliary storage of length 2*log_2(n).
        integer, parameter :: nStackMax = 50
        integer, parameter :: nInsertionSort = 7
		integer, intent(in), optional :: nskip

        %(type1)s, intent(inout) :: arr(:)
        %(type2)s, intent(inout) :: arr2(:)
		%(type3)s, intent(inout) :: arr3(:)
		%(type4)s, intent(inout) :: arr4(:)
		%(type5)s, intent(inout) :: arr5(:)

        ! Oh, how lovely it would be to be able to use push/pop and not need
        ! to guess a size of the stack to start with
        integer :: stack(nStackMax), nstack, nskip_
        integer :: pivot, lo, hi, n, i, j
        ! n.b. This size statement is removed if type1 is scalar ...
        %(type1)s :: a(size(arr(1)))
        %(type2)s :: a2(size(arr2(1)))
        %(type3)s :: a3(size(arr3(1)))
        %(type4)s :: a4(size(arr4(1)))
        %(type5)s :: a5(size(arr5(1)))
        character(*), parameter :: this_routine = 'name'

		if (present(nskip)) then
			nskip_ = nskip
		else
			nskip_ = 1
		endif

        ! The size of the array to sort. 
		! N.B. Use zero based indices. To obtain ! the entry into the actual 
		! array, multiply indices by nskip and add ! 1 (hence zero based)
		! **** See local macro srt_ind() ******
		lo = lbound(arr, %(dim-arr)s) - 1
		n = ((ubound(arr, %(dim-arr)s) - lo -1)/nskip_) + 1
		hi = lo + n - 1

        nstack = 0
        do while (.true.)
            ! If the section/partition we are looking at is smaller than
            ! nInsertSort then perform an insertion sort 
            if (hi - lo < nInsertionSort) then
                do j = lo + 1, hi
                    a = arr(srt_ind(j))
                    %(arr2_prefix)s a2 = arr2(srt_ind(j))
                    %(arr3_prefix)s a3 = arr3(srt_ind(j))
                    %(arr4_prefix)s a4 = arr4(srt_ind(j))
                    %(arr5_prefix)s a5 = arr5(srt_ind(j))
                    do i = j - 1, 0, -1
                        if (arr(srt_ind(i)) %(op_lt)s a) exit
                        arr(srt_ind(i+1)) = arr(srt_ind(i))
                        %(arr2_prefix)s arr2(srt_ind(i+1)) = arr2(srt_ind(i))
                        %(arr3_prefix)s arr3(srt_ind(i+1)) = arr3(srt_ind(i))
                        %(arr4_prefix)s arr4(srt_ind(i+1)) = arr4(srt_ind(i))
                        %(arr5_prefix)s arr5(srt_ind(i+1)) = arr5(srt_ind(i))
                    enddo
                    arr(srt_ind(i+1)) = a
                    %(arr2_prefix)s arr2(srt_ind(i+1)) = a2
                    %(arr3_prefix)s arr3(srt_ind(i+1)) = a3
                    %(arr4_prefix)s arr4(srt_ind(i+1)) = a4
                    %(arr5_prefix)s arr5(srt_ind(i+1)) = a5
                enddo

                if (nstack == 0) exit
                hi = stack(nstack)
                lo = stack(nstack-1)
                nstack = nstack - 2

            ! Otherwise start partitioning with quicksort. 
            else
                ! Pick a partitioning element, and arrange such that
                ! arr(lo) <= arr(lo+1) <= arr(hi) 
                pivot = (lo + hi) / 2
                call swap (arr(srt_ind(pivot)), arr(srt_ind(lo + 1)))
                %(arr2_prefix)s call swap (arr2(srt_ind(pivot)), arr2(srt_ind(lo+1)))
                %(arr3_prefix)s call swap (arr3(srt_ind(pivot)), arr3(srt_ind(lo+1)))
                %(arr4_prefix)s call swap (arr4(srt_ind(pivot)), arr4(srt_ind(lo+1)))
                %(arr5_prefix)s call swap (arr5(srt_ind(pivot)), arr5(srt_ind(lo+1)))

                if (arr(srt_ind(lo)) %(op_gt)s arr(srt_ind(hi))) then
                    call swap (arr(srt_ind(lo)), arr(srt_ind(hi)))
                    %(arr2_prefix)s call swap (arr2(srt_ind(lo)), arr2(srt_ind(hi)))
                    %(arr3_prefix)s call swap (arr3(srt_ind(lo)), arr3(srt_ind(hi)))
                    %(arr4_prefix)s call swap (arr4(srt_ind(lo)), arr4(srt_ind(hi)))
                    %(arr5_prefix)s call swap (arr5(srt_ind(lo)), arr5(srt_ind(hi)))
                endif
                if (arr(srt_ind(lo+1)) %(op_gt)s arr(srt_ind(hi))) then
                    call swap (arr(srt_ind(lo+1)), arr(srt_ind(hi)))
                    %(arr2_prefix)s call swap (arr2(srt_ind(lo+1)), arr2(srt_ind(hi)))
                    %(arr3_prefix)s call swap (arr3(srt_ind(lo+1)), arr3(srt_ind(hi)))
                    %(arr4_prefix)s call swap (arr4(srt_ind(lo+1)), arr4(srt_ind(hi)))
                    %(arr5_prefix)s call swap (arr5(srt_ind(lo+1)), arr5(srt_ind(hi)))
                endif
                if (arr(srt_ind(lo)) %(op_gt)s arr(srt_ind(lo+1))) then
                    call swap (arr(srt_ind(lo)), arr(srt_ind(lo+1)))
                    %(arr2_prefix)s call swap (arr2(srt_ind(lo)), arr2(srt_ind(lo+1)))
                    %(arr3_prefix)s call swap (arr3(srt_ind(lo)), arr3(srt_ind(lo+1)))
                    %(arr4_prefix)s call swap (arr4(srt_ind(lo)), arr4(srt_ind(lo+1)))
                    %(arr5_prefix)s call swap (arr5(srt_ind(lo)), arr5(srt_ind(lo+1)))
                endif

                i = lo + 1
                j = hi
                a = arr(srt_ind(lo + 1)) !! a is the pivot value
                %(arr2_prefix)s a2 = arr2(srt_ind(lo + 1))
                %(arr3_prefix)s a3 = arr3(srt_ind(lo + 1))
                %(arr4_prefix)s a4 = arr4(srt_ind(lo + 1))
                %(arr5_prefix)s a5 = arr5(srt_ind(lo + 1))
                do while (.true.)
                    ! Scand down list to find element > a 
                    i = i + 1
                    do while (arr(srt_ind(i)) %(op_lt)s a)
                        i = i + 1
                    enddo

                    ! Scan down list to find element < a 
                    j = j - 1
                    do while (arr(srt_ind(j)) %(op_gt)s a)
                        j = j - 1
                    enddo

                    ! When the pointers crossed, partitioning is complete. 
                    if (j < i) exit

                    ! Swap the elements, so that all elements < a end up
                    ! in lower indexed variables. 
                    call swap (arr(srt_ind(i)), arr(srt_ind(j)))
                    %(arr2_prefix)s call swap (arr2(srt_ind(i)), arr2(srt_ind(j)))
                    %(arr3_prefix)s call swap (arr3(srt_ind(i)), arr3(srt_ind(j)))
                    %(arr4_prefix)s call swap (arr4(srt_ind(i)), arr4(srt_ind(j)))
                    %(arr5_prefix)s call swap (arr5(srt_ind(i)), arr5(srt_ind(j)))
                enddo;

                ! Insert partitioning element 
                arr(srt_ind(lo + 1)) = arr(srt_ind(j))
                arr(srt_ind(j)) = a
                %(arr2_prefix)s arr2(srt_ind(lo + 1)) = arr2(srt_ind(j))
                %(arr3_prefix)s arr3(srt_ind(lo + 1)) = arr3(srt_ind(j))
                %(arr4_prefix)s arr4(srt_ind(lo + 1)) = arr4(srt_ind(j))
                %(arr5_prefix)s arr5(srt_ind(lo + 1)) = arr5(srt_ind(j))
                %(arr2_prefix)s arr2(srt_ind(j)) = a2
                %(arr3_prefix)s arr3(srt_ind(j)) = a3
                %(arr4_prefix)s arr4(srt_ind(j)) = a4
                %(arr5_prefix)s arr5(srt_ind(j)) = a5

                ! Push the larger of the partitioned sections onto the stack
                ! of sections to look at later.
                ! --> need fewest stack elements. 
                nstack = nstack + 2
                if (nstack > nStackMax) call stop_all (this_routine, &
                                        "parameter nStackMax too small")
                if (hi - i + 1 >= j - 1) then
                    stack(nstack) = hi
                    stack(nstack-1) = i
                    hi = j - 1
                else
                    stack(nstack) = j - 1
                    stack(nstack-1) = lo
                    lo = i
                endif
            endif
        enddo
    end subroutine
end module
