#############################################
############## Sort scalars #################
#############################################
[int]
type1 = integer(kind=int32)
end_of_decl = )
op_gt = >
op_lt = <
count = size(arr)
type2 = !
type3 = !
type4 = !
type5 = !
arr2_prefix = !
arr3_prefix = !
arr4_prefix = !
arr5_prefix = !

[int64]
type1 = integer(kind=int64)

[doub]
type1 = real*8

##############################################
############### Sort arrays ##################
##############################################
[arr_int]
type1 = integer(kind=int32), dimension(:)
op_gt = .arrgt.
op_lt = .arrlt.
count = size(arr(1,:))

[arr_int64]
type1 = integer(kind=int64), dimension(:)

[arr_doub]
type1 = real*8, dimension(:)

##############################################
############ Sort by scalars #################
[int_int]
type1 = integer(kind=int32)
type2 = integer(kind=int32)
arr2_prefix = 
end_of_decl = , arr2)
op_gt = >
op_lt = <
count = size(arr)

[int_doub]
type2 = real*8

[int_arr_int]
type2 = integer(kind=int32), dimension(:)

[int_arr_doub]
type2 = real*8, dimension(:)

[doub_int]
type1 = real*8
type2 = integer(kind=int32)

[doub_doub]
type2 = real*8

[doub_arr_int]
type2 = integer(kind=int32), dimension(:)

[doub_arr_doub]
type2 = real*8, dimension(:)

###############################################
########## Sort by integer array ##############
###############################################
[arr_int_arr_int]
type1 = integer(kind=int32), dimension(:)
type2 = integer(kind=int32), dimension(:)
arr2_prefix = 
end_of_decl = , arr2)
op_gt = .arrgt.
op_lt = .arrlt.
count = size(arr(1,:))

[arr_int_arr_doub]
type2 = real*8, dimension(:)

[arr_int_int]
type2 = integer(kind=int32)

[arr_int_doub]
type2 = real*8

#################################################
############# Sort by double array ##############
#################################################
[arr_doub_doub]
type1 = real*8, dimension(:)

[arr_doub_int]
type2 = integer(kind=int32)

[arr_doub_arr_doub]
type2 = real*8, dimension(:)

[arr_doub_arr_int]
type2 = integer(kind=int32), dimension(:)


################################################
############ More specific sorts ###############
################################################
[int_arr_int64_logical]
type1 = integer(kind=int32)
type2 = integer(kind=int64), dimension(:)
type3 = logical
arr3_prefix = 
end_of_decl = , arr2, arr3)
op_gt = >
op_lt = <
count = size(arr)

[int_int_int64_int]
type1 = integer(kind=int32)
type2 = integer(kind=int32)
type3 = integer(kind=int64)
type4 = integer(kind=int32)
arr4_prefix = 
end_of_decl = , arr2, arr3, arr4)

[int64_int64_int_int_int]
type1 = integer(kind=int64)
type2 = integer(kind=int64)
type3 = integer(kind=int32)
type4 = integer(kind=int32)
type5 = integer(kind=int32)
arr5_prefix = 
end_of_decl = , arr2, arr3, arr4, arr5)


===================

module sort_mod
    use util_mod, only: operator(.arrlt.), operator(.arrgt.), swap
	use constants
    use helem
	implicit none
	
	private
	public :: sort

    interface sort
        module procedure sort_%(name)s
    end interface

contains
    subroutine sort_%(name)s (arr%(end_of_decl)s

        ! Perform a quicksort on an array of integers, arr(n). Uses the 
        ! sample code in NumericalRecipies as a base.
        ! Optionally sort arr2 in parallel (in the routines it is enabled)

        ! sort needs auxiliary storage of length 2*log_2(n).
        integer, parameter :: nStackMax = 50
        integer, parameter :: nInsertionSort = 7

        %(type1)s, intent(inout) :: arr(:)
        %(type2)s, intent(inout) :: arr2(:)
		%(type3)s, intent(inout) :: arr3(:)
		%(type4)s, intent(inout) :: arr4(:)
		%(type5)s, intent(inout) :: arr5(:)

        ! Oh, how lovely it would be to be able to use push/pop and not need
        ! to guess a size of the stack to start with
        integer :: stack(nStackMax), nstack
        integer :: pivot, lo, hi, n, i, j
        ! n.b. This size statement is removed if type1 is scalar ...
        %(type1)s :: a(size(arr(1)))
        %(type2)s :: a2(size(arr2(1)))
        %(type3)s :: a3(size(arr3(1)))
        %(type4)s :: a4(size(arr4(1)))
        %(type5)s :: a5(size(arr5(1)))
        character(*), parameter :: this_routine = 'name'

        ! The size of the array to sort
        n = %(count)s

        nstack = 0
        lo = 1
        hi = n
        do while (.true.)
            ! If the section/partition we are looking at is smaller than
            ! nInsertSort then perform an insertion sort 
            if (hi - lo < nInsertionSort) then
                do j = lo + 1, hi
                    a = arr(j)
                    %(arr2_prefix)s a2 = arr2(j)
                    %(arr3_prefix)s a3 = arr3(j)
                    %(arr4_prefix)s a4 = arr4(j)
                    %(arr5_prefix)s a5 = arr5(j)
                    do i = j - 1, 1, -1
                        if (arr(i) %(op_lt)s a) exit
                        arr(i+1) = arr(i)
                        %(arr2_prefix)s arr2(i+1) = arr2(i)
                        %(arr3_prefix)s arr3(i+1) = arr3(i)
                        %(arr4_prefix)s arr4(i+1) = arr4(i)
                        %(arr5_prefix)s arr5(i+1) = arr5(i)
                    enddo
                    arr(i+1) = a
                    %(arr2_prefix)s arr2(i+1) = a2
                    %(arr3_prefix)s arr3(i+1) = a3
                    %(arr4_prefix)s arr4(i+1) = a4
                    %(arr5_prefix)s arr5(i+1) = a5
                enddo

                if (nstack == 0) exit
                hi = stack(nstack)
                lo = stack(nstack-1)
                nstack = nstack - 2

            ! Otherwise start partitioning with quicksort. 
            else;
                ! Pick a partitioning element, and arrange such that
                ! arr(lo) <= arr(lo+1) <= arr(hi) 
                pivot = (lo + hi) / 2
                call swap (arr(pivot), arr(lo + 1))
                %(arr2_prefix)s call swap (arr2(pivot), arr2(lo+1))
                %(arr3_prefix)s call swap (arr3(pivot), arr3(lo+1))
                %(arr4_prefix)s call swap (arr4(pivot), arr4(lo+1))
                %(arr5_prefix)s call swap (arr5(pivot), arr5(lo+1))

                if (arr(lo) %(op_gt)s arr(hi)) then
                    call swap (arr(lo), arr(hi))
                    %(arr2_prefix)s call swap (arr2(lo), arr2(hi))
                    %(arr3_prefix)s call swap (arr3(lo), arr3(hi))
                    %(arr4_prefix)s call swap (arr4(lo), arr4(hi))
                    %(arr5_prefix)s call swap (arr5(lo), arr5(hi))
                endif
                if (arr(lo+1) %(op_gt)s arr(hi)) then
                    call swap (arr(lo+1), arr(hi))
                    %(arr2_prefix)s call swap (arr2(lo+1), arr2(hi))
                    %(arr3_prefix)s call swap (arr3(lo+1), arr3(hi))
                    %(arr4_prefix)s call swap (arr4(lo+1), arr4(hi))
                    %(arr5_prefix)s call swap (arr5(lo+1), arr5(hi))
                endif
                if (arr(lo) %(op_gt)s arr(lo+1)) then
                    call swap (arr(lo), arr(lo+1))
                    %(arr2_prefix)s call swap (arr2(lo), arr2(lo+1))
                    %(arr3_prefix)s call swap (arr3(lo), arr3(lo+1))
                    %(arr4_prefix)s call swap (arr4(lo), arr4(lo+1))
                    %(arr5_prefix)s call swap (arr5(lo), arr5(lo+1))
                endif

                i = lo + 1
                j = hi
                a = arr(lo + 1) !! a is the pivot value
                %(arr2_prefix)s a2 = arr2(lo + 1)
                %(arr3_prefix)s a3 = arr3(lo + 1)
                %(arr4_prefix)s a4 = arr4(lo + 1)
                %(arr5_prefix)s a5 = arr5(lo + 1)
                do while (.true.)
                    ! Scand down list to find element > a 
                    i = i + 1
                    do while (arr(i) %(op_lt)s a)
                        i = i + 1
                    enddo

                    ! Scan down list to find element < a 
                    j = j - 1
                    do while (arr(j) %(op_gt)s a)
                        j = j - 1
                    enddo

                    ! When the pointers crossed, partitioning is complete. 
                    if (j < i) exit

                    ! Swap the elements, so that all elements < a end up
                    ! in lower indexed variables. 
                    call swap (arr(i), arr(j))
                    %(arr2_prefix)s call swap (arr2(i), arr2(j))
                    %(arr3_prefix)s call swap (arr3(i), arr3(j))
                    %(arr4_prefix)s call swap (arr4(i), arr4(j))
                    %(arr5_prefix)s call swap (arr5(i), arr5(j))
                enddo;

                ! Insert partitioning element 
                arr(lo + 1) = arr(j)
                arr(j) = a
                %(arr2_prefix)s arr2(lo + 1) = arr2(j)
                %(arr3_prefix)s arr3(lo + 1) = arr3(j)
                %(arr4_prefix)s arr4(lo + 1) = arr4(j)
                %(arr5_prefix)s arr5(lo + 1) = arr5(j)
                %(arr2_prefix)s arr2(j) = a2
                %(arr3_prefix)s arr3(j) = a3
                %(arr4_prefix)s arr4(j) = a4
                %(arr5_prefix)s arr5(j) = a5

                ! Push the larger of the partitioned sections onto the stack
                ! of sections to look at later.
                ! --> need fewest stack elements. 
                nstack = nstack + 2
                if (nstack > nStackMax) call stop_all (this_routine, &
                                        "parameter nStackMax too small")
                if (hi - i + 1 >= j - 1) then
                    stack(nstack) = hi
                    stack(nstack-1) = i
                    hi = j - 1
                else
                    stack(nstack) = j - 1
                    stack(nstack-1) = lo
                    lo = i
                endif
            endif
        enddo
    end subroutine
end module
