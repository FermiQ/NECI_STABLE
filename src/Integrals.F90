#include "macros.h"
module Integrals

    use SystemData, only: tStoreSpinOrbs, tStarStore, nBasisMax, iSpinSkip, &
                          tFixLz, nBasis, G1, Symmetry, tCacheFCIDUMPInts, &
                          tRIIntegrals, tVASP
    use UmatCache, only: tUmat2D, UMatInd, umat2d, tTransFIndx, nHits, &
                         nMisses, GetCachedUMatEl, HasKPoints, TransTable, &
                         nTypes, gen2CPMDInts, tDFInts
    use util_mod, only: get_nan
    use vasp_neci_interface
    use IntegralsData
    use shared_alloc, only: shared_allocate, shared_deallocate
    use global_utilities
    use gen_coul_ueg_mod, only: gen_coul_hubnpbc, get_ueg_umat_el, &
                                get_hub_umat_el
    use HElem, only: HElement_t_size, HElement_t_sizeB
    use Parallel, only: iProcIndex

    implicit none

    interface
        function get_umat_el (fn, i, j, k, l) result(hel)
            use, intrinsic :: iso_c_binding
            use constants, only: dp
            implicit none
            type(c_ptr), intent(in), value :: fn
            integer, intent(in) :: i, j, k, l
            HElement_t :: hel
        end function

        ! TODO: From sym.F. Should modularise at some point
        function TotSymRep ()
            use SystemData, only: Symmetry
            implicit none
            type(Symmetry) :: TotSymRep
        end function

        ! TODO: Same again
        function symProd (iSym1, iSym2)
            use SystemData, only: Symmetry
            implicit none
            type(Symmetry) :: iSym1, iSym2, symProd
        end function

        ! TODO: Same again
        logical function lSymSym (sym)
            use SystemData, only: Symmetry
            implicit none
            type(Symmetry) :: sym
        end function

        ! TODO: Same again
        function SymConj (s2)
            use Systemdata, only: Symmetry
            implicit none
            type(Symmetry) :: SymConj, s2
        end function
    end interface

contains

    subroutine set_getumatel_fn (fn)
        implicit none
        interface
            function fn (i, j, k, l) result(hel)
                use constants, only: dp
                implicit none
                integer, intent(in) :: i, j, k, l
                HElement_t :: hel
            end function
        end interface

        call assign_proc (ptr_getumatel, fn)
    end subroutine

    subroutine set_getumatel_stack (fn)
        implicit none
        interface
            function fn (i, j, k, l, fn2) result(hel)
                use constants, only: dp
                implicit none
                interface
                    function fn2 (i, j, k, l) result (hel)
                        use constants, only: dp
                        implicit none
                        integer, intent(in) :: i, j, k, l
                        HElement_t :: hel
                    end function
                end interface
                integer, intent(in) :: i, j, k, l
                HElement_t :: hel
            end function
        end interface

        ptr_getumatel_2 = ptr_getumatel
        call assign_proc (ptr_getumatel, fn)
    end subroutine

    subroutine SetIntDefaults()
      != Set defaults for Calc data items.

      use SystemData , only : OrbOrder
      use UMatCache, only: tReadInCache,nSlotsInit,nMemInit,iDumpCacheFlag,iDFMethod
      use default_sets
      implicit none

      TLinRootChange=.false.
      TRmRootExcitStarsRootChange=.false.
      TExcitStarsRootChange=.false.
      TDiagStarStars=.false.    
      TJustQuads=.false.
      TNoDoubs=.false.
      TCalcExcitStar=.false.
      TQuadVecMax=.false.
      TQuadValMax=.false.
      TDISCONODES=.FALSE.
      NRCONV=1.D-13
      RFCONV=1.D-8
      NRSTEPSMAX=50
      TQUADRHO=.false.
      TEXPRHO=.false.
      NTAY(1:2) = 1
      THFBASIS=.false.
      THFCALC = .false.
      nHFit=0
      HFMix=0.d0
      HFEDelta=0.d0
      HFCDelta=0.d0
      IHFMETHOD = 1
      TRHF=.true.
      TReadTUMat=.false.
      TReadHF=.false.
      NFROZEN=0
      NTFROZEN=0
      NFROZENIN=0
      NTFROZENIN=0
      NPartFrozen=0
      NHolesFrozen=0
      NVirtPartFrozen=0
      NElVirtFrozen=0
      tPartFreezeCore=.false.
      tPartFreezeVirt=.false.
      OrbOrder(:,:)=0
      OrbOrder2(:)=0.d0
      nSlotsInit=1024
      nMemInit=0
      iDumpCacheFlag=0
      tReadInCache=.false.
      iDFMethod=0
      HFRand=0.01
      DMatEpsilon=0
      tPostFreezeHF=.false.

!Feb 08 defaults
      IF(Feb08) THEN
         NTAY(2)=3
      ENDIF
      
    end subroutine SetIntDefaults

    SUBROUTINE IntReadInput()
      USE input
      use SystemData , only : NEL,TUSEBRILLOUIN,tStarStore,OrbOrder,NMSH,BasisFN
      use UMatCache, only: tReadInCache,nSlotsInit,nMemInit,iDumpCacheFlag,iDFMethod
      IMPLICIT NONE
      LOGICAL eof
      CHARACTER (LEN=100) w
      INTEGER :: i
           
      integral: do
        call read_line(eof)
        if (eof) then
            exit
        end if
        call readu(w)
        select case(w)
        case("LINROOTCHANGE")
            TLinRootChange=.true.
        case("RMROOTEXCITSTARSROOTCHANGE")
            TRmRootExcitStarsRootChange=.true.
        case("EXCITSTARSROOTCHANGE")
            TExcitStarsRootChange=.true.
        case("DIAGSTARSTARS")
            TDiagStarStars=.true.
        case("STARQUADEXCITS")
            TJustQuads=.true.
        case("STARNODOUBS")
            TNoDoubs=.true.
        case("CALCEXCITSTAR")
            TCalcExcitStar=.true.
        case("QUADVECMAX")
            TQuadVecMax=.true.
        case("QUADVALMAX")
            TQuadValMax=.true.
        case("NRCONV")
            call readf(NRCONV)
        case("RFCONV")
            call readf(RFCONV)
        case("NRSTEPSMAX")
            call readi(NRSTEPSMAX)
        case("INCLUDEQUADRHO")
            TQUADRHO=.true.
        case("EXPRHO")
            TEXPRHO=.true.
        case("RHO-1STORDER")
            NTAY(2)=4
        case("FOCK-PARTITION")
            NTAY(2)=2
        case("FOCK-PARTITION-LOWDIAG")
            NTAY(2)=3
        case("FOCK-PARTITION-DCCORRECT-LOWDIAG")
            NTAY(2)=5
        case("DIAG-PARTITION")
            NTAY(2)=1
        case("CALCREALPROD")
            TCALCREALPROD=.TRUE.
            IF(.NOT.TUSEBRILLOUIN) THEN
              call report(trim(w)//" will not work unless "           &
     &        //"USEBRILLOUINTHEOREM set",.true.)
            ENDIF
        case("CALCRHOPROD")
            TCALCRHOPROD=.TRUE.
        case("SUMPRODII")
            TSUMPROD=.TRUE.
        case("DISCONNECTNODES")
            TDISCONODES=.TRUE.
        case("HF")
            THFBASIS = .true.
        case("CALCULATE")
            THFCALC = .true.
        case("MAXITERATIONS")
            call geti(NHFIT)
        case("MIX")
            call getf(HFMIX)
        case("RAND")
            call getf(HFRAND)
        case("THRESHOLD")
            do while ( item .lt. nitems )
              call readu(w)
              select case(w)
              case("ENERGY")
                  call readf(HFEDELTA)
              case("ORBITAL")
                  call readf(HFCDELTA)
              case default
                  call report(trim(w)//" not valid THRESHOLD"         &
     &         //"OPTION.  Specify ENERGY or ORBITAL convergence"     &
     &           //" threshold.",.true.)
              end select
            end do
        case("RHF")
            TRHF = .true.
        case("UHF")
            TRHF = .false.
        case("HFMETHOD")
            call readu(w)
            select case(w)
            case("DESCENT")
                call readu(w)
                select case(w)
                case("OTHER")
                    IHFMETHOD = 2
                case("SINGLES")
                    IHFMETHOD = 1
                case default
                    call report(trim(w)//" not valid DESCENT"         &
     &              //" option",.true.)
                end select
            case("STANDARD")
                IHFMETHOD = 0
            case("MODIFIED")
               IHFMETHOD=3
            case default
                call report(trim(w)//" not valid HF method",          &
     &           .true.)
            end select
        case("READ")
            do while ( item .lt. nitems )
              call readu(w)
              select case(w)
              case("MATRIX")
                  TREADTUMAT = .true.
              case("BASIS")
                  TREADHF = .true.
              case default
                  call report(trim(w)//" is an invalid HF read"       &
     &            //" option.",.true.)
              end select
            end do
        case("FREEZE")
            call readi(NFROZEN)
            call readi(NTFROZEN)
            if ( mod(NFROZEN,2).ne.0 .or.                             &
     &       (NTFROZEN.GT.0 .and. mod(NTFROZEN,2).ne.0) ) then
                call report("NFROZEN and (+ve) NTFROZEN must be"      &
     &          //"multiples of 2",.true.)
            end if
            if (                                                      &
     &       (NTFROZEN.LT.0 .and. mod(NEL-NTFROZEN,2).ne.0) ) then
                call report("-ve NTFROZEN must be same parity  "      &
     &          //"as NEL",.true.)
            end if
        case("FREEZEINNER")
!This option allows us to freeze orbitals 'from the inside'.  This means that rather than freezing
!the lowest energy occupied orbitals, the NFROZENIN occupied (spin) orbitals with the highest energy are 
!frozen, along with the NTFROZENIN lowest energy virtual (spin) orbitals.
!The main purpose of this is to select an active space and calculate the energy of the orbitals NOT in this
!active space.
            call readi(NFROZENIN)
            call readi(NTFROZENIN)
            NFROZENIN=ABS(NFROZENIN)
            NTFROZENIN=ABS(NTFROZENIN)
            if((mod(NFROZENIN,2).ne.0).or.(mod(NTFROZENIN,2).ne.0) ) then
                call report("NFROZENIN and NTFROZENIN must be"      &
     &          //"multiples of 2",.true.)
            end if
        case("PARTIALLYFREEZE")
!This option chooses a set of NPartFrozen SPIN orbitals as a core, and partially freezes the electrons 
!in these orbitals so that no more than NHolesFrozen holes may exist in this core at a time.
!In practice, a walker attempts to spawn on a determinant - if this determinant has more than the 
!allowed number of holes in the partially frozen core, the spawning is forbidden.  
            tPartFreezeCore=.true.
            call readi(NPartFrozen)
            call readi(NHolesFrozen)
        case("PARTIALLYFREEZEVIRT")
!This option works very similarly to the one above.  The integers following this keyword refer firstly to the number
!of *spin* orbitals that are frozen from the highest energy virtual orbitals down.  The second integer refers to the 
!number of electrons that are allowed to occupy these 'partially frozen' virtual orbitals.  I.e. NElVirtFrozen = 1, 
!means that spawning is accepted if is to a determinant that only has one or less of the partially frozen virtual 
!orbitals occupied.  Any more than this, and the spawning is rejected.
            tPartFreezeVirt=.true.
            call readi(NVirtPartFrozen)
            call readi(NElVirtFrozen)
        case("ORDER")
            I = 1
            do while ( item .lt. nitems )
              call readf(ORBORDER2(I))
              I = I + 1
            end do
            DO I=1,8
! two ways of specifying open orbitals
! if orborder2(I,1) is integral, then if it's odd, we have a single
! open orbital
               IF(ORBORDER2(I).EQ.INT(ORBORDER2(I))) THEN
                  ORBORDER(I,1)=IAND(INT(ORBORDER2(I)),65534)
                  IF((INT(ORBORDER2(I))-ORBORDER(I,1)).GT.0) THEN
! we have an open orbital
                     ORBORDER(I,2)=2
                  ELSE
                     ORBORDER(I,2)=0
                  ENDIF
               ELSE
! non-integral.  The integral part is the number of closed oribtals,
! and the fractional*1000 is the number of open orbitals.
! e.g. 6.002 would mean 6 closed and 2 open
! which would have orborder(I,1)=6, orborder(I,2)=4
! but say 5.002 would be meaningless as the integral part must be a
! multiple of 2
                  ORBORDER(I,1)=INT(ORBORDER2(I)+0.000001)
                  ORBORDER(I,2)=INT((ORBORDER2(I)-ORBORDER(I,1)+      &
     &                           0.000001)*1000)*2
               ENDIF
            ENDDO
        case("UMATCACHE")
            call readu(w)
            select case(w)
               case("SLOTS")
                  call geti(NSLOTSINIT)
               case("MB")
                  call geti(NMEMINIT)
                  if (nMemInit.eq.0) then
                      ! Not using the cache...
                      nSlotsInit=0
                  else
                      nSlotsInit=1
                  end if
               case("READ")
                   tReadInCache=.true.
               case("DUMP")
                   if (iDumpCacheFlag.eq.0) iDumpCacheFlag=1
               case("FORCE")
                   iDumpCacheFlag=2
               case default
                  call reread(-1)
                  call geti(NSLOTSINIT)
            end select
        case("NOUMATCACHE")
            NSLOTSINIT=-1
        case ("DFMETHOD")
            call readu(w)
            select case(w)
            case ("DFOVERLAP")
               iDFMethod=1
            case ("DFOVERLAP2NDORD")
               iDFMethod=2
            case ("DFOVERLAP2")
               iDFMethod=3
            case ("DFCOULOMB")
               iDFMethod=4
           case default
               call report("keyword "//trim(w)//" not recognized in DFMETHOD block",.true.)
            end select
        case("POSTFREEZEHF")
          tPostFreezeHF=.true.
        case("DMATEPSILON")
          call readf(DMatEpsilon)
        case("ENDINT")
             exit integral
        case default
            call report("keyword "//trim(w)//" not recognized in integral block",.true.)
        end select
      end do integral
      
    END SUBROUTINE IntReadInput



    Subroutine IntInit(iCacheFlag)
!who knows what for
      Use global_utilities
      use constants, only: dp
      Use OneEInts, only: SetupTMat!,GetTMatEl
      USE UMatCache, only : FreezeTransfer, CreateInvBRR, GetUMatSize, SetupUMat2D_df
      Use UMatCache, only: InitStarStoreUMat,SetupUMatCache!,GTID,UMatInd
      use SystemData, only : nBasisMax, Alpha,BHub, BRR,nmsh,nEl
      use SystemData, only : Ecore,G1,iSpinSkip,nBasis,nMax,nMaxZ
      use SystemData, only: Omega,tAlpha,TBIN,tCPMD,tDFread,THFORDER,tRIIntegrals
      use SystemData, only: thub,tpbc,treadint,ttilt,TUEG,tVASP,tStarStore
      use SystemData, only: uhub, arr,alat,treal,tCacheFCIDUMPInts
      use constants, only: Pi, Pi2, THIRD
      INTEGER iCacheFlag
      COMPLEX*16,ALLOCATABLE :: ZIA(:)
      INTEGER,SAVE :: tagZIA=0
      COMPLEX*16,ALLOCATABLE :: COEFF(:)
      INTEGER,SAVE :: tagCOEFF=0
      INTEGER i!,j,k,l,idi,idj,idk,idl,Index1
      INTEGER TmatInt,UMatInt
      REAL*8 :: UMatMem
      integer iErr
      character(25), parameter :: this_routine='IntInit'
      LOGICAL :: tReadFreezeInts

      FREEZETRANSFER=.false.
            
      IF(THFBASIS) THEN
         WRITE(6,*) "Using Hartree-Fock Basis"
         IF(.NOT.THFCALC) WRITE(6,*) "Reading Hartree-Fock Basis"
      ENDIF
!I_VMAX.EQ.1.AND..NOT.TENERGY.AND.
      IF(.not.tNeedsVirts.and.NTFROZEN.EQ.0) THEN
         WRITE(6,*) "MaxVertices=1 and NTFROZEN=0."
         IF(ABS(ARR(NEL,1)-ARR(NEL+1,1)).GT.1.d-3) THEN
           WRITE(6,*) "NEL spinorbitals completely fills up degenerate set."
           WRITE(6,*) "Only calculating vertex sum, so freezing all virtuals."
           NTFROZEN=NBASIS-NEL
         ELSE
           WRITE(6,*) "NEL spinorbitals does not completely fill up degenerate set."
           WRITE(6,*) "NOT freezing all virtuals."
         ENDIF
      ENDIF

!     IF(.NOT.(TREAD.OR.TREADRHO)) THEN
      IF(NTFROZEN.LT.0) THEN
         I=NEL+(-NTFROZEN)
      ELSE
         I=nBasis-NTFROZEN
      ENDIF
      IF(TCPMD) THEN
!.. We don't need to do init any 4-index integrals, but we do need to init the 2-index
         WRITE(6,*) " *** INITIALIZING CPMD 2-index integrals ***"
         call shared_allocate ("umat", umat, (/1/))
         !Allocate(UMat(1), stat=ierr)
         LogAlloc(ierr, 'UMat', 1,HElement_t_SizeB, tagUMat)
         CALL GENSymStatePairs(nBasis/2,.false.)
         CALL SetupTMAT(nBasis,2,TMATINT)
         CALL CPMDINIT2INDINT(nBasis,I,NBASISMAX,ISPINSKIP,G1,NEL,ECORE,THFORDER,ARR,BRR,iCacheFlag)
      ELSEIF(tVASP) THEN
         call shared_allocate ("umat", umat, (/1/))
         !Allocate(UMat(1), stat=ierr)
         LogAlloc(ierr, 'UMat', 1,HElement_t_SizeB, tagUMat)
         CALL GENSymStatePairs(nBasis/2,.false.)
         CALL SetupTMAT(nBasis,2,TMATINT)
         CALL VASPInitIntegrals(I,ECore,tHFOrder)
!      ELSEIF(TREADINT.AND.TReadCacheInts)...
!set up dummy umat, read in TMAT, <ij|ij> and <ii|jj>
!Work out size needed for cache
!Initialise cache
!read in integral and put in cache
!change flag to read integrals from cache
      ELSEIF(TREADINT.AND.TDFREAD) THEN
         call shared_allocate ("umat", umat, (/1/))
         !Allocate(UMat(1), stat=ierr)
         LogAlloc(ierr, 'UMat', 1,HElement_t_SizeB, tagUMat)
         CALL SetupTMAT(nBasis,2,TMATINT)
         Call ReadDalton1EIntegrals(G1,nBasis,Arr,Brr,ECore)
         Call ReadDF2EIntegrals(nBasis,I)
      ELSEIF(TREADINT.AND.tRIIntegrals) THEN
         call shared_allocate ("umat", umat, (/1/))
         !Allocate(UMat(1), stat=ierr)
         LogAlloc(ierr, 'UMat', 1,HElement_t_SizeB, tagUMat)
!Why is this called twice here?!
         CALL SetupTMAT(nBasis,2,TMATINT)
         CALL SetupTMAT(nBasis,iSpinSkip,TMATINT)
         !   CALL READFCIINTBIN(UMAT,NBASIS,ECORE,ARR,BRR,G1)
         Call ReadRIIntegrals(nBasis,I)
         CALL READFCIINT(UMAT,NBASIS,ECORE,ARR,BRR,G1,.false.)
         NBASISMAX(2,3)=0
         WRITE(6,*) ' ECORE=',ECORE
      ELSEIF(tReadInt.and.tCacheFCIDUMPInts) THEN
         call shared_allocate ("umat", umat, (/1/))
         !ALLOCATE(UMat(1),stat=ierr)
         LogAlloc(ierr,'UMat',1,HElement_t_SizeB,tagUMat)
         CALL SetupTMAT(nBasis,iSpinSkip,TMATINT)
!Now set up the UMatCache (**what size is allocated**.)
         IF(nBasis.ne.I) THEN
!We will freeze later - only allocate a small preliminary cache before freezing.
             WRITE(6,*) "Setting up pre-freezing UMatCache"
             call SetupUMatCache(I/2,.TRUE.)
!Here, if we are freezing, we only want to read in the <ij|kj> integrals - not all of them.
             tReadFreezeInts=.true.
         ELSE
!nBasisMax(2,3) is iSpinSkip = 1 if UHF and 2 if RHF/ROHF
             iSpinSkip=nBasisMax(2,3)
             IF(iSpinSkip.eq.1) THEN
                 WRITE(6,*) "Setting up main UMatCache for open-shell system (inefficient - ~16x too much memory used for ROHF)"
                 call SetupUMatCache(I,.FALSE.)
             ELSE
                 call SetupUMatCache(I/2,.FALSE.)
                 WRITE(6,*) "Setting up main UMatCache for closed-shell system"
             ENDIF
             tReadFreezeInts=.false.
         ENDIF
!Set up UMat2D for storing the <ij|u|ij> and <ij|u|ji> integrals
         call SetupUMat2D_df()  !This needs to be changed
!The actual UMat2D integrals are read here into UMat2D here, as well as the integrals needed into the cache.
         CALL READFCIINT(UMAT,NBASIS,ECORE,ARR,BRR,G1,tReadFreezeInts)

         NBASISMAX(2,3)=0   !This is generally iSpinSkp, but stupidly, needs to be .le.0 to indicate that we want to look up the integral.
         WRITE(6,*) ' ECORE=',ECORE
      ELSEIF(TREADINT.AND.TSTARSTORE) THEN
         WRITE(6,'(A)') '*** READING DOUBLES 2-VERTEX INTEGRALS FROM FCIDUMP ***'
         NBASISMAX(2,3)=2
         !NBASIS/nBasis is number of spin-orbitals
         CALL GENSymStatePairs(nBasis/2,.false.)
         !CALL WRITESYMORBS(nBasis,G1)
         !NBASISMAX(5,2)+1 is the number of irreps
         CALL SetupTMAT(nBasis,2,TMATINT)
         CALL CREATEINVBRR(BRR,nBasis)
         Call InitStarStoreUMat(nEl/2, nBasis/2)
         CALL GetUMatSize(nBasis,nEl,2,UMATINT)
         call shared_allocate ("umat", umat, (/UMatInt/))
         !Allocate(UMat(UMatInt), stat=ierr)
         LogAlloc(ierr, 'UMat', UMatInt,HElement_t_SizeB, tagUMat)
         if (iprocindex == 0) UMat = 0.d0
         CALL SETUPUMAT2D_DF()
         IF(TBIN) THEN
             CALL READFCIINTBIN(UMAT,NBASIS,ECORE,ARR,BRR,G1)
         ELSE
             CALL READFCIINT(UMAT,NBASIS,ECORE,ARR,BRR,G1,.false.)
         ENDIF
         WRITE(6,*) ' ECORE=',ECORE
         ISPINSKIP=2
      ELSEIF(TREADINT) THEN
         WRITE(6,'(A)') '*** READING PRIMITIVE INTEGRALS FROM FCIDUMP ***'
!.. Generate the 2e integrals (UMAT)
         ISPINSKIP=NBasisMax(2,3)
         IF(ISPINSKIP.le.0) STOP 'NBASISMAX(2,3) ISpinSkip unset'
!nBasisMax(2,3) is iSpinSkip = 1 if UHF and 2 if RHF/ROHF
         CALL GetUMatSize(nBasis,nEl,iSpinSkip,UMATINT)
         WRITE(6,*) "UMatSize: ",UMATINT
         UMatMem=REAL(UMatInt,8)*REAL(HElement_t_sizeB,8)*(9.536743164D-7)
         WRITE(6,"(A,G20.10,A)") " UMatMemory: ",UMatMem, " Mb/Processor"
         call shared_allocate ("umat", umat, (/UMatInt/))
         !Allocate(UMat(UMatInt), stat=ierr)
         LogAlloc(ierr, 'UMat', UMatInt,HElement_t_SizeB, tagUMat)
         if (iprocindex == 0) UMat = 0.d0
!nBasisMax(2,3) is iSpinSkip = 1 if UHF and 2 if RHF/ROHF
         CALL SetupTMAT(nBasis,iSpinSkip,TMATINT)
         IF(TBIN) THEN
            CALL READFCIINTBIN(UMAT,NBASIS,ECORE,ARR,BRR,G1)
         ELSE
            CALL READFCIINT(UMAT,NBASIS,ECORE,ARR,BRR,G1,.false.)
         ENDIF
         WRITE(6,*) 'ECORE=',ECORE
      ELSE
         ISPINSKIP=NBASISMAX(2,3)
         IF(NBASISMAX(1,3).GE.0) THEN
            IF(TUEG.OR.THUB) THEN
               IF(THUB.AND.TREAL) THEN
    !!C.. Real space hubbard
    !!C.. we pre-compute the 2-e integrals
                  WRITE(6,*) "Generating 2e integrals"
    !!C.. Generate the 2e integrals (UMAT)
                  CALL GetUMatSize(nBasis,nEl,iSpinSkip,UMATINT)
                  call shared_allocate ("umat", umat, (/UMatInt/))
                  !Allocate(UMat(UMatInt), stat=ierr)
                  LogAlloc(ierr, 'UMat', UMatInt,HElement_t_SizeB, tagUMat)
                  UMat = 0.d0
                  WRITE(6,*) "Size of UMat is: ",UMATINT
                  CALL CALCUMATHUBREAL(NEL,NBASIS,NBASISMAX,G1,UHUB,UMAT)
               ELSEIF(THUB.AND..NOT.TPBC) THEN
    !!C.. we pre-compute the 2-e integrals
                  WRITE(6,*) "Generating 2e integrals"
    !!C.. Generate the 2e integrals (UMAT)
                  CALL GetUMatSize(nBasis,nEl,iSpinSkip,UMATINT)
                  call shared_allocate ("umat", umat, (/UMatInt/))
                  !Allocate(UMat(UMatInt), stat=ierr)
                  LogAlloc(ierr, 'UMat', UMatInt,HElement_t_SizeB, tagUMat)
                  UMat = 0.d0
    !!C.. Non-periodic hubbard (mom space)
                  call gen_coul_hubnpbc
               ELSE
    !!C.. Most normal Hubbards
                  IF(.NOT.TUEG) THEN
    !                CALL GEN_COUL_UEG(NEL,NBASISMAX,nBasis,G1,NMSH,NMAX,FCK,UMAT,ISPINSKIP,THUB,UHUB,OMEGA,ALAT)
                     ISPINSKIP=-1
                     NBASISMAX(2,3)=-1
                     WRITE(6,*) "Not precomputing HUBBARD 2-e integrals"
                     call shared_allocate ("umat", umat, (/1/))
                     !Allocate(UMat(1), stat=ierr)
                     LogAlloc(ierr, 'UMat', 1,HElement_t_SizeB, tagUMat)
                     UMAT(1)=UHUB/OMEGA
                  ENDIF
    !!C.. The UEG doesn't store coul integrals
               ENDIF
            ELSE
    !!C.. We need to init the arrays regardless of whether we're storing H
    !!C..Need to initialise the Fourier arrays
               Allocate(Fck(nMsh**3),stat=ierr)
               LogAlloc(ierr,'FCK',NMSH**3,16,tagFCK)
               allocate(COEFF(2*(3*NMSH+48)))
               LogAlloc(ierr,'COEFF',2*(NMSH+1)*NMAX*NMAX,16,tagCOEFF)
               allocate(ZIA(2*(NMSH+1)*NMAX*NMAX))
               LogAlloc(ierr,'ZIA',2*(NMSH+1)*NMAX*NMAX,16,tagZIA)
               WRITE(6,*) NMSH,NMAX
    !!C..
               CALL N_MEMORY_CHECK()
               IF(NMAXZ.EQ.0) THEN
    !!C..  We're doing a 2D simulation
                  CALL INITFOU2D(NMSH,FCK,COEFF,NMAX,ALAT,TALPHA,ALPHA,OMEGA,ZIA)
               ELSE
                  CALL INITFOU(NMSH,FCK,COEFF,NMAX,ALAT,TALPHA,ALPHA,OMEGA,ZIA)
               ENDIF
               CALL N_MEMORY_CHECK()
    !!C.. we pre-compute the 2-e integrals
               WRITE(6,*) "Generating 2e integrals"
    !!C.. Generate the 2e integrals (UMAT)
               CALL GetUMatSize(nBasis,nEl,iSpinSkip,UMATINT)
               call shared_allocate ("umat", umat, (/UMatInt/))
               !Allocate(UMat(UMatInt), stat=ierr)
               LogAlloc(ierr, 'UMat', UMatInt,HElement_t_SizeB, tagUMat)
               UMat = 0.d0
               CALL GEN_COUL(NEL,NBASISMAX,nBasis,G1,NMSH,NMAX,FCK,UMAT,ISPINSKIP,ZIA)
               deallocate(ZIA)
               LogDealloc(tagZIA)
               LogDealloc(tagFCK)
               Deallocate(FCK)
            ENDIF
         ELSE
            WRITE(6,*) "Not precomputing 2-e integrals"
            call shared_allocate ("umat", umat, (/1/))
            !Allocate(UMat(1), stat=ierr)
            LogAlloc(ierr, 'UMat', 1,HElement_t_SizeB, tagUMat)
         ENDIF
         CALL N_MEMORY_CHECK()
    !!C.. we need to generate TMAT - Now setup in individual routines
         !CALL N_MEMORY(IP_TMAT,HElement_t_size*nBasis*nBasis,'TMAT')
         !TMAT=(0.d0)
         IF(THUB) THEN
            CALL CALCTMATHUB(NBASIS,NBASISMAX,BHUB,TTILT,G1,TREAL,TPBC)
         ELSE
    !!C..Cube multiplier
             CST=PI*PI/(2.D0*ALAT(1)*ALAT(1))
    !!C.. the UEG has k=2pi n/L rather than pi n/L, so we need to multiply the
    !!C.. KE up by 4
            IF(NBASISMAX(1,1).LE.0) CST=CST*4
            CALL CALCTMATUEG(NBASIS,ALAT,G1,CST,NBASISMAX(1,1).LE.0,OMEGA)
         ENDIF
      ENDIF
      !ENDIF

!      WRITE(6,*) "ONE ELECTRON"
!      do i=1,nBasis
!          do j=1,nBasis
!              WRITE(36,"(2I5,G25.10)") i,j,GetTMatEl(i,j)
!          enddo
!      enddo
!      WRITE(6,*) "TWO ELECTRON"
!      do i=1,nBasis
!          do j=1,nBasis
!              do k=1,nBasis
!                  do l=1,nBasis
!                     IDi = GTID(i)
!                     IDj = GTID(j)
!                     IDk = GTID(k)
!                     IDl = GTID(l)
!                     Index1=UMatInd(idi,idj,idk,idl,0,0)
!                     WRITE(37,"(9I5,G25.10)") i,j,k,l,idi,idj,idk,idl,Index1,GetUMatEl(NBasisMax,UMAT,ALAT,nBasis,ISpinSkip,G1,idi,idj,idk,idl)
!                 enddo
!             enddo
!         enddo
!     enddo

    ! Setup the umatel pointers as well
    call init_getumatel_fn_pointers ()


    End Subroutine IntInit
        

        
    Subroutine IntFreeze
      use SystemData, only: Alat,Brr,CoulDampOrb,ECore,fCoulDampMu
      use SystemData, only: G1,iSpinSkip,NIfD,NIfY,NIfP,NIfTot,tCSF,NIfDBO
      use SystemData, only: nBasis,nEl,arr,nbasismax
      use UMatCache, only: GetUMatSize
      use constants, only: dp,bits_n_int
      use SymData , only : TwoCycleSymGens
      use CalcData , only : tTruncInitiator,tDelayTruncInit
      use FciMCData , only : tDebug
      use global_utilities
      character(25), parameter ::this_routine='IntFreeze'            
!//Locals
      HElement_t, pointer :: UMAT2(:)
      INTEGER tagUMat2, ierr
      INTEGER nOcc
      integer UMATInt
      integer nHG

      nHG=nBasis
            
      CHEMPOT=(ARR(NEL,1)+ARR(NEL+1,1))/2.D0
      WRITE(6,*) "Chemical Potential: ",CHEMPOT
      IF(NTFROZEN.LT.0) THEN
         WRITE(6,*) "NTFROZEN<0.  Leaving ", -NTFROZEN," unfrozen virtuals."
         NTFROZEN=NTFROZEN+nBasis-NEL
      ENDIF
      IF((NFROZEN+NFROZENIN).gt.NEL) CALL Stop_All("IntFreeze","Overlap between low energy frozen orbitals &
                                                    & and inner frozen occupied orbitals - to many frozen occupied orbitals &
                                                    & for the number of electrons.")
      IF((NTFROZEN+NTFROZENIN).gt.(NBASIS-NEL)) CALL Stop_All("IntFreeze","Overlap between high energy frozen orbitals &
                                                    & and inner frozen virtual orbitals - to many frozen virtual orbitals &
                                                    & for the number of unnoccupied orbitals.")
      IF(((NFROZENIN.GT.0).or.(NTFROZENIN.GT.0)).and.(.not.TwoCycleSymGens)) CALL Stop_All("IntFreeze","TwoCycleSymGens is not true. &
                                                    & The code is only set up to deal with freezing from the inside for molecular &
                                                    & systems with only 8 symmetry irreps.")
      IF(NFROZEN.GT.0.OR.NTFROZEN.GT.0.OR.NFROZENIN.GT.0.OR.NTFROZENIN.GT.0) THEN
          WRITE(6,'(A)') '-------- FREEZING ORBITALS ----------'
!!C.. At this point, we transform the UMAT and TMAT into a new UMAT and
!!C.. TMAT and Ecore with the frozen orbitals factored in
!!C..
!!C.. a,b are frozen spinorbitals
!!C.. E'core = Ecore+sum_a t_aa + sum_(a<b) (<ab|ab>-<ab|ba>)
!!C.. t'_ii = t_ii+ sum_a ( <ai|ai> - <ai|ia> ) 
!!C.. NHG contains the old number of orbitals
!!C.. NBASIS contains the new
         NBASIS=NBASIS-NFROZEN-NTFROZEN-NFROZENIN-NTFROZENIN
!!C.. We need to transform some integrals
         !CALL N_MEMORY(IP_TMAT2,HElement_t_size*(NBASIS)**2,'TMAT2')
         !TMAT2=(0.d0)
         IF(NBASISMAX(1,3).GE.0.AND.ISPINSKIP.NE.0) THEN
            CALL GetUMatSize(nBasis,(nEl-NFROZEN-NFROZENIN),iSpinSkip,UMATINT)
                call shared_allocate ("umat2", umat2, (/UMatInt/))
                !Allocate(UMat2(UMatInt), stat=ierr)
                LogAlloc(ierr, 'UMat2', UMatInt,HElement_t_SizeB, tagUMat2)
            UMAT2 = 0.d0
         ELSE
!!C.. we don't precompute 4-e integrals, so don't allocate a large UMAT
            call shared_allocate ("umat2", umat2, (/1/))
            !Allocate(UMat2(1), stat=ierr)
            LogAlloc(ierr, 'UMat2', 1,HElement_t_SizeB, tagUMat2)
         ENDIF 
         CALL N_MEMORY_CHECK()

         WRITE(6,*) "Freezing ",NFROZEN," core orbitals."
         WRITE(6,*) "Freezing ",NTFROZEN," virtual orbitals."
         IF(NFROZENIN.ne.0) WRITE(6,*) "Freezing ",NFROZENIN," of the highest energy occupied (inner) orbitals."
         IF(NTFROZENIN.ne.0) WRITE(6,*) "Freezing ",NTFROZENIN," of the lowest energy virtual (inner) orbitals."
 
!At the end of IntFREEZEBASIS, NHG is reset to nBasis - the final number of active orbitals.
         CALL IntFREEZEBASIS(NHG,NBASIS,UMAT,UMAT2,ECORE, G1,NBASISMAX,ISPINSKIP,BRR,NFROZEN,NTFROZEN,NFROZENIN,NTFROZENIN,NEL,ALAT)
         CALL FLUSH(6)
         CALL N_MEMORY_CHECK()
         WRITE(6,*) "ECORE now",ECORE
         WRITE(6,*) "Number of orbitals remaining: ",NBASIS
         NEL=NEL-NFROZEN-NFROZENIN
         NOCC=NEL/2
!!C.. NEL now only includes active electrons
         WRITE(6,*) "Number of active electrons:",NEL
         
         !CALL N_FREEM(IP_TMAT)
         !IP_TMAT=IP_TMAT2
         !IP_TMAT2=NULL
!!C.. Now we can remove the old UMATRIX, and set the pointer UMAT to point
!!C.. to UMAT2
         LogDealloc(tagUMat)
         call shared_deallocate(umat)
         !Deallocate(UMat)
         UMat=>UMat2
         nullify(UMat2)
         tagUMat=tagUMat2
         tagUMat2=0
         CALL N_MEMORY_CHECK()
!         WRITE(6,*) "Active basis functions:",NHG
         CALL WRITEBASIS(6,G1,NHG,ARR,BRR)
      ENDIF
!      CALL WRITETMAT(NBASIS)
!      CALL WRITESYMCLASSES(NBASIS)

        ! Setup the umatel pointers as well
        call init_getumatel_fn_pointers ()
      
      ! This indicates the upper-bound for the determinants when expressed in
      ! bit-form. This will equal INT(nBasis/32).
      ! The actual total length for a determinant in bit form will be 
      ! NoIntforDet+1 + NIfY (which is the size of the Yamanouchi symbol)
      NIfD=INT(nBasis/bits_n_int)

      ! NIfY gives space to store number of open shell e-
      ! and the Yamanouchi symbol in a bit representation
      if (tCSF) then
          NIfY = int(nel/bits_n_int)+1
      else
          NIfY = 0
      endif
      NIfTot = NIfD + NIfY
      NIfDBO = NIfD + NIfY
        
      if (tTruncInitiator.or.tDelayTruncInit) then
! We need an integer to contain a flag of whether or not the parent of spawned walkers was inside or outside the active space.          
          NIfP = 1
      else
          NIfP = 0
      endif
      NIfTot = NIfTot + NIfP

      WRITE(6,*) "Setting integer length of determinants as bit-strings to: ",NIfD+NIfY+NIfP+1
      WRITE(6,*) "Setting integer bit-length of determinants as bit-strings to: ",bits_n_int

         
      IF(COULDAMPORB.GT.0) THEN
         FCOULDAMPMU=(ARR(COULDAMPORB,1)+ARR(COULDAMPORB+1,1))/2
         WRITE(6,*) "Setting Coulomb damping mu between orbitals ",ARR(COULDAMPORB,1)," and ",ARR(COULDAMPORB+1,1)
         WRITE(6,*) "MU=",FCOULDAMPMU
      ENDIF
    End Subroutine IntFreeze


    subroutine IntCleanup (iCacheFlag)
        use SystemData, only: G1, nBasis
        use UMatCache, only: iDumpCacheFlag, tReadInCache, nStates, &
                             nStatesDump, DumpUMatCache, DestroyUMatCache, &
                             WriteUMatCacheStats
        integer :: iCacheFlag
        character(*), parameter :: this_routine = 'IntCleanup'

        if ((btest(iDumpCacheFlag, 0) .and. &
            (nStatesDump < nStates .or. .not. tReadInCache)) .or. &
            btest(iDumpCacheFlag, 1)) call DumpUMatCache (nBasis, G1)

        ! If we're told explicitly not to destroy the cache, we don't
        if (.not. btest(iCacheFlag, 0)) then
            call DestroyUMatCache ()
        else
            call WriteUMatCacheStats ()
        endif

        ! Cleanup UMAT array
        if (associated(UMAT)) then
            LogDealloc (tagUMat)
            call shared_deallocate (UMAT)
        endif
    end subroutine

!This routine takes the frozen orbitals and modifies ECORE, UMAT, BRR etc accordingly.
    SUBROUTINE IntFREEZEBASIS(NHG,NBASIS,UMAT,UMAT2,ECORE,           &
   &         G1,NBASISMAX,ISS,BRR,NFROZEN,NTFROZEN,NFROZENIN,NTFROZENIN,NEL,ALAT)
       use constants, only: dp
       use SystemData, only: Symmetry,BasisFN,BasisFNSize,arr,tagarr,tHub
       use OneEInts
       USE UMatCache, only: FreezeTransfer,UMatCacheData,UMatInd,TUMat2D
       Use UMatCache, only: FreezeUMatCache, CreateInvBrr2,FreezeUMat2D, SetupUMatTransTable
       use UMatCache, only: GTID
       use global_utilities

       IMPLICIT NONE
       INTEGER NHG,NBASIS,nBasisMax(5,*),ISS
       TYPE(BASISFN) G1(NHG),KSYM
       HElement_t UMAT(*)
!!C.. was (NHG/ISS,NHG/ISS,NHG/ISS,NHG/ISS)
       HElement_t UMAT2(*)
       REAL*8 ECORE
!!C.. was (NBASIS/ISS,NBASIS/ISS,NBASIS/ISS,NBASIS/ISS)
       REAL*8 ARR2(NBASIS,2)
       INTEGER NFROZEN,BRR(NHG),BRR2(NBASIS),GG(NHG)
       TYPE(BASISFN) G2(NHG)
       INTEGER NTFROZEN,NFROZENIN,NTFROZENIN
       INTEGER BLOCKMINW,BLOCKMAXW,FROZENBELOWW,BLOCKMINY,BLOCKMAXY,FROZENBELOWY
       INTEGER BLOCKMINX,BLOCKMAXX,FROZENBELOWX,BLOCKMINZ,BLOCKMAXZ,FROZENBELOWZ
       INTEGER I,J,K,L,A,B,IP,JP,KP,LP,IDI,IDJ,IDK,IDL,W,X,Y,Z
       INTEGER IB,JB,KB,LB,AB,BB,IPB,JPB,KPB,LPB
       INTEGER IDIP,IDJP,IDKP,IDLP
       INTEGER IDA,IDB,SGN
       INTEGER iSize,ierr
       INTEGER FDET(NEL),NEL
!       TYPE(Symmetry) KSYM
       REAL*8 ALAT(3)
       character(*), parameter :: this_routine='IntFreezeBasis'

       IF(tHub) THEN
           CALL Stop_All("IntFreezeBasis","Freezing does not currently work with the hubbard model.")
       ENDIF

!!C.. Just check to see if we're not in the middle of a degenerate set with the same sym
       IF(NFROZEN.GT.0) THEN
          IF(ABS(ARR(NFROZEN,1)-ARR(NFROZEN+1,1)).LT.1.D-6.AND.       &
   &        G1(BRR(NFROZEN))%SYM%s.EQ.G1(BRR(NFROZEN+1))%SYM%s) THEN
             STOP "Cannot freeze in the middle of a degenerate set"
          ELSE IF (ABS(ARR(NFROZEN,1)-ARR(NFROZEN+1,1)).LT.1.D-6) THEN
             write (6,'(a)') 'WARNING: Freezing in the middle of a degenerate set.'
             write (6,'(a)') 'This should only be done for debugging purposes.'
          ENDIF
       ENDIF
       IF(NTFROZEN.GT.0) THEN
          IF(ABS(ARR(NHG-NTFROZEN,1)-ARR(NHG-NTFROZEN+1,1)).LT.1.D-6  &
   &         .AND.G1(BRR(NHG-NTFROZEN))%SYM%s                         &
   &               .EQ.G1(BRR(NHG-NTFROZEN+1))%SYM%s) THEN
             STOP "Cannot freeze in the middle of a degenerate virtual set"
          ELSE IF (ABS(ARR(NHG-NTFROZEN,1)-ARR(NHG-NTFROZEN+1,1)).LT.1.D-6) THEN
             write (6,'(a)') 'WARNING: Freezing in the middle of a degenerate set.'
             write (6,'(a)') 'This should only be done for debugging purposes.'
          ENDIF
       ENDIF
       IF(NFROZENIN.GT.0) THEN
          IF(ABS(ARR(NEL-NFROZENIN,1)-ARR(NEL-NFROZENIN+1,1)).LT.1.D-6.AND.       &
   &        G1(BRR(NEL-NFROZENIN))%SYM%s.EQ.G1(BRR(NEL-NFROZENIN+1))%SYM%s) THEN
             STOP "Cannot freeze in the middle of a degenerate set"
          ELSE IF (ABS(ARR(NEL-NFROZENIN,1)-ARR(NEL-NFROZENIN+1,1)).LT.1.D-6) THEN
             write (6,'(a)') 'WARNING: Freezing in the middle of a degenerate set.'
             write (6,'(a)') 'This should only be done for debugging purposes.'
          ENDIF
       ENDIF
       IF(NTFROZENIN.GT.0) THEN
          IF(ABS(ARR(NEL+NTFROZENIN,1)-ARR(NEL+NTFROZENIN+1,1)).LT.1.D-6  &
   &         .AND.G1(BRR(NEL+NTFROZENIN))%SYM%s                         &
   &               .EQ.G1(BRR(NEL+NTFROZENIN+1))%SYM%s) THEN
             STOP "Cannot freeze in the middle of a degenerate virtual set"
          ELSE IF (ABS(ARR(NEL+NTFROZENIN,1)-ARR(NEL+NTFROZENIN+1,1)).LT.1.D-6) THEN
             write (6,'(a)') 'WARNING: Freezing in the middle of a degenerate set.'
             write (6,'(a)') 'This should only be done for debugging purposes.'
          ENDIF
       ENDIF


!!C.. At this point, we transform the UMAT and TMAT into a new UMAT and
!!C.. TMAT and Ecore with the frozen orbitals factored in
!!C..
!!C.. a,b are frozen spinorbitals
!!C.. E'core = Ecore+sum_a t_aa + sum_(a<b) (<ab|ab>-<ab|ba>)
!!C.. t'_ii = t_ii+ sum_a ( <ai|ai> - <ai|ia> ) 
!!C.. NHG contains the old number of orbitals
!!C.. NBASIS contains the new
!!C.. We first need to work out where each of the current orbitals will
!!C.. end up in the new set

       K=0
       DO I=1,NHG
          L=1
          DO J=1,NFROZEN
!C.. if orb I is to be frozen, L will become 0
             IF(BRR(J).EQ.I) L=0
          ENDDO
          DO J=NEL-NFROZENIN+1,NEL
             IF(BRR(J).EQ.I) L=0
          ENDDO
          DO J=NEL+1,NEL+NTFROZENIN
             IF(BRR(J).EQ.I) L=0
          ENDDO
          DO J=NBASIS+NFROZEN+NFROZENIN+NTFROZENIN+1,NHG
!C.. if orb I is to be frozen, L will become 0
             IF(BRR(J).EQ.I) L=0
          ENDDO
          IF(L.EQ.0) THEN
             GG(I)=0
          ELSE
!C.. we've got an orb which is not to be frozen 
             K=K+L
!C.. GG(I) is the new position in G of the (old) orb I
             GG(I)=K
!C.. copy the eigenvalue table to the new location
             G2(K)=G1(I)
!             CALL NECI_ICOPY(BasisFNSize,G1(I),1,G2(K),1)
          ENDIF
       ENDDO

!C.. Now construct the new BRR and ARR
!       DO I=1,NBASIS

!Need to run through the remaining orbitals in 2 lots, the occupied and virtual, because
!each are being shifted by different amounts.  The occupied are only affected by the low energy 
!frozen orbitals, but the virtuals need to also account for the inner frozen orbitals.
       DO W=1,2
          IF(W.eq.1) THEN
              BLOCKMINW=1 
              BLOCKMAXW=NEL-NFROZEN-NFROZENIN
              FROZENBELOWW=NFROZEN
          ELSEIF(W.eq.2) THEN
              BLOCKMINW=NEL-NFROZEN-NFROZENIN+1 
              BLOCKMAXW=NBASIS
              FROZENBELOWW=NFROZEN+NFROZENIN+NTFROZENIN
          ENDIF
          DO I=BLOCKMINW,BLOCKMAXW
              BRR2(I)=GG(BRR(I+FROZENBELOWW))
              ARR2(I,1)=ARR(I+FROZENBELOWW,1)
          ENDDO
       ENDDO 

       DO I=1,NHG
          IF(GG(I).NE.0) ARR2(GG(I),2)=ARR(I,2)
       ENDDO

       IF(TSTARSTORE.or.tCPMDSymTMat) THEN
          IF(NFROZENIN.gt.0.or.NTFROZENIN.gt.0)             &
!The symmetry routines (GETSYM etc) required for StarStore or CPMD are a bit confusing, so these have not been set 
!up to cope with freezing the inner orbitals as it is not expected to be done with these options much.
!Can remove this restriction and modify the symmetry routines if needed.
  &           CALL Stop_All("IntFreezeBasis","Freezing from the inner is not set up to cope &
                            &with StarStore or CPMDSymTMat.")
!C.. Now setup the default symmetry to include the frozen electrons
!C.. BRR(1:NFROZEN) is effectively the det of the frozens, so we get its sym
          IF (NFROZEN>0) THEN
             ! if no orbitals are frozen then the symmetry of the "frozen"
             ! orbitals is already initialised as totally symmetric.
             CALL GETSYM(BRR,NFROZEN,G1,NBASISMAX,KSym)
             CALL SetupFreezeAllSym(KSYM)
          END IF
!C.. Freeze the sym labels
          !SYMCLASSES2 gives the new symmetry of the frozen set of orbitals
          CALL FREEZESYMLABELS(NHG,NBASIS,GG,.true.)
!C.. Copy the new G1 over the old ones
          do i=1,nbasis
              G1(i)=G2(i)
          enddo
!          CALL NECI_ICOPY(BasisFNSize*NBASIS,G2,1,G1,1)
          !Redo SYMLABELCOUNTS
          CALL GENSymStatePairs(NBASIS/2,.true.)
       ENDIF
       CALL SetupTMAT2(NBASIS,2,iSize)

!C.. First deal with Ecore
!Adding the energy of the occupied orbitals to the core energy.
!Need to do this for both the low energy frozen and inner frozen orbitals.
       DO A=1,NFROZEN
          AB=BRR(A)
          ! Ecore' = Ecore + sum_a <a|h|a> where a is a frozen spin orbital
          ! TMATEL is the one electron integrals <a|h|a>.
          ECORE=ECORE+GetTMATEl(AB,AB)

          ! Ecore' = Ecore + sum a<b (<ab|ab> - <ab|ba>)
          DO B=A+1,NFROZEN
             BB=BRR(B)
             IDA = GTID(AB)
             IDB = GTID(BB)
!C.. No sign problems from permuations here as all perms even
             ECORE=ECORE+GETUMATEL(NBASISMAX,UMAT,ALAT,NHG,ISS,G1,IDA,IDB,IDA,IDB)
!C.. If we have spin-independent integrals, or 
!C.. if the spins are the same
             IF(G1(AB)%MS.EQ.G1(BB)%MS)                               &
   &            ECORE=ECORE-GETUMATEL(NBASISMAX,UMAT,ALAT,NHG,ISS,G1,IDA,IDB,IDB,IDA)
          ENDDO

!The sum over b runs over all frozen orbitals > a, so the inner frozen orbitals too.          
          DO B=NEL-NFROZENIN+1,NEL
             BB=BRR(B)
             IDA = GTID(AB)
             IDB = GTID(BB)
!C.. No sign problems from permuations here as all perms even
             ECORE=ECORE+GETUMATEL(NBASISMAX,UMAT,ALAT,NHG,ISS,G1,IDA,IDB,IDA,IDB)
!C.. If we have spin-independent integrals, or 
!C.. if the spins are the same
             IF(G1(AB)%MS.EQ.G1(BB)%MS)                               &
   &            ECORE=ECORE-GETUMATEL(NBASISMAX,UMAT,ALAT,NHG,ISS,G1,IDA,IDB,IDB,IDA)
          ENDDO
       ENDDO

!Need to also account for when a is the frozen inner orbitals, but b > a, so b only runs over the frozen 
!inner.
       DO A=NEL-NFROZENIN+1,NEL
          AB=BRR(A)
          ECORE=ECORE+GetTMATEl(AB,AB)
          DO B=A+1,NEL
             BB=BRR(B)
             IDA = GTID(AB)
             IDB = GTID(BB)
!C.. No sign problems from permuations here as all perms even
             ECORE=ECORE+GETUMATEL(NBASISMAX,UMAT,ALAT,NHG,ISS,G1,IDA,IDB,IDA,IDB)
!C.. If we have spin-independent integrals, or 
!C.. if the spins are the same
             IF(G1(AB)%MS.EQ.G1(BB)%MS)                               &
   &            ECORE=ECORE-GETUMATEL(NBASISMAX,UMAT,ALAT,NHG,ISS,G1,IDA,IDB,IDB,IDA)
          ENDDO
       ENDDO

!C.. now deal with the new TMAT
       FREEZETRANSFER=.true.
!First the low energy frozen orbitals.

!t'_ii = t_ii+ sum_a ( <ai|ai> - <ai|ia> ) 
!Again need to do this for the remaining occupied, and then the remaining virtual separately.
!The above i runs over all orbitals, whereas a is only over the occupied virtuals.
       DO W=1,2
          IF(W.eq.1) THEN
              BLOCKMINW=1 
              BLOCKMAXW=NEL-NFROZEN-NFROZENIN
              FROZENBELOWW=NFROZEN
          ELSEIF(W.eq.2) THEN
              BLOCKMINW=NEL-NFROZEN-NFROZENIN+1 
              BLOCKMAXW=NBASIS
              FROZENBELOWW=NFROZEN+NFROZENIN+NTFROZENIN
          ENDIF
 
          DO I=BLOCKMINW,BLOCKMAXW
              IP=I+FROZENBELOWW
              IB=BRR(IP)
              IPB=GG(IB)
              IDI = GTID(IB)

!I and J give the indexes of the TMAT.  This bit accounts for the off-diagonal terms which must be copied accross.          
              DO Y=1,2
                 IF(Y.eq.1) THEN
                    BLOCKMINY=1 
                    BLOCKMAXY=NEL-NFROZEN-NFROZENIN
                    FROZENBELOWY=NFROZEN
                 ELSEIF(Y.eq.2) THEN
                    BLOCKMINY=NEL-NFROZEN-NFROZENIN+1 
                    BLOCKMAXY=NBASIS
                    FROZENBELOWY=NFROZEN+NFROZENIN+NTFROZENIN
                 ENDIF
 
                 DO J=BLOCKMINY,BLOCKMAXY
                    JP=J+FROZENBELOWY
                    JB=BRR(JP)
                    JPB=GG(JB)
                    IDJ = GTID(JB)
                    IF(TSTARSTORE.or.tCPMDSymTMat) THEN
                       TMATSYM2(NEWTMATInd(IPB,JPB))=GetTMATEl(IB,JB)
                    ELSE
                       IF(IPB.eq.0.or.JPB.eq.0) THEN
!                           WRITE(6,*) 'W',W,'I',I,'J',J,'IPB',IPB,'JPB',JPB
!                           CALL FLUSH(6)
!                           CALL Stop_All("","here 01")
                       ENDIF
                       TMAT2D2(IPB,JPB)=GetTMATEl(IB,JB)
                    ENDIF
                    DO A=1,NFROZEN
                       AB=BRR(A)
                       IDA = GTID(AB)
!C.. SGN takes into account permutationnness.
!C                SGN=1
!C                IF(IB.GT.AB) SGN=-SGN
!C                IF(JB.GT.AB) SGN=-SGN
                       IF(G1(IB)%MS.EQ.G1(JB)%MS) THEN
                          IF(TSTARSTORE.or.tCPMDSymTMat) THEN
                             TMATSYM2(NEWTMATInd(IPB,JPB))=                  &
   &                         GetNEWTMATEl(IPB,JPB)+GETUMATEL(NBASISMAX,UMAT,ALAT,NHG,ISS,G1,IDA,IDI,IDA,IDJ)
                          ELSE
!                             IF(IPB.eq.0.or.JPB.eq.0) CALL Stop_All("","here 02")
                             TMAT2D2(IPB,JPB)=TMAT2D2(IPB,JPB)+GETUMATEL(NBASISMAX,UMAT,ALAT,NHG,ISS,G1,IDA,IDI,IDA,IDJ)
                          ENDIF
                       ENDIF
!C.. If we have spin-independent integrals, ISS.EQ.2.OR
!C.. if the spins are the same
                       IF(G1(IB)%MS.EQ.G1(AB)%MS.AND.G1(AB)%MS.EQ.G1(JB)%MS) THEN
                          IF(TSTARSTORE.or.tCPMDSymTMat) THEN
                             TMATSYM2(NEWTMATInd(IPB,JPB))=GetNEWTMATEl(IPB,JPB) &
   &                         -GETUMATEL(NBASISMAX,UMAT,ALAT,NHG,ISS,G1,IDA,IDI,IDJ,IDA)        
                          ELSE
!                             IF(IPB.eq.0.or.JPB.eq.0) CALL Stop_All("","here 03")
                             TMAT2D2(IPB,JPB)=GetNEWTMATEl(IPB,JPB)              &
   &                         -GETUMATEL(NBASISMAX,UMAT,ALAT,NHG,ISS,G1,IDA,IDI,IDJ,IDA)
                          ENDIF
                       ENDIF
                    ENDDO
                    DO A=NEL-NFROZENIN+1,NEL
                       AB=BRR(A)
                       IDA = GTID(AB)
!C.. SGN takes into account permutationnness.
!C                SGN=1
!C                IF(IB.GT.AB) SGN=-SGN
!C                IF(JB.GT.AB) SGN=-SGN
                       IF(G1(IB)%MS.EQ.G1(JB)%MS) THEN
                          IF(TSTARSTORE.or.tCPMDSymTMat) THEN
                             TMATSYM2(NEWTMATInd(IPB,JPB))=                  &
   &                         GetNEWTMATEl(IPB,JPB)+GETUMATEL(NBASISMAX,UMAT,ALAT,NHG,ISS,G1,IDA,IDI,IDA,IDJ)
                          ELSE
!                             IF(IPB.eq.0.or.JPB.eq.0) CALL Stop_All("","here 04")
                             TMAT2D2(IPB,JPB)=TMAT2D2(IPB,JPB)+GETUMATEL(NBASISMAX,UMAT,ALAT,NHG,ISS,G1,IDA,IDI,IDA,IDJ)
                          ENDIF
                       ENDIF
!C.. If we have spin-independent integrals, ISS.EQ.2.OR
!C.. if the spins are the same
                       IF(G1(IB)%MS.EQ.G1(AB)%MS.AND.G1(AB)%MS.EQ.G1(JB)%MS) THEN
                          IF(TSTARSTORE.or.tCPMDSymTMat) THEN
                             TMATSYM2(NEWTMATInd(IPB,JPB))=GetNEWTMATEl(IPB,JPB) &
   &                         -GETUMATEL(NBASISMAX,UMAT,ALAT,NHG,ISS,G1,IDA,IDI,IDJ,IDA)        
                          ELSE
!                             IF(IPB.eq.0.or.JPB.eq.0) CALL Stop_All("","here 05")
                             TMAT2D2(IPB,JPB)=GetNEWTMATEl(IPB,JPB)              &
   &                         -GETUMATEL(NBASISMAX,UMAT,ALAT,NHG,ISS,G1,IDA,IDI,IDJ,IDA)
                          ENDIF
                       ENDIF
                    ENDDO
!             WRITE(6,*) "T",TMAT(IB,JB),I,J,TMAT2(IPB,JPB)
!          IF(abs(TMAT(IPB,JPB)).gt.1.D-9) WRITE(16,*) I,J,TMAT2(IPB,JPB)
                 ENDDO
             ENDDO
          ENDDO  
       ENDDO

       IF(NBASISMAX(1,3).GE.0.AND.ISS.NE.0) THEN

          CALL CREATEINVBRR2(BRR2,NBASIS)
!CC Only do the below if we've a stored UMAT
!C.. Now copy the relevant matrix elements of UMAT across
!C.. the primed (...P) are the new versions
          DO W=1,2
              IF(W.eq.1) THEN
                  BLOCKMINW=1 
                  BLOCKMAXW=NEL-NFROZEN-NFROZENIN
                  FROZENBELOWW=NFROZEN
              ELSEIF(W.eq.2) THEN
                  BLOCKMINW=NEL-NFROZEN-NFROZENIN+1 
                  BLOCKMAXW=NBASIS
                  FROZENBELOWW=NFROZEN+NFROZENIN+NTFROZENIN
              ENDIF
              DO I=BLOCKMINW,BLOCKMAXW
                 IB=BRR(I+FROZENBELOWW)
                 IPB=GG(IB)
                 IF(ISS.NE.0.OR.G1(I)%MS.EQ.1) THEN
                    IDI = GTID(IB)
                    IDIP = GTID(IPB)
                    DO X=1,2
                      IF(X.eq.1) THEN
                         BLOCKMINX=1 
                         BLOCKMAXX=NEL-NFROZEN-NFROZENIN
                         FROZENBELOWX=NFROZEN
                      ELSEIF(X.eq.2) THEN
                         BLOCKMINX=NEL-NFROZEN-NFROZENIN+1 
                         BLOCKMAXX=NBASIS
                         FROZENBELOWX=NFROZEN+NFROZENIN+NTFROZENIN
                      ENDIF
                      DO J=BLOCKMINX,BLOCKMAXX
                          JB=BRR(J+FROZENBELOWX)
                          JPB=GG(JB)
                          IF(ISS.NE.0.OR.G1(I)%MS.EQ.1) THEN
                             IDJ = GTID(JB)
                             IDJP = GTID(JPB)
                             DO Y=1,2
                                 IF(Y.eq.1) THEN
                                    BLOCKMINY=1 
                                    BLOCKMAXY=NEL-NFROZEN-NFROZENIN
                                    FROZENBELOWY=NFROZEN
                                 ELSEIF(Y.eq.2) THEN
                                    BLOCKMINY=NEL-NFROZEN-NFROZENIN+1 
                                    BLOCKMAXY=NBASIS
                                    FROZENBELOWY=NFROZEN+NFROZENIN+NTFROZENIN
                                 ENDIF
                                 DO K=BLOCKMINY,BLOCKMAXY
                                    KB=BRR(K+FROZENBELOWY)
                                    KPB=GG(KB)
                                    IF(ISS.NE.0.OR.G1(I)%MS.EQ.1) THEN
                                       IDK = GTID(KB)
                                       IDKP = GTID(KPB)
                                       DO Z=1,2
                                         IF(Z.eq.1) THEN
                                            BLOCKMINZ=1 
                                            BLOCKMAXZ=NEL-NFROZEN-NFROZENIN
                                            FROZENBELOWZ=NFROZEN
                                         ELSEIF(Z.eq.2) THEN
                                            BLOCKMINZ=NEL-NFROZEN-NFROZENIN+1 
                                            BLOCKMAXZ=NBASIS
                                            FROZENBELOWZ=NFROZEN+NFROZENIN+NTFROZENIN
                                         ENDIF
                                         DO L=BLOCKMINZ,BLOCKMAXZ
                                              IF((K*(K-1))/2+I.GE.(L*(L-1))/2+J) THEN
                                                 LB=BRR(L+FROZENBELOWZ)
                                                 LPB=GG(LB)
                                                 IF(ISS.NE.0.OR.G1(I)%MS.EQ.1) THEN
                                                    IDL = GTID(LB)
                                                    IDLP = GTID(LPB)
                                                    IF(TSTARSTORE) THEN
                                                       IF(.NOT.TUMAT2D) STOP 'UMAT2D should be on'
                                                       IF((IDI.eq.IDJ.and.IDI.eq.IDK.and.IDI.eq.IDL).or.    &
                   &                                        (IDI.eq.IDK.and.IDJ.eq.IDL).or.                 &
                   &                                        (IDI.eq.IDL.and.IDJ.eq.IDK).or.                 &
                   &                                        (IDI.eq.IDJ.and.IDK.eq.IDL)) THEN
                                                          CONTINUE
                                                       ELSE
                                                          IF(((I+FROZENBELOWZ).gt.NEL).or.((J+FROZENBELOWZ).gt.NEL)) THEN
                                                             CONTINUE
                                                          ELSE
                                                             UMAT2(UMatInd(IDIP,IDJP,IDKP,IDLP,0,(NEL-NFROZEN-NFROZENIN)/2))=  &
                   &                                                          UMAT(UMatInd(IDI,IDJ,IDK,IDL,NHG/2,0))
                                                          ENDIF
                                                       ENDIF
                                                    ELSE
                                                       UMAT2(UMatInd(IDIP,IDJP,IDKP,IDLP,0,0))=             &
                   &                                                 UMAT(UMatInd(IDI,IDJ,IDK,IDL,NHG/2,0))
                                                    ENDIF
                                                 ENDIF
                                              ENDIF
                                         ENDDO
                                       ENDDO
                                    ENDIF
                                 ENDDO
                             ENDDO
                          ENDIF
                      ENDDO
                    ENDDO
                 ENDIF
              ENDDO
          ENDDO
          CALL FLUSH(11)
          CALL FLUSH(12)
 
          IF(TSTARSTORE) CALL FreezeUMAT2D(NHG,NBASIS,GG,2)
       ELSEIF(Associated(UMatCacheData)) THEN
!.. We've a UMAT2D and a UMATCACHE.  Go and Freeze them
!C.. NHG contains the old number of orbitals
!C.. NBASIS contains the new
!C.. GG(I) is the new position in G of the (old) orb I
          CALL FreezeUMatCache(GG,NHG,NBASIS)
       ENDIF
       IF(ISS.EQ.0) CALL SetupUMatTransTable(GG,nHG,nBasis)

!       do i=1,NBASIS
!           WRITE(6,*) i,G2(i)%Sym%S
!       enddo

       IF(.NOT.TSTARSTORE) THEN
          IF(NFROZENIN.gt.0) THEN
!             CALL GETSYM(BRR,NFROZEN,BRR((NEL-NFROZENIN+1):NEL),G1,NBASISMAX,KSym)
!This is slightly dodgey... I have commented out the above routine that finds the symmetry of the frozen orbitals.
!There is already a test to check we are not freezing in the middle of degenracies, so the symmetry should always come
!out as 0 anyway, unless we are breaking up a set of symmetry irreps somehow ... I think.
             WRITE(6,*) "WARNING: Setting the symmetry of the frozen orbitals to 0. This will be incorrect &
                        &if orbitals are frozen in the middle of a degenerate set of the same symmetery irrep."
             KSym%Sym%S=0
             CALL SetupFREEZEALLSYM(KSym)
          ELSEIF(NFROZEN>0) THEN
             CALL GETSYM(BRR,NFROZEN,G1,NBASISMAX,KSym)
!             WRITE(6,*) '************'
!             WRITE(6,*) 'KSym',KSym
             CALL SetupFREEZEALLSYM(KSym)
          END IF
          CALL FREEZESYMLABELS(NHG,NBASIS,GG,.false.)
          do i=1,NBASIS
              G1(i)=G2(i)
          enddo
!          CALL NECI_ICOPY(BasisFNSize*NBASIS,G2,1,G1,1)
       ENDIF 

       FREEZETRANSFER=.false.
!C.. Copy the new BRR and ARR over the old ones
       CALL SWAPTMAT(NBASIS,NHG,GG)

       deallocate(arr)
       LogDealloc(tagarr)
       allocate(arr(nBasis,2),stat=ierr)
       LogAlloc(ierr,'Arr',2*nBasis,8,tagArr)

       CALL NECI_ICOPY(NBASIS,BRR2,1,BRR,1)
       CALL DCOPY(NBASIS*2,ARR2,1,ARR,1)
!C.. Now reset the total number of orbitals
       NHG=NBASIS
       Call DetFreezeBasis(GG)

       RETURN
    end subroutine intfreezebasis



    function GetUMatEl2(I,J,A,B)
       ! A wrapper for GetUMatEl, now everything is available via modules.
       ! In:
       !    I,J,A,B: indices of integral
       ! Returns <ij|ab>
       use SystemData, only: ALAT,G1,iSpinSkip,nBasis,nBasisMax
       implicit none
       HElement_t GetUMatEl2
       integer :: I,J,A,B
       
       GetUMatEl2=GetUMatEl(nBasisMax,UMat,ALAT,nBasis,iSpinSkip,G1,I,J,A,B)

    end function GetUMatEl2

    subroutine init_getumatel_fn_pointers ()

        integer :: iss
        character(*), parameter :: this_routine = 'init_getumatel_fn_pointers'

        if (nBasisMax(1,3) >= 0) then
            ! This is a hack. iss is not what it should be. grr.
            iss = nBasisMax(2,3)
            if (iss == 0) then
                ! Store <ij|ij> and <ij|ji> in umat2d.
                ! n.b. <ij|jk> == <ii|jj>
                !
                ! If complex, more difficult:
                ! <ii|ii> is always real and allowed.
                ! <ij|ij> is always real and allowed (densities i*i, j*j)
                ! <ij|ji> is always reald and allowed (codensities i*j, and
                !                                      j*i = (i*j)*)
                ! <ii|jj> is not stored in umat2d, and may not be allowed by
                !         symmetry. It can be complex.
                ! If orbitals are real, we substitute <ij|ij> for <ii|jj>

                if (tumat2d) then
                    ! call umat2d routine
                    call set_getumatel_fn (get_umat_el_tumat2d)

                else
                    ! see if in the cache. This is the fallback if ids are
                    ! such that umat2d canot be used anyway.
                    call set_getumatel_fn (get_umat_el_cache)
                endif
            else if (iss == -1) then
                ! Non-stored hubbard integral
                call set_getumatel_fn (get_hub_umat_el)
            else
                if (tStarStore) then
                    if (.not. tumat2d) &
                        call stop_all (this_routine, &
                                       'UMat2D is required for tStarStore')
                    write (6, '(" Setting StarStore GetUMatEl routine")')
                    call set_getumatel_fn (get_umat_el_starstore)
                else
                    write (6, '(" Setting normal GetUMatEl routine")')
                    call set_getumatel_fn (get_umat_el_normal)
                endif
            endif
        else if (nBasisMax(1,3) == -1) then
            ! UEG integral
            call set_getumatel_fn (get_ueg_umat_el)
        endif

        ! Note that this comes AFTER the above tests
        ! --> the tfixlz case is earlier in the list and will therefore be
        !     executed first.
        if (tFixLz) then
            if (tStoreSpinOrbs) then
                write (6, '(" Setting GetUmatEl to use fixed lz with &
                            &tStoreSpinOrbs set")')
                call set_getumatel_stack (get_umat_el_fixlz_storespinorbs)
            else
                write (6, '(" Setting GetUmatEl to use fixed lz without &
                            &tStoreSpinOrbs set")')
                call set_getumatel_stack (get_umat_el_fixlz_notspinorbs)
            endif
        endif

    end subroutine

    function get_umat_el_tumat2d (idi, idj, idk, idl) result (hel)

        integer, intent(in) :: idi, idj, idk, idl
        integer :: i, j
        HElement_t :: hel

        if ( (idi == idj) .and. (idi == idk) .and. (idi == idl) ) then
            ! <ii|ii>
            hel = umat2d (idi, idi)
        else if ( (idi == idk) .and. (idj == idl) ) then
            ! <ij|ij>
            i = min (idi, idj)
            j = max (idi, idj)
            hel = umat2d (i, j)
        else if ( (idi == idl) .and. (idj == idk) ) then
            ! <ij|ji>
            i = max (idi, idj)
            j = min (idi, idj)
            hel = umat2d (i, j)
        else if ( (tCacheFCIDumpInts .or. tRIIntegrals) .and. &
                  (idi == idj) .and. (idk == idl) .and. &
                  (HElement_t_size == 1) ) then
            ! <ii|jj> = <ij|ji>, only for real systems (andn not for the local
            !                    exchange scheme.
            i = max (idi, idk)
            j = min (idi, idk)
            hel = umat2d (i, j)
        else
            hel = get_umat_el_cache (idi, idj, idk, idl)
        endif

    end function get_umat_el_tumat2d

    function get_umat_el_cache (idi, idj, idk, idl) result (hel)

        integer, intent(in) :: idi, idj, idk, idl
        integer :: i, j, k, l, a, b
        integer :: iType, iCache, iCacheI
        type(Symmetry) :: sym
        HElement_t :: hel, UElems(0:nTypes-1)
        logical :: calc2ints
        complex(dp) :: vasp_int(1, 0:1)

        i = idi
        j = idj
        k = idk
        l = idl
        sym = TotSymRep ()

        ! UHF/ROHF (but not explicit ROHF in input) calculation. Integrals
        ! stored as spin-orbitals already...
        ! Also assume real orbitals, since this can only be done by
        ! tCacheFCIDumpInts
        if (tStoreSpinOrbs) then
            sym = symProd (sym, G1(i)%Sym)
            sym = symProd (sym, G1(j)%Sym)
            sym = symProd (sym, G1(k)%Sym)
            sym = symProd (sym, G1(l)%Sym)
        else
            sym = symProd (sym, symConj(G1(2*i-1)%Sym))
            sym = symProd (sym, symConj(G1(2*j-1)%Sym))
            sym = symProd (sym, G1(2*k-1)%Sym)
            sym = symProd (sym, G1(2*l-1)%Sym)
        endif

        ! Check the symmetry of the 4-index integrals
        if ( .not. lSymSym(sym)) then
            hel = 0
            return
        endif

        ! First check whether we can reduce a set of k-points to a simpler
        ! symmetry related one.
        ! TODO: can we function pointer out this bit?
        if (HasKPoints()) then
            if (tTransFIndx) then
                i = TransTable (i)
                j = TransTable (j)
                k = TransTable (k)
                l = TransTable (l)
            endif

            ! As we're not looping over i,j,k,l it's safe to return the k-pnt
            ! related labels in the same variables
            call KPntSymInt (i, j, k, l, i, j, k, l)
            if (tTransFIndx) then
                i = TransTable (i)
                j = TransTable (j)
                k = TransTable (k)
                l = TransTable (l)
            endif
        endif

        ! This will rearrange i,j,k,l into the correct order (i,k) <= (j,l) 
        ! and i <= k, j <= l.
        if (GetCachedUmatEl (i, j, k, l, hel, iCache, iCacheI, a, b, &
            iType)) then
            ! We don't have a stored UMAt - we call to generate it
            if (tDFInts .or. tRIIntegrals) then
                ! We're using density fitting
                call GetDF2EInt (i, j, k, l, UElems)
                hel = UElems (0)
            else if (tCacheFCIDumpInts) then
                hel = 0
            else if (tVASP) then
                if (tTransFIndx) then
                    call construct_ijab_one (TransTable(i), TransTable(j), &
                                             TransTable(k), TransTable(l), &
                                             vasp_int(1,0))
                    call construct_ijab_one (TransTable(i), TransTable(l), &
                                             TransTable(k), TransTable(j), &
                                             vasp_int(1,1))
                else
                    call construct_ijab_one (i, j, k, l, vasp_int(1,0))
                    call construct_ijab_one (i, l, k, j, vasp_int(1,1))
                end if
                UElems(0) = vasp_int(1,0)
                UElems(1) = vasp_int(1,1)
                ! TODO: This bit seems broken. Why hel = ? twice
                !       Why not iand(iType, 0)
                hel = UElems(0)
                ! Bit 0 tells us which integral in the slot we need
                hel = UElems(iand(iType, 1))
                ! Bit 1 tells us whether we need to complex conj the integral
#ifdef __CMPLX
                if (btest(iType, 1)) hel = conjg(hel)
#endif
            else
                ! We call CPMD.
                ! Only need <ij|kl> if we're doing a 2-vertex calculation
                ! unless the intgral is for a single excitation, in which
                ! case we need <il|jk> as well.
                calc2ints = gen2CPMDInts .or. ( (idi == idj) .or. &
                            (idi == idk) .or. (idi == idl) .or. &
                            (idj == idk) .or. (idj == idl) )
                if (tTransFIndx) then
                    call InitFindXI (TransTable(i), TransTable(j), &
                                     TransTable(k), TransTable(l), &
                                     UElems, calc2ints)
                else
                    ! InitFindxI returns up to two integrals in UElems.
                    ! <id|u|kl> and <kj|u|il> (which are distinct when cplx
                    !                          orbitals are used)
                    call InitFindXI (i, j, k, l, UElems, calc2ints)
                endif

                ! TODO: Once again, should this not be iand(itype, 0)?
                ! Bit 0 tells us which integral in the slot we need
                hel = UElems (iand(iType, 1))
                ! Bit 1 tells us whether we need to complex conj the integral
#ifdef __CMPLX
                if (btest(iType, 1)) hel = conjg(hel)
#endif
            endif

            ! Because we've asked for the integral in the form to be stored,
            ! we shore as iType = 0.
            if ( (iCache /= 0) .and. (.not. tCacheFCIDUMPInts)) &
                call CacheUMatEl (a, b, UElems, iCache, iCacheI, 0)
            nMisses = nMisses + 1
        else
            nHits = nHits + 1
        endif
        
    end function

    function get_umat_el_fixlz_storespinorbs (i, j, k, l, fn2) result(hel)

        ! Consider the case where we are fixing Lz symmetry, and are storing
        ! spin orbitals
        
        interface
            function fn2 (i, j, k, l) result (hel)
                use constants, only: dp
                implicit none
                integer, intent(in) :: i, j, k, l
                HElement_t :: hel
            end function
        end interface

        integer, intent(in) :: i, j, k, l
        HElement_t :: hel

        ! If we are fixing Lz, then <ij|kl> != <kj|il> necessarily, since we
        ! have complex orbitals (though real integrals) and want to ensure
        ! that we conserve momentum. i.e. momentum of bra = mom of ket.
        if ( (G1(i)%Ml + G1(j)%Ml) /= (G1(k)%Ml + G1(l)%Ml) ) then
            hel = 0
        else
            hel = fn2 (i, j, k, l)
        endif

    end function

    function get_umat_el_fixlz_notspinorbs (i, j, k, l, fn2) result(hel)

        ! Consider the case where we are fixing Lz symmetry, and are not
        ! storing spin orbitals
        
        interface
            function fn2 (i, j, k, l) result (hel)
                use constants, only: dp
                implicit none
                integer, intent(in) :: i, j, k, l
                HElement_t :: hel
            end function
        end interface

        integer, intent(in) :: i, j, k, l
        HElement_t :: hel

        ! If we are fixing Lz, then <ij|kl> != <kj|il> necessarily, since we
        ! have complex orbitals (though real integrals) and want to ensure
        ! that we conserve momentum. i.e. momentum of bra = mom of ket.
        if ( (G1(2*i)%Ml + G1(2*j)%Ml) /= (G1(2*k)%Ml + G1(2*l)%Ml) ) then
            hel = 0
        else
            hel = fn2 (i, j, k, l)
        endif

    end function

    function get_umat_el_normal (idi, idj, idk, idl) result(hel)
        
        ! The normal, cached case for getumatel

        integer, intent(in) :: idi, idj, idk, idl
        HElement_t :: hel

        hel = UMAT (UMatInd(idi, idj, idk, idl, 0, 0))
    end function

    function get_umat_el_starstore (idi, idj, idk, idl) result(hel)

        ! The case when tStarStore and tUMat2D are set

        integer, intent(in) :: idi, idj, idk, idl
        integer :: i, j
        HElement_t :: hel

        if ( (idi == idj) .and. (idi == idk) .and. (idi == idl) ) then
            hel = umat2d (idi, idi)
        else if ( (idi == idk) .and. (idj == idl) ) then
            i = min (idi, idj)
            j = max (idi, idj)
            hel = umat2d (i, j)
        else if ( (idi == idl) .and. (idj == idk) ) then
            i = max (idi, idj)
            j = min (idi, idj)
            hel = umat2d (i, j)
        else if ( (idi == idj) .and. (idk == idl) ) then
            i = max (idi, idk)
            j = min (idi, idk)
            hel = umat2d (i, j)
        else
            i = UMatInd (idi, idj, idk, idl, nBasis/2, 0)
            if (i == -1) then
                hel = get_nan ()
            else
                hel = UMAT (i)
            endif
        endif
    end function


    FUNCTION GetUMatEl(NBASISMAX,UMATstore,ALAT,NHG,ISS,G1,IDI,IDJ,IDK,IDL)
        use systemdata, only: basisfn
      ! Get a U matrix element <ij|u|kl> in multifarious ways, where orbitals
      ! are spatial orbitals.  Either from a passed-in UMAT, or ALAT parameters
      ! (Hubbard, UEG, particle in a box), or from UMatcache (CPMD, DF).
      ! In:
      !    nBasisMax: legacy.  Contains some information that Alex is not clear on (rant at will).
      !    UMatstore: Store of <ij|u|kl> integrals.
      !    ALAT: Size of cell/box for Hubbard/UEG/particle in a box.
      !    iSS: as above in GetUMatSize.
      !    NHG: # basis functions.`
      !    G1: symmetry and momentum information on the basis functions.
      !    IDI,IDJ,IDK,IDL: indices for integral.

      ! This function only exists for backward compatibility, and acts as
      ! another layer of wrapper
      ! --> For Speed call the get_umat_el function directly.

      HElement_t GetUMatEl
      INTEGER nBasisMax(5,*),NHG,ISS
      TYPE(BasisFN) G1(NHG)
      REAL*8 ALAT(3)
      HElement_t UMATstore(*)
      INTEGER IDI,IDJ,IDK,IDL

      getumatel = get_umat_el (ptr_getumatel, idi, idj, idk, idl)
    END FUNCTION GetUMatEl



    SUBROUTINE WRITESYMCLASSES(NBASIS)
      use constants, only: dp
      use SystemData, only: BasisFN,BasisFNSize,BasisFNSizeB
      use SystemData, only: Symmetry,SymmetrySize,SymmetrySizeB
      USE UMatCache
      use SymData, only: SymClasses,SymLabelCounts,nSymLabels
      IMPLICIT NONE
      INTEGER I,NBASIS
      
      DO I=1,NBASIS/2
          WRITE(13,*) I,SYMCLASSES(I)
          CALL FLUSH(13)
      ENDDO
      DO I=1,NSYMLABELS
          WRITE(13,*) I,SYMLABELCOUNTS(2,I)
      ENDDO
      WRITE(13,*) "******************"
      CALL FLUSH(13)
    END subroutine writesymclasses

END MODULE Integrals



! Calculate the diagonal matrix elements for the Uniform electron gas
!  CST is PI*PI/2L*L for the non-periodic case, and
!  CST is 4*PI*PI/2L*L for the periodic case, and

!  For the periodic case we must also add in a periodic images correction
!  which is 1/2 (<ii|ii> - <ii|ii>cell) for each orbital
!  We calculate <ii|ii>cell with a potenial v(r)=1/r (r<Rc) and 0 (r>=Rc)
!  Rc=ALAT(4).

! Evaluation a diagonal matrix element via Slater--Condon rules gives:
! < D | H | D > = \sum_i < i | T | i > + 1/2 \sum_ij < ij || ij >
!               = \sum_i [< i | T | i > + < ii || ii >] + \sum_i>j < ij || ij >
! < ii || ii > normally cancel out.  However, in the UEG the Coulomb integral
! < ii | ii  > is infinite but the sum cancels out exactly with the interactions
! with the background (cf Ewald summations).
! The exchange interaction contains an integrable divergence which converges
! slowly with system size.  Speed of convergence can be increased by using
! either an attenuated (better) or screened (use attentuated) potential to
! evaluate the exchange integrals.  This leads to:
! < ii || ii > = < ii | ii > - < ii | ii >_cell
!              = -2*pi*R_c/2
! It is easiest to include this periodic image correction with the kinetic
! (one-electron) terms.

SUBROUTINE CALCTMATUEG(NBASIS,ALAT,G1,CST,TPERIODIC,OMEGA)
  use constants, only: dp
  use SystemData, only: BasisFN, k_offset, iPeriodicDampingType
  USE OneEInts, only : SetupTMAT,TMAT2D,TSTARSTORE
  IMPLICIT NONE
  INTEGER NBASIS
  TYPE(BASISFN) G1(NBASIS)
  REAL*8 ALAT(4),HFBASIS(NBASIS,NBASIS),CST,K_REAL(3)
  INTEGER I,J
  INTEGER iSIZE
  REAL*8 tot,S1,OMEGA
  LOGICAL TPERIODIC
  REAL*8, PARAMETER :: PI=3.1415926535897932384626433832795029D0
  IF(TPERIODIC) WRITE(6,*) "Periodic UEG"
  OPEN(10,FILE='TMAT',STATUS='UNKNOWN')
  IF(TSTARSTORE) STOP 'Cannot use TSTARSTORE with UEG'
  CALL SetupTMAT(NBASIS,2,iSIZE)
  DO I=1,NBASIS
    K_REAL=G1(I)%K+K_OFFSET
    TMAT2D(I,I)=((ALAT(1)**2)*((K_REAL(1)**2)/(ALAT(1)**2)+        &
&        (K_REAL(2)**2)/(ALAT(2)**2)+(K_REAL(3)**2)/(ALAT(3)**2)))
    TMAT2D(I,I)=TMAT2D(I,I)*(CST)
!..  The G=0 component is explicitly calculated for the cell interactions as 2 PI Rc**2 .
!   we *1/2 as we attribute only half the interaction to this cell.
    IF(TPERIODIC .and. iPeriodicDampingType/=0) TMAT2D(I,I)=TMAT2D(I,I)-(PI*ALAT(4)**2/OMEGA)
    WRITE(10,*) I,I,TMAT2D(I,I)
  ENDDO
  CLOSE(10)
  RETURN
END SUBROUTINE CALCTMATUEG

! See Integrals.F90 for an interface for this function.
function get_umat_el (fn, i, j, k, l) result(hel)
    use, intrinsic :: iso_c_binding
    use constants, only: dp
    use IntegralsData, only: ptr_getumatel_2
    implicit none

    interface
        function fn (i, j, k, l, fn2) result(hel)
            use constants, only: dp
            use, intrinsic :: iso_c_binding
            implicit none
            integer, intent(in) :: i, j, k, l
            type(c_ptr), intent(in), value :: fn2
            HElement_t :: hel
        end function
    end interface

    integer, intent(in) :: i, j, k, l
    HElement_t :: hel

    hel = fn (i, j, k, l, ptr_getumatel_2)
end function
