#############################################
############## Sort scalars #################
#############################################
[int]
type1 = integer(kind=int32)
extra_arrs = 
op_gt = >
op_lt = <
type2 = !
type3 = !
type4 = !
type5 = !
type6 = !
arr2_prefix = !
arr3_prefix = !
arr4_prefix = !
arr5_prefix = !
arr6_prefix = !
tmp_init1 = !
tmp_destroy1 = !
tmp_init2 = !
tmp_destroy2 = !
tmp_init3 = !
tmp_destroy3 = !
tmp_init4 = !
tmp_destroy4 = !
tmp_init5 = !
tmp_destroy5 = !
tmp_init6 = !
tmp_destroy6 = !

[int64]
type1 = integer(kind=int64)

[doub]
type1 = real*8

[sym]
type1 = type(Symmetry)

[sympairprod]
type1 = type(SymPairProd)

[starwalker]
type1 = type(star_walker)

[cmplx]
type1 = complex(dp)

##############################################
############### Sort arrays ##################
##############################################
[arr_int]
type1 = integer(kind=int32), dimension(:)
op_gt = .arrgt.
op_lt = .arrlt.

[arr_int64]
type1 = integer(kind=int64), dimension(:)

[arr_doub]
type1 = real*8, dimension(:)

##############################################
############ Sort by scalars #################
##############################################
[int_int]
type1 = integer(kind=int32)
type2 = integer(kind=int32)
arr2_prefix = 
extra_arrs = arr2,
op_gt = >
op_lt = <

[int_doub]
type2 = real*8

[int_arr_int]
type2 = integer(kind=int32), dimension(:)

[int_arr_int64]
type2 = integer(kind=int64), dimension(:)

[int_arr_doub]
type2 = real*8, dimension(:)

[int_arr_complex]
type2 = complex*16, dimension(:)

[doub_int]
type1 = real*8
type2 = integer(kind=int32)

[doub_doub]
type2 = real*8

[doub_arr_int]
type2 = integer(kind=int32), dimension(:)

[doub_arr_int64]
type2 = integer(kind=int64), dimension(:)

[doub_arr_doub]
type2 = real*8, dimension(:)

[sym_arr_int]
type1 = type(Symmetry)
type2 = integer(kind=int32), dimension(:)

###############################################
########## Sort by integer array ##############
###############################################
[arr_int_arr_int]
type1 = integer(kind=int32), dimension(:)
type2 = integer(kind=int32), dimension(:)
op_gt = .arrgt.
op_lt = .arrlt.

[arr_int_arr_doub]
type2 = real*8, dimension(:)

[arr_int_int]
type2 = integer(kind=int32)

[arr_int_doub]
type2 = real*8

###############################################
############# 64-bit integers #################
###############################################
[arr_int64_arr_int64]
type1 = integer(kind=int64), dimension(:)
type2 = integer(kind=int64), dimension(:)
op_gt = .arrgt.
op_lt = .arrlt.

[arr_int64_arr_doub]
type2 = real*8, dimension(:)

[arr_int64_int]
type2 = integer(kind=int32)

[arr_int64_inti64]
type2 = integer(kind=int64)

[arr_int64_doub]
type2 = real*8


#################################################
############# Sort by double array ##############
#################################################
[arr_doub_doub]
type1 = real*8, dimension(:)

[arr_doub_int]
type2 = integer(kind=int32)

[arr_doub_arr_doub]
type2 = real*8, dimension(:)

[arr_doub_arr_int]
type2 = integer(kind=int32), dimension(:)

################################################
############ More specific sorts ###############
################################################
[arr_int_int_doub]
type1 = integer(kind=int32), dimension(:)
type2 = integer(kind=int32)
type3 = real(kind=dp)
arr3_prefix = 
extra_arrs = arr2, arr3,

[arr_int64_int_doub]
type1 = integer(kind=int64), dimension(:)

[int_arr_int64_logical]
type1 = integer(kind=int32)
type2 = integer(kind=int64), dimension(:)
type3 = logical
op_gt = >
op_lt = <

[int_arr_int_doub]
type2 = integer(kind=int32), dimension(:)
type3 = real(kind=dp)

[int_arr_int64_doub]
type2 = integer(kind=int64), dimension(:)

[doub_doub_doub]
type1 = real(kind=dp)
type2 = real(kind=dp)
type3 = real(kind=dp)

[doub_arr_doub_int]
type2 = real(kind=dp), dimension(:)
type3 = integer(kind=int32)

[cmplx_cmplx_cmplx]
type1 = complex(dp)
type2 = complex(dp)
type3 = complex(dp)

[int_int_int64_int]
type1 = integer(kind=int32)
type2 = integer(kind=int32)
type3 = integer(kind=int64)
type4 = integer(kind=int32)
arr4_prefix = 
extra_arrs = arr2, arr3, arr4,

[doub_doub_doub_int]
type1 = real(kind=dp)
type2 = real(kind=dp)
type3 = real(kind=dp)
type4 = integer(kind=int32)

[int64_int_int_int]
type1 = integer(kind=int64)
type2 = integer(kind=int32)
type3 = integer(kind=int32)
type4 = integer(kind=int32)

[int64_int64_int_int_int]
type1 = integer(kind=int64)
type2 = integer(kind=int64)
type3 = integer(kind=int32)
type4 = integer(kind=int32)
type5 = integer(kind=int32)
arr5_prefix = 
extra_arrs = arr2, arr3, arr4, arr5,

##################################################
############### For FciMC.F90 ####################
##################################################
[arr_int_arr_doub_int_logical]
type5 = !
arr5_prefix = !
extra_arrs = arr2, arr3, arr4, 
op_gt = .arrgt.
op_lt = .arrlt.
type1 = integer(kind=int32), dimension(:)
type2 = real(kind=dp), dimension(:)
type3 = integer(kind=int32)
type4 = logical

[aint_adoub_int_log_egen]
type5 = type(excitGenerator)
arr5_prefix =
extra_arrs = arr2, arr3, arr4, arr5,
tmp_init5 = call excitgenerator_init
tmp_destroy5 = call excitgenerator_destroy

[arr_int_arr_doub_int_logical_doub]
type5 = real(kind=dp)
tmp_init5 = !
tmp_destroy5 = !

[aint_adoub_int_log_egen_doub]
type6 = type(excitGenerator)
arr6_prefix =
extra_arrs = arr2, arr3, arr4, arr5, arr6,
tmp_init6 = call excitgenerator_init
tmp_destroy6 = call excitgenerator_destroy


===================

#define srt_ind(i) (((i)*nskip_)+1)

module sort_mod
    use util_mod, only: operator(.arrlt.), operator(.arrgt.)
    use constants
    use SystemData, only: Symmetry, operator(.eq.), operator(.ne.), &
                          operator(.gt.), operator(.lt.), assignment(=)
    use symdata, only: SymPairProd, operator(.eq.), operator(.ne.), &
                       operator(.gt.), operator(.lt.), assignment(=)
    use FciMCData, only: ExcitGenerator, assignment(=), excitgenerator_init, &
                         excitgenerator_destroy
    use StarDiagData
    implicit none
    
    private
    public :: sort

    ! Private operator for sorting complex numbers by their real values
    interface operator(.gt.)
        module procedure cmplx_gt_%(name)s
    end interface
    interface operator(.lt.)
        module procedure cmplx_lt_%(name)s
    end interface

contains
    subroutine sort (arr, %(extra_arrs)snskip)

        ! Perform a quicksort on an array of integers, arr(n). Uses the 
        ! sample code in NumericalRecipies as a base.
        ! Optionally sort arr2 in parallel (in the routines it is enabled)

        ! sort needs auxiliary storage of length 2*log_2(n).
        integer, parameter :: nStackMax = 50
        integer, parameter :: nInsertionSort = 7
        integer, intent(in), optional :: nskip

        %(type1)s, intent(inout) :: arr(:)
        %(type2)s, intent(inout) :: arr2(:)
        %(type3)s, intent(inout) :: arr3(:)
        %(type4)s, intent(inout) :: arr4(:)
        %(type5)s, intent(inout) :: arr5(:)
        %(type6)s, intent(inout) :: arr6(:)

        ! Oh, how lovely it would be to be able to use push/pop and not need
        ! to guess a size of the stack to start with
        integer :: stack(nStackMax), nstack, nskip_
        integer :: pivot, lo, hi, n, i, j
        ! n.b. This size statement is removed if type1 is scalar ...
        %(type1)s :: a(size(arr(1)))
        %(type2)s :: a2(size(arr2(1)))
        %(type3)s :: a3(size(arr3(1)))
        %(type4)s :: a4(size(arr4(1)))
        %(type5)s :: a5(size(arr5(1)))
        %(type6)s :: a6(size(arr6(1)))

        ! Temporary variables for swapping
        %(type1)s :: tmp1(size(arr(1)))
        %(type2)s :: tmp2(size(arr2(1)))
        %(type3)s :: tmp3(size(arr3(1)))
        %(type4)s :: tmp4(size(arr4(1)))
        %(type5)s :: tmp5(size(arr5(1)))
        %(type6)s :: tmp6(size(arr6(1)))
        character(*), parameter :: this_routine = 'sort'

        ! Initialise temporary variables if required
        %(tmp_init1)s(a)
        %(tmp_init1)s(tmp1)
        %(tmp_init2)s(a2)
        %(tmp_init2)s(tmp2)
        %(tmp_init3)s(a3)
        %(tmp_init3)s(tmp3)
        %(tmp_init4)s(a4)
        %(tmp_init4)s(tmp4)
        %(tmp_init5)s(a5)
        %(tmp_init5)s(tmp5)
        %(tmp_init6)s(a6)
        %(tmp_init6)s(tmp6)

        if (present(nskip)) then
            nskip_ = nskip
        else
            nskip_ = 1
        endif

        ! The size of the array to sort. 
        ! N.B. Use zero based indices. To obtain ! the entry into the actual 
        ! array, multiply indices by nskip and add ! 1 (hence zero based)
        ! **** See local macro srt_ind() ******
        lo = lbound(arr, %(dim-arr)s) - 1
        n = ((ubound(arr, %(dim-arr)s) - lo -1)/nskip_) + 1
        hi = lo + n - 1

        nstack = 0
        do while (.true.)
            ! If the section/partition we are looking at is smaller than
            ! nInsertSort then perform an insertion sort 
            if (hi - lo < nInsertionSort) then
                do j = lo + 1, hi
                    a = arr(srt_ind(j))
                    %(arr2_prefix)s a2 = arr2(srt_ind(j))
                    %(arr3_prefix)s a3 = arr3(srt_ind(j))
                    %(arr4_prefix)s a4 = arr4(srt_ind(j))
                    %(arr5_prefix)s a5 = arr5(srt_ind(j))
                    %(arr6_prefix)s a6 = arr6(srt_ind(j))
                    do i = j - 1, 0, -1
                        if (arr(srt_ind(i)) %(op_lt)s a) exit
                        arr(srt_ind(i+1)) = arr(srt_ind(i))
                        %(arr2_prefix)s arr2(srt_ind(i+1)) = arr2(srt_ind(i))
                        %(arr3_prefix)s arr3(srt_ind(i+1)) = arr3(srt_ind(i))
                        %(arr4_prefix)s arr4(srt_ind(i+1)) = arr4(srt_ind(i))
                        %(arr5_prefix)s arr5(srt_ind(i+1)) = arr5(srt_ind(i))
                        %(arr6_prefix)s arr6(srt_ind(i+1)) = arr6(srt_ind(i))
                    enddo
                    arr(srt_ind(i+1)) = a
                    %(arr2_prefix)s arr2(srt_ind(i+1)) = a2
                    %(arr3_prefix)s arr3(srt_ind(i+1)) = a3
                    %(arr4_prefix)s arr4(srt_ind(i+1)) = a4
                    %(arr5_prefix)s arr5(srt_ind(i+1)) = a5
                    %(arr6_prefix)s arr6(srt_ind(i+1)) = a6
                enddo

                if (nstack == 0) exit
                hi = stack(nstack)
                lo = stack(nstack-1)
                nstack = nstack - 2

            ! Otherwise start partitioning with quicksort. 
            else
                ! Pick a partitioning element, and arrange such that
                ! arr(lo) <= arr(lo+1) <= arr(hi) 
                pivot = (lo + hi) / 2
                tmp1 = arr(srt_ind(pivot))
                arr(srt_ind(pivot)) = arr(srt_ind(lo + 1))
                arr(srt_ind(lo + 1)) = tmp1
                %(arr2_prefix)s tmp2 = arr2(srt_ind(pivot))
                %(arr2_prefix)s arr2(srt_ind(pivot)) = arr2(srt_ind(lo+1))
                %(arr2_prefix)s arr2(srt_ind(lo+1)) = tmp2
                %(arr3_prefix)s tmp3 = arr3(srt_ind(pivot))
                %(arr3_prefix)s arr3(srt_ind(pivot)) = arr3(srt_ind(lo+1))
                %(arr3_prefix)s arr3(srt_ind(lo+1)) = tmp3
                %(arr4_prefix)s tmp4 = arr4(srt_ind(pivot))
                %(arr4_prefix)s arr4(srt_ind(pivot)) = arr4(srt_ind(lo+1))
                %(arr4_prefix)s arr4(srt_ind(lo+1)) = tmp4
                %(arr5_prefix)s tmp5 = arr5(srt_ind(pivot))
                %(arr5_prefix)s arr5(srt_ind(pivot)) = arr5(srt_ind(lo+1))
                %(arr5_prefix)s arr5(srt_ind(lo+1)) = tmp5
                %(arr6_prefix)s tmp6 = arr6(srt_ind(pivot))
                %(arr6_prefix)s arr6(srt_ind(pivot)) = arr6(srt_ind(lo+1))
                %(arr6_prefix)s arr6(srt_ind(lo+1)) = tmp6

                if (arr(srt_ind(lo)) %(op_gt)s arr(srt_ind(hi))) then
                    tmp1 = arr(srt_ind(lo))
                    arr(srt_ind(lo)) = arr(srt_ind(hi))
                    arr(srt_ind(hi)) = tmp1
                    %(arr2_prefix)s tmp2 = arr2(srt_ind(lo))
                    %(arr2_prefix)s arr2(srt_ind(lo)) = arr2(srt_ind(hi))
                    %(arr2_prefix)s arr2(srt_ind(hi)) = tmp2
                    %(arr3_prefix)s tmp3 = arr3(srt_ind(lo))
                    %(arr3_prefix)s arr3(srt_ind(lo)) = arr3(srt_ind(hi))
                    %(arr3_prefix)s arr3(srt_ind(hi)) = tmp3
                    %(arr4_prefix)s tmp4 = arr4(srt_ind(lo))
                    %(arr4_prefix)s arr4(srt_ind(lo)) = arr4(srt_ind(hi))
                    %(arr4_prefix)s arr4(srt_ind(hi)) = tmp4
                    %(arr5_prefix)s tmp5 = arr5(srt_ind(lo))
                    %(arr5_prefix)s arr5(srt_ind(lo)) = arr5(srt_ind(hi))
                    %(arr5_prefix)s arr5(srt_ind(hi)) = tmp5
                    %(arr6_prefix)s tmp6 = arr6(srt_ind(lo))
                    %(arr6_prefix)s arr6(srt_ind(lo)) = arr6(srt_ind(hi))
                    %(arr6_prefix)s arr6(srt_ind(hi)) = tmp6
                endif
                if (arr(srt_ind(lo+1)) %(op_gt)s arr(srt_ind(hi))) then
                    tmp1 = arr(srt_ind(lo+1))
                    arr(srt_ind(lo+1)) = arr(srt_ind(hi))
                    arr(srt_ind(hi)) = tmp1
                    %(arr2_prefix)s tmp2 = arr2(srt_ind(lo+1))
                    %(arr2_prefix)s arr2(srt_ind(lo+1)) = arr2(srt_ind(hi))
                    %(arr2_prefix)s arr2(srt_ind(hi)) = tmp2
                    %(arr3_prefix)s tmp3 = arr3(srt_ind(lo+1))
                    %(arr3_prefix)s arr3(srt_ind(lo+1)) = arr3(srt_ind(hi))
                    %(arr3_prefix)s arr3(srt_ind(hi)) = tmp3
                    %(arr4_prefix)s tmp4 = arr4(srt_ind(lo+1))
                    %(arr4_prefix)s arr4(srt_ind(lo+1)) = arr4(srt_ind(hi))
                    %(arr4_prefix)s arr4(srt_ind(hi)) = tmp4
                    %(arr5_prefix)s tmp5 = arr5(srt_ind(lo+1))
                    %(arr5_prefix)s arr5(srt_ind(lo+1)) = arr5(srt_ind(hi))
                    %(arr5_prefix)s arr5(srt_ind(hi)) = tmp5
                    %(arr6_prefix)s tmp6 = arr6(srt_ind(lo+1))
                    %(arr6_prefix)s arr6(srt_ind(lo+1)) = arr6(srt_ind(hi))
                    %(arr6_prefix)s arr6(srt_ind(hi)) = tmp6
                endif
                if (arr(srt_ind(lo)) %(op_gt)s arr(srt_ind(lo+1))) then
                    tmp1 = arr(srt_ind(lo))
                    arr(srt_ind(lo)) = arr(srt_ind(lo+1))
                    arr(srt_ind(lo+1)) = tmp1
                    %(arr2_prefix)s tmp2 = arr2(srt_ind(lo))
                    %(arr2_prefix)s arr2(srt_ind(lo)) = arr2(srt_ind(lo+1))
                    %(arr2_prefix)s arr2(srt_ind(lo+1)) = tmp2
                    %(arr3_prefix)s tmp3 = arr3(srt_ind(lo))
                    %(arr3_prefix)s arr3(srt_ind(lo)) = arr3(srt_ind(lo+1))
                    %(arr3_prefix)s arr3(srt_ind(lo+1)) = tmp3
                    %(arr4_prefix)s tmp4 = arr4(srt_ind(lo))
                    %(arr4_prefix)s arr4(srt_ind(lo)) = arr4(srt_ind(lo+1))
                    %(arr4_prefix)s arr4(srt_ind(lo+1)) = tmp4
                    %(arr5_prefix)s tmp5 = arr5(srt_ind(lo))
                    %(arr5_prefix)s arr5(srt_ind(lo)) = arr5(srt_ind(lo+1))
                    %(arr5_prefix)s arr5(srt_ind(lo+1)) = tmp5
                    %(arr6_prefix)s tmp6 = arr6(srt_ind(lo))
                    %(arr6_prefix)s arr6(srt_ind(lo)) = arr6(srt_ind(lo+1))
                    %(arr6_prefix)s arr6(srt_ind(lo+1)) = tmp6
                endif

                i = lo + 1
                j = hi
                a = arr(srt_ind(lo + 1)) !! a is the pivot value
                %(arr2_prefix)s a2 = arr2(srt_ind(lo + 1))
                %(arr3_prefix)s a3 = arr3(srt_ind(lo + 1))
                %(arr4_prefix)s a4 = arr4(srt_ind(lo + 1))
                %(arr5_prefix)s a5 = arr5(srt_ind(lo + 1))
                %(arr6_prefix)s a6 = arr6(srt_ind(lo + 1))
                do while (.true.)
                    ! Scand down list to find element > a 
                    i = i + 1
                    do while (arr(srt_ind(i)) %(op_lt)s a)
                        i = i + 1
                    enddo

                    ! Scan down list to find element < a 
                    j = j - 1
                    do while (arr(srt_ind(j)) %(op_gt)s a)
                        j = j - 1
                    enddo

                    ! When the pointers crossed, partitioning is complete. 
                    if (j < i) exit

                    ! Swap the elements, so that all elements < a end up
                    ! in lower indexed variables. 
                    tmp1 = arr(srt_ind(i))
                    arr(srt_ind(i)) = arr(srt_ind(j))
                    arr(srt_ind(j)) = tmp1
                    %(arr2_prefix)s tmp2 = arr2(srt_ind(i))
                    %(arr2_prefix)s arr2(srt_ind(i)) = arr2(srt_ind(j))
                    %(arr2_prefix)s arr2(srt_ind(j)) = tmp2
                    %(arr3_prefix)s tmp3 = arr3(srt_ind(i))
                    %(arr3_prefix)s arr3(srt_ind(i)) = arr3(srt_ind(j))
                    %(arr3_prefix)s arr3(srt_ind(j)) = tmp3
                    %(arr4_prefix)s tmp4 = arr4(srt_ind(i))
                    %(arr4_prefix)s arr4(srt_ind(i)) = arr4(srt_ind(j))
                    %(arr4_prefix)s arr4(srt_ind(j)) = tmp4
                    %(arr5_prefix)s tmp5 = arr5(srt_ind(i))
                    %(arr5_prefix)s arr5(srt_ind(i)) = arr5(srt_ind(j))
                    %(arr5_prefix)s arr5(srt_ind(j)) = tmp5
                    %(arr6_prefix)s tmp6 = arr6(srt_ind(i))
                    %(arr6_prefix)s arr6(srt_ind(i)) = arr6(srt_ind(j))
                    %(arr6_prefix)s arr6(srt_ind(j)) = tmp6
                enddo;

                ! Insert partitioning element 
                arr(srt_ind(lo + 1)) = arr(srt_ind(j))
                arr(srt_ind(j)) = a
                %(arr2_prefix)s arr2(srt_ind(lo + 1)) = arr2(srt_ind(j))
                %(arr3_prefix)s arr3(srt_ind(lo + 1)) = arr3(srt_ind(j))
                %(arr4_prefix)s arr4(srt_ind(lo + 1)) = arr4(srt_ind(j))
                %(arr5_prefix)s arr5(srt_ind(lo + 1)) = arr5(srt_ind(j))
                %(arr6_prefix)s arr6(srt_ind(lo + 1)) = arr6(srt_ind(j))
                %(arr2_prefix)s arr2(srt_ind(j)) = a2
                %(arr3_prefix)s arr3(srt_ind(j)) = a3
                %(arr4_prefix)s arr4(srt_ind(j)) = a4
                %(arr5_prefix)s arr5(srt_ind(j)) = a5
                %(arr6_prefix)s arr6(srt_ind(j)) = a6

                ! Push the larger of the partitioned sections onto the stack
                ! of sections to look at later.
                ! --> need fewest stack elements. 
                nstack = nstack + 2
                if (nstack > nStackMax) then
                        write(6,*) nstack,nStackMax,n
                        call stop_all (this_routine, &
                                        "parameter nStackMax too small")
                endif
                if (hi - i + 1 >= j - lo) then
                    stack(nstack) = hi
                    stack(nstack-1) = i
                    hi = j - 1
                else
                    stack(nstack) = j - 1
                    stack(nstack-1) = lo
                    lo = i
                endif
            endif
        enddo

        ! Destroy temporary variables if required
        %(tmp_destroy1)s(a)
        %(tmp_destroy1)s(tmp1)
        %(tmp_destroy2)s(a2)
        %(tmp_destroy2)s(tmp2)
        %(tmp_destroy3)s(a3)
        %(tmp_destroy3)s(tmp3)
        %(tmp_destroy4)s(a4)
        %(tmp_destroy4)s(tmp4)
        %(tmp_destroy5)s(a5)
        %(tmp_destroy5)s(tmp5)
        %(tmp_destroy6)s(a6)
        %(tmp_destroy6)s(tmp6)

    end subroutine

    ! A private comparison. This should not be available outside of the
    ! module!
    elemental function cmplx_gt (a, b) result (bGt)
        complex(dp), intent(in) :: a, b
        logical :: bGt

        bGt = real(a, dp) > real(b, dp)
    end function

    elemental function cmplx_lt (a, b) result (bLt)
        complex(dp), intent(in) :: a, b
        logical :: bLt

        bLt = real(a, dp) < real(b, dp)
    end function
        
end module
