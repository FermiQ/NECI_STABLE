[int1]
type = integer
sizeof = sizeof_int
dim = :
elem1 = 1
alloc_str = dims(1)

[int2]
dim = :,:
elem1 = 1,1
alloc_str = dims(1), dims(2)

[int3]
dim = :,:,:
elem1 = 1,1,1
alloc_str = dims(1), dims(2), dims(3)

[int4]
dim = :,:,:,:
elem1 = 1,1,1,1
alloc_str = dims(1), dims(2), dims(3), dims(4)

[int5]
dim = :,:,:,:,:
elem1 = 1,1,1,1,1
alloc_str = dims(1), dims(2), dims(3), dims(4), dims(5)

[int6]
dim = :,:,:,:,:,:
elem1 = 1,1,1,1,1,1
alloc_str = dims(1), dims(2), dims(3), dims(4), dims(5), dims(6)

[int7]
dim = :,:,:,:,:,:,:
elem1 = 1,1,1,1,1,1,1
alloc_str = dims(1), dims(2), dims(3), dims(4), dims(5), dims(6), dims(7)

[doub1]
type = real*8
sizeof = sizeof_dp
dim = :
elem1 = 1
alloc_str = dims(1)

[doub2]
dim = :,:
elem1 = 1,1
alloc_str = dims(1), dims(2)

[doub3]
dim = :,:,:
elem1 = 1,1,1
alloc_str = dims(1), dims(2), dims(3)

[doub4]
dim = :,:,:,:
elem1 = 1,1,1,1
alloc_str = dims(1), dims(2), dims(3), dims(4)

[doub5]
dim = :,:,:,:,:
elem1 = 1,1,1,1,1
alloc_str = dims(1), dims(2), dims(3), dims(4), dims(5)

[doub6]
dim = :,:,:,:,:,:
elem1 = 1,1,1,1,1,1
alloc_str = dims(1), dims(2), dims(3), dims(4), dims(5), dims(6)

[doub7]
dim = :,:,:,:,:,:,:
elem1 = 1,1,1,1,1,1,1
alloc_str = dims(1), dims(2), dims(3), dims(4), dims(5), dims(6), dims(7)

[real1]
type = real*4
sizeof = sizeof_sp
dim = :
elem1 = 1
alloc_str = dims(1)

[real2]
dim = :,:
elem1 = 1,1
alloc_str = dims(1), dims(2)

[real3]
dim = :,:,:
elem1 = 1,1,1
alloc_str = dims(1), dims(2), dims(3)

[real4]
dim = :,:,:,:
elem1 = 1,1,1,1
alloc_str = dims(1), dims(2), dims(3), dims(4)

[real5]
dim = :,:,:,:,:
elem1 = 1,1,1,1,1
alloc_str = dims(1), dims(2), dims(3), dims(4), dims(5)

[real6]
dim = :,:,:,:,:,:
elem1 = 1,1,1,1,1,1
alloc_str = dims(1), dims(2), dims(3), dims(4), dims(5), dims(6)

[real7]
dim = :,:,:,:,:,:,:
elem1 = 1,1,1,1,1,1,1
alloc_str = dims(1), dims(2), dims(3), dims(4), dims(5), dims(6), dims(7)

[complex1]
type = complex*16
sizeof = sizeof_complexdp
dim = :
elem1 = 1
alloc_str = dims(1)

[complex2]
dim = :,:
elem1 = 1,1
alloc_str = dims(1), dims(2)

[complex3]
dim = :,:,:
elem1 = 1,1,1
alloc_str = dims(1), dims(2), dims(3)

[complex4]
dim = :,:,:,:
elem1 = 1,1,1,1
alloc_str = dims(1), dims(2), dims(3), dims(4)

[complex5]
dim = :,:,:,:,:
elem1 = 1,1,1,1,1
alloc_str = dims(1), dims(2), dims(3), dims(4), dims(5)

[complex6]
dim = :,:,:,:,:,:
elem1 = 1,1,1,1,1,1
alloc_str = dims(1), dims(2), dims(3), dims(4), dims(5), dims(6)

[complex7]
dim = :,:,:,:,:,:,:
elem1 = 1,1,1,1,1,1,1
alloc_str = dims(1), dims(2), dims(3), dims(4), dims(5), dims(6), dims(7)

=========================


module shared_alloc
    use, intrinsic :: iso_c_binding
    use constants
    use HElem
    implicit none

    private
    public :: shared_allocate, shared_deallocate

    interface
        subroutine alloc_shared_worker (nm, pt, sz) bind(c)
            use, intrinsic :: iso_c_binding
            implicit none
            character(c_char), intent(in) :: nm
            type(c_ptr), intent(inout) :: pt
            integer(c_size_t), value :: sz
        end subroutine
        subroutine dealloc_shared_worker (ptr) bind(c)
            use, intrinsic :: iso_c_binding
            use constants, only: int32, int64
            implicit none
#ifdef __PATHSCALE__
#ifdef POINTER8
            integer(int64), value :: ptr
#else
            integer(int32), value :: ptr
#endif
#else
            type(c_ptr), value :: ptr
#endif
        end subroutine
        subroutine iluts_pointer_jiggle_%(name)s (ptr, arr, dims)
            integer, intent(in) :: dims((len_trim('%(dim)s') + 1) / 2)
            %(type)s, dimension(%(dim)s), intent(inout), pointer :: ptr
            %(type)s, dimension(1:1+%(alloc_str)s), intent(inout), target :: arr
        end subroutine
    end interface

contains

    subroutine shared_allocate (nm, ptr, dims)

        character(*), intent(in) :: nm
        %(type)s, dimension(%(dim)s), intent(inout), pointer :: ptr
        integer, intent(in) :: dims((len_trim('%(dim)s') + 1) / 2)
        character(len=len_trim(nm)+1) :: name_tmp

#ifdef __SHARED_MEM
        integer :: sz
        type(c_ptr) :: tmp
#endif

        ! Prepare name of shared memory object to pass to C.
        name_tmp = trim(nm)//c_null_char

#ifdef __SHARED_MEM
        sz = %(sizeof)s * product(dims)

        ! Allocate the shared memory
        call alloc_shared_worker (name_tmp, tmp, &
                                  int(sz, kind=c_size_t))

        ! Assign to a fortran pointer.
        call c_f_pointer (tmp, ptr, dims)

        write (6, '("Allocated ", i10, " bytes of shared memory named: ", a)')&
               sz, nm
#else
        ! Sigh
        allocate(ptr(%(alloc_str)s))
#endif
    end subroutine


    subroutine shared_allocate_iluts (nm, ptr, dims)

        ! This is a horrible hack for Alex.
        ! The array will be allocated such that the first dimension goes is
        ! such that (0:dim1, dim2, dim3 ...)
        !
        ! i.e. use call shared_allocate_iluts (nm, ptr, (/NifTot, num/))

        character(*), intent(in) :: nm
        %(type)s, dimension(%(dim)s), intent(inout), pointer :: ptr
        %(type)s, dimension(%(dim)s), pointer :: ptr_tmp
        integer, intent(in) :: dims((len_trim('%(dim)s') + 1) / 2) ! compile time const.
        integer :: dims_tmp((len_trim('%(dim)s') + 1) / 2)
        character(len=len_trim(nm)+1) :: name_tmp

#ifdef __SHARED_MEM
        integer :: sz
        type(c_ptr) :: tmp
#endif

        ! Prepare name of shared memory object to pass to C.
        name_tmp = trim(nm)//c_null_char

#ifdef __SHARED_MEM
        dims_tmp = dims
        dims_tmp(1) = dims_tmp(1) + 1
        sz = %(sizeof)s * product(dims_tmp)

        ! Allocate the shared memory
        call alloc_shared_worker (name_tmp, tmp, &
                                  int(sz, kind=c_size_t))

        ! Assign to a fortran pointer.
        call c_f_pointer (tmp, ptr_tmp, dims_tmp)

        ! Jiggle the pointers, so that the first dimension of the first one
        ! goes from 0:dims(1), rather than 1:dims(1)+1
        call iluts_pointer_jiggle (ptr, ptr_tmp, dims)
        nullify(ptr_tmp)

        write (6, '("Allocated ", i10, " bytes of shared memory named: ", a)')&
               sz, nm
#else
        ! Sigh
        allocate(ptr(0:%(alloc_str)s))
#endif
    end subroutine





    subroutine shared_deallocate (ptr)
        %(type)s, dimension(%(dim)s), intent(inout), pointer :: ptr

#ifdef __SHARED_MEM

        %(type)s, pointer :: pt1

        ! Sigh, a hack to get pathscale to work
#ifdef __PATHSCALE__
#ifdef POINTER8
        integer(int64) :: tmp
#else
        integer(int32) :: tmp
#endif
#else
        type(c_ptr) :: tmp
#endif

        ! Get a pointer to the first element. c_loc requries its argument to
        ! be a scalar variable.
        pt1 => ptr(%(elem1)s)

#ifdef __PATHSCALE__
        tmp = loc(ptr(%(elem1)s))
#else
        tmp = c_loc(pt1)
#endif
        call dealloc_shared_worker (tmp)
#else
        deallocate(ptr)
#endif
        nullify(ptr)
    end subroutine
end module


! n.b. this is outside of the module and doesn't _quite_ match up with the
!      interface...
subroutine iluts_pointer_jiggle (ptr, arr, dims)
    integer, intent(in) :: dims((len_trim('%(dim)s') + 1) / 2)
    %(type)s, dimension(%(dim)s), intent(inout), pointer :: ptr
    %(type)s, dimension(0:%(alloc_str)s), intent(inout), target :: arr

    ptr => arr
end subroutine

supermodule shared_alloc
    interface
        subroutine cleanup_shared_alloc () bind(c)
        end subroutine
    end interface
end supermodule
