

!Diagonalize a compressed hamiltonian (in HAMIL), returning eigenvalues in W and eigenvectors in CK.
       SUBROUTINE HDIAG_neci(NDET,HAMIL,LAB,NROW,CK,W,WORK2,WORK,
     &                     NBLOCKSTARTS,NBLOCKS)
         use constants, only: dp,int32!,n_int
         use SystemData, only: BasisFN
         use global_utilities
         use HElem, only: HElement_t_size
!         use DetCalcData, only: NMRKS
!         use DetBitOps, only: count_open_orbs,EncodeBitDet,DetBitEQ
!         use DetBitOps, only: FindBitExcitLevel
!         use Bit_Reps
!         use HPHFRandExcitMod, only: FindExcitBitDetSym
         IMPLICIT NONE
!         INTEGER(n_int) :: BitRep(0:NIfTot),BitRepSym(0:NIfTot)
!         INTEGER(n_int) :: TempBitRep(0:NIfTot),BitRepHF(0:NIfTot)
         INTEGER NDET
         INTEGER NROW(NDET),LAB(*)
         HElement_t  HAMIL(*),CK(NDET,NDET),WORK2(4*NDET),WORK
!         HElement_t CopyCK(NDET,NDET)
         real(dp) W(NDET)
         INTEGER I,J,IND,INDZ,NBS!,nopen,k,Excit
         INTEGER(int32) INFO
         INTEGER NBLOCKS,NBLOCKSTARTS(NBLOCKS+1)
         type(timer), save :: proc_timer
         real(dp) GSEN
         proc_timer%timer_name='HDIAG     '
         call set_timer(proc_timer)
         GSEN=1.D100
         DO I=1,NDET
            DO J=1,NDET
               CK(I,J)=0.D0
            ENDDO
         ENDDO
C.. Now we fill the RIJ array
         IND=1
         INDZ=1
         DO I=1,NDET
            INDZ=INDZ+NROW(I)
            DO WHILE (IND.LT.INDZ)
               CK(I,LAB(IND))=HAMIL(IND)
               IND=IND+1
            ENDDO
         ENDDO
         IF(HElement_t_size.ne.1) THEN
             !ensure hermitian
             do i=1,ndet
                 do j=1,i-1
                     CK(i,j)=CONJG(CMPLX(CK(j,i)))
                 enddo
             enddo
         ENDIF

!****************************
!Needs to be uncommented for ExcitChangeTest to work
!         DO I=1,NDET
!             DO J=I,NDET
!                 CopyCK(I,J)=CK(I,J)
!                 CopyCK(J,I)=CK(I,J)
!             ENDDO
!         ENDDO
!         DO I=1,NDET
!             DO J=1,NDET
!                 WRITE(6,"(F20.14)",advance='no') CopyCK(I,J) 
!             ENDDO
!             WRITE(6,*) ""
!         ENDDO
!***************************

C.. Diagonalize
         DO I=1,NBLOCKS
            NBS=NBLOCKSTARTS(I)
            IF(HElement_t_size.EQ.1) THEN
               CALL DSYEV('V','U',NBLOCKSTARTS(I+1)-NBS,CK(NBS,NBS),
     &            NDET,W(NBS),WORK2,4*NDET,INFO)
            ELSE
                 CALL ZHEEV('V','U',NBLOCKSTARTS(I+1)-NBS,CK(NBS,NBS),
     &            NDET,W(NBS),WORK,4*NDET,WORK2,INFO)
            ENDIF
            IF(INFO.NE.0) THEN
               WRITE(6,*) 'DYSEV error: ',INFO
               STOP
            ENDIF
            IF(W(NBS).LT.GSEN) GSEN=W(NBS)
! This is commented out develomental code to label the determinants
! by their HPHF partner and number of open shells.
!
!            do j=1,ndet
!                call EncodeBitDet(NMRKS(:,j),BitRep) 
!                if(j.eq.1) then
!                    BitRepHF=BitRep
!                endif
!                nopen = count_open_orbs(BitRep)
!                Excit = FindBitExcitLevel(BitRepHF,BitRep,NEl)
!                call FindExcitBitDetSym(BitRep,BitRepSym)
!                do k=1,ndet
!                    call EncodeBitDet(NMRKS(:,k),TempBitRep)
!                    if(DetBitEQ(TempBitRep,BitRepSym,NIfDBO)) then
!!                        write(6,*) "Found same: ",j,k,BitRep(0:NIfDBO), &
!!     &                      TempBitRep(0:NIfDBO)
!                        exit
!                    endif
!                enddo
!                if(k.eq.ndet+1) stop 'Error in finding spin-coup dets'
!                write(69,"(I4,4G20.10,3I5)") j,CK(j,1:4),Excit,nopen,k
!            enddo
!
         ENDDO

!Developmental and research routine
!         CALL ExcitChangeTest(CK,W,CopyCK,NDET)

C.. CK now contains the eigenvectors, and W the eigenvalues
         WRITE(6,"(A,F19.11,I4)") "GROUND E=",GSEN
         call halt_timer(proc_timer)
         RETURN
      END

!This routine for each determinant, calculates each excitation, and then its contribution to the change in
!the coefficient of the desired eigenvector. The average for this is obviously zero.
!This is called from HDIAG, but will generally be commented out, since it is just for interest.
      SUBROUTINE ExcitChangeTest(Vecs,Vals,HMAT,NDET)
         use constants, only: dp
         IMPLICIT NONE
         INTEGER NDET,i,j,NExcit,bin,nbins
         HElement_t Vecs(NDET,NDET),HMAT(NDET,NDET),KMAT(NDET,NDET)
         real(dp) Vals(NDET),S(NDET,NDET+1),SSUM
         real(dp) MinS,MaxS,RangeBins
         INTEGER , ALLOCATABLE :: SHist(:,:)
         real(dp) , ALLOCATABLE :: RangeHist(:)

!Vals(1) contains ground state
!Check that eigenvectors are correct by multiplying matrix by first eigenvector
!         TrialEigenvec=0.d0
!         Norm=(0.D0)
!         do i=1,NDET
!             do j=1,NDET
!                 TrialEigenvec(i)=TrialEigenvec(i)+HMAT(i,j)*Vecs(j,1)
!             enddo
!             Norm=Norm+(Vecs(i,1)*Vecs(i,1))
!         enddo
!         WRITE(6,*) "Norm for first eigenvector is: ", Norm
!         do i=1,NDET
!             TrialEigenvec(i)=TrialEigenvec(i)/(Vals(1))
!             WRITE(6,*) Vals(i)
!             WRITE(6,*) TrialEigenvec(i),Vecs(i,1)
!         enddo

!Create the k matrix...
         KMAT=(0.d0)
         DO i=1,NDET
             KMAT(i,i)=Vals(1)
         ENDDO
         DO i=1,NDET
             DO j=1,NDET
                 KMAT(i,j)=KMAT(i,j)-HMAT(i,j)
             ENDDO
         ENDDO

!         DO I=1,NDET
!             DO J=1,NDET
!                 WRITE(6,"(F20.14)",advance='no') KMAT(I,J) 
!             ENDDO
!             WRITE(6,*) ""
!         ENDDO

!Diagonalise to test eigenvectors are the same
!         CALL DSYEV('V','U',NDET,KMAT,
!     &         NDET,KVals,Work,3*NDET,INFO)

!         DO i=1,NDET
!             WRITE(6,*) Vals(i),KVals(i),Vals(1)-Vals(i)
!         ENDDO

!We now want eigenvector corresponding to largest eigenvalue of KMAT or smallest of HMAT
!         DO i=1,NDET
!             WRITE(6,*) Vecs(i,1), KMAT(i,NDET)
!         ENDDO
         

!Run through determinants in graph
         NBins=100
         S=0.d0
         MinS=100.0
         MaxS=-100.0
         WRITE(11,*) "# Det   SijSum     MinS    MaxS"
         do i=1,NDET

!Count excitations attached to it...
             NExcit=0
             do j=1,NDET
!We only want excitations, so remove the diagonal contribution
                 IF(i.eq.j) CYCLE
                 IF(abs(KMAT(i,j)).gt.0.D0) NExcit=NExcit+1
             enddo

!             IF(NExcit.lt.1) STOP 'ERROR IN COUNTING EXCITS'

             do j=1,NDET
                 IF(i.eq.j) CYCLE
                 IF(abs(KMAT(i,j)).gt.0.D0) THEN
!For each excitation of each determinant i, find its contribution to the change of expansion coefficient
                     S(i,j)=((KMAT(i,i)/(NExcit+0.D0))*Vecs(i,1))+
     &                        ((KMAT(i,j))*Vecs(j,1))
                     IF(S(i,j).lt.MinS) MinS=S(i,j)
                     IF(S(i,j).gt.MaxS) MaxS=S(i,j)
                 ENDIF
             enddo

!Sum all the changes of the expansion coefficient for a given i due to the excitations j
             SSUM=0.D0
             do j=1,NDET
                 SSUM=SSUM+S(i,j)
             enddo
!Store this value in the final column of the S array
             WRITE(6,"(I4,3G25.16)") i,SSUM,MinS,MaxS
             WRITE(11,"(I4,3G25.16)") i,SSUM,MinS,MaxS
             S(i,NDET+1)=SSUM

         enddo

         RangeBins=(MaxS-MinS)/(NBins+0.D0)

         ALLOCATE(SHist(NDET,NBins))
         SHist(1:nDet,1:NBins)=0
         ALLOCATE(RangeHist(NBins+1))
         RangeHist=0.d0

         RangeHist(1)=MinS
         do i=2,NBins
             RangeHist(i)=RangeHist(i-1)+RangeBins
         enddo
!Make sure final bin catches them all
         RangeHist(NBins+1)=MaxS+10

         do i=1,NDET
!Run through determinants again, and determinant non-zero matrix elements

             do j=1,NDET
                 IF(i.eq.j) CYCLE
                 IF(abs(KMAT(i,j)).gt.0.D0) THEN
!j is excitation of i - find which bin the overlap goes into
                     Bin=1
                     do while(S(i,j).ge.RangeHist(Bin+1))
                         Bin=Bin+1
                     enddo
                     IF(Bin.gt.NBins) STOP 'Error in creating histogram'
                     SHist(i,Bin)=SHist(i,Bin)+1

                 ENDIF
             enddo

         enddo

         do i=1,NBins
            WRITE(9,"(G20.12)",advance='no') (MinS+((i-1.D0)*RangeBins))
     &                                    +(RangeBins/2.0)
            do j=1,NDET
                WRITE(9,"(I8)",advance='no') SHist(j,i)
            enddo
            WRITE(9,*) ""
        enddo

        DEALLOCATE(SHist)
        DEALLOCATE(RangeHist)

      END SUBROUTINE ExcitChangeTest

 
      SUBROUTINE HDIAG_NH(NDET,NBLOCKSTARTS,NBLOCKS,
     &            NEL,NMRKS,NBASISMAX,NBASIS,G1,BRR,
     &            BETA,I_P,IFDET,ARR,BLOCKSYM)
         use SystemData, only: BasisFN
         use global_utilities
         use Determinants, only: get_helement
         use sym_mod
         use constants, only: dp,int32
         use MemoryManager, only: TagIntType
         IMPLICIT NONE
         INTEGER NDET,NEL,NBLOCKS,NBLOCKSTARTS(NBLOCKS),NMRKS(NEL,NDET)
         INTEGER nBasisMax(5,*),NBASIS
         TYPE(BasisFN) G1(*)
         INTEGER I_P,BRR(*)
         INTEGER(int32) INFO
         real(dp)  BETA
         LOGICAL TWARN
         real(dp)  DNORM
         real(dp)  CALCDLWDB,ARR(NBASIS)
         
         INTEGER I,NBLKMAX,NBLK,J,K,NBS,III,IFDET,L
         real(dp) EXEN,GSEN,FLRI,FLSI,GSEN2
         real(dp), ALLOCATABLE :: CK(:),W(:),WORK(:)
         integer(TagIntType), save :: tagCK=0,tagW=0,tagWORK=0
         real(dp) ELOWEST,GOFE(NBASIS),EBIAS
         INTEGER GELOWEST,IDEG
         type(timer), save :: proc_timer
         TYPE(BasisFN) BLOCKSYM(NBLOCKS)
         HElement_t :: hel
         character(*),parameter :: this_routine='HDIAG_NH'
         proc_timer%timer_name=this_routine
         call set_timer(proc_timer)
C.. Find the largest block
         NBLKMAX=0
         DO I=1,NBLOCKS
            IF(NBLOCKSTARTS(I+1)-NBLOCKSTARTS(I).GT.NBLKMAX)
     &         NBLKMAX=NBLOCKSTARTS(I+1)-NBLOCKSTARTS(I)
         ENDDO
         WRITE(6,*) "Maximum Block Size:",NBLKMAX
C.. Now allocate memory
         allocate(CK(NBLKMAX*NBLKMAX))
         call LogMemAlloc('CK',NBLKMAX*NBLKMAX,8,this_routine,tagCK)
         allocate(W(NBLKMAX))
         call LogMemAlloc('W',NBLKMAX,8,this_routine,tagW)
         allocate(WORK(3*NBLKMAX))
         call LogMemAlloc('WORK',3*NBLKMAX,8,this_routine,tagWORK)
C.. Go through the blocks forming the hamil matrix
         EXEN=0.D0
         DNORM=0.D0
         EBIAS=0.D0
         DO J=1,NBASIS
            GOFE(J)=0.D0
         ENDDO
         OPEN(14,FILE='RHOPIIex',STATUS='UNKNOWN')
         OPEN(15,FILE='ENERGIES',STATUS='UNKNOWN')
         ELOWEST=1.D200
         GELOWEST=0
         DO I=0,NBLOCKS-1
            NBS=NBLOCKSTARTS(I+1)
            NBLK=NBLOCKSTARTS(I+2)-NBS
            DO J=0,NBLK-1
               DO K=J,NBLK-1
                  hel = get_helement (NMRKS(:,NBS+J), NMRKS(:,NBS+K))
                  CK(J*NBLK+K+1) = hel
               ENDDO
            ENDDO
C.. Diagonalize
            CALL DSYEV('V','L',NBLK,CK,NBLK,W,WORK,3*NBLKMAX,INFO)
            IF(INFO.NE.0) THEN
               WRITE(6,*) 'DYSEV error: ',INFO
               STOP
            ENDIF
C.. Now work out exact wi etc.
            CALL GETSYMDEGEN(BLOCKSYM(I+1),NBASISMAX,IDEG)
            DO III=1,NBLK
               WRITE(15,"(2I4,I7)",advance='no') I+1,III,NBS+III-1
!               CALL WRITEDET(15,NMRKS(1,NBS+III-1),NEL,.FALSE.)
               WRITE(15,"(F19.11,I5)") W(III),IDEG

               IF(ABS(W(III)/ELOWEST-1.D0).LT.1.D-6) THEN
                  GELOWEST=GELOWEST+IDEG
               ELSEIF(W(III).LT.ELOWEST) THEN
C.. if we're going to change ELOWEST, and there was a previous ELOWEST,
C.. we need to multiply DNORM and EXEN by exp(-BETA(ENEW-EOLD))
                     EXEN=EXEN*EXP(-BETA*(EBIAS-W(III)))
                     DNORM=DNORM*EXP(-BETA*(EBIAS-W(III)))
                  ELOWEST=W(III)
                  GELOWEST=IDEG
                  EBIAS=W(III)
               ENDIF
C
C               DO J=1,NBLK
C                  WRITE(15,*) CK((III-1)*NBLK+J)
C               ENDDO
               CALL CALCRHOPII(III,NBLK,NBLK,CK,W,BETA,I_P,
     &               FLRI,FLSI,TWARN)
               WRITE(14,"(I12,A)",advance='no') NBS+III-1,"("
               DO L=1,NEL
                  WRITE(14,"(I3,A)",advance='no')
     &                                           NMRKS(L,NBS+III-1),","
               ENDDO
               GSEN=CALCDLWDB(III,NBLK,NBLK,CK,W,BETA)
               WRITE(14,"(A,4G25.16,I5)") ") ",
     &            EXP(FLSI+I_P*FLRI),FLRI*I_P,FLSI,GSEN,IDEG
               EXEN=EXEN+(W(III)*IDEG)*EXP(-(W(III)-EBIAS)*BETA)
               DNORM=DNORM+IDEG*EXP(-(W(III)-EBIAS)*BETA)
C.. Find the lowest energy, and write out g(E)
C               IF(W(III).LT.ELOWEST) THEN
C                  ELOWEST=W(III)
                  DO J=1,NBLK
                     DO K=1,NEL
                        L=NMRKS(K,NBS+J-1)
                       GOFE(L)=GOFE(L)
     &                   +IDEG*(CK((III-1)*NBLK+J)**2)*EXP(-W(III)*BETA)
C                        IF(L.EQ.9.AND.
C     &                  ABS(CK((III-1)*NBLK+J)).GT.1.D-5) THEN
C         WRITE(6,*) NBS+III-1,J,CK((III-1)*NBLK+J),W(III),
C     &         (CK((III-1)*NBLK+J)**2)*EXP(-W(III)*BETA)
C                        ENDIF
                     ENDDO
                  ENDDO
C               ENDIF
            ENDDO
            IF(IFDET.GE.NBS.AND.IFDET.LT.NBLOCKSTARTS(I+2)) THEN
               GSEN2=CALCDLWDB(IFDET-NBS+1,NBLK,NBLK,CK,W,BETA)
            ENDIF
         ENDDO
         CLOSE(14)
         CLOSE(15)
C        WRITE(6,*) "NORM: ",DNORM
         WRITE(6,"(A,F19.11)") "EXACT E(BETA)=",EXEN/DNORM
         WRITE(6,"(A,F19.11)") "EXACT DLWDB(D0)=",GSEN2
         WRITE(6,"(A,F19.11,I4)") "GROUND E, g(E)=",ELOWEST,GELOWEST
         OPEN(16,FILE='GOFE',STATUS='UNKNOWN')
         DO J=1,NBASIS
            WRITE(16,"(6I4,2G25.16)") BRR(J),(G1(BRR(J))%k(K),K=1,5),
     &         ARR(J),GOFE(BRR(J))/DNORM
         ENDDO
         CLOSE(16)
         deallocate(WORK,CK,W)
         call LogMemDealloc(this_routine,tagWORK)
         call LogMemDealloc(this_routine,tagW)
         call LogMemDealloc(this_routine,tagCK)
         call halt_timer(proc_timer)
         RETURN
      END 
