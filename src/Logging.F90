#include "macros.h"

MODULE Logging
            
    use constants, only: dp,int64
    use input
    use MemoryManager, only: LogMemAlloc, LogMemDealloc,TagIntType
    use SystemData, only: nel, LMS, nbasis, tHistSpinDist, nI_spindist, &
                          hist_spin_dist_iter
    use constants, only: n_int, size_n_int, bits_n_int
    use bit_rep_data, only: NIfTot, NIfD
    use DetBitOps, only: EncodeBitDet
    use hist_data, only: iNoBins, tHistSpawn, BinRange

    IMPLICIT NONE
    Save

    INTEGER ILOGGING,ILOGGINGDef
    INTEGER :: iGlobalTimerLevel=40
    INTEGER nPrintTimer,G_VMC_LOGCOUNT
    INTEGER HFLOGLEVEL,iWritePopsEvery,StartPrintOrbOcc,StartPrintDoubsUEG
    INTEGER PreVarLogging,WavevectorPrint,NoHistBins,HistInitPopsIter
    real(dp) MaxHistE,OffDiagMax,OffDiagBinRange,PopsfileTimer
    LOGICAL TDistrib,TPopsFile,TCalcWavevector,TDetPops,tROFciDump,tROHistOffDiag,tROHistDoubExc,tROHistOnePartOrbEn
    LOGICAL tPrintPopsDefault
    LOGICAL TZeroProjE,TWriteDetE,TAutoCorr,tBinPops,tIncrementPops,tROHistogramAll,tROHistER,tROHistSingExc
    LOGICAL tRoHistOneElInts
    LOGICAL tROHistVirtCoulomb,tPrintInts,tHistEnergies,tTruncRODump,tRDMonFly,tDiagRDM,tDo_Not_Calc_RDMEnergy
    LOGICAL tPrintFCIMCPsi,tCalcFCIMCPsi,tPrintSpinCoupHEl,tIterStartBlock,tHFPopStartBlock,tInitShiftBlocking
    LOGICAL tTruncDumpbyVal, tChangeVarsRDM
    LOGICAL tWriteTransMat,tHistHamil,tPrintOrbOcc,tHistInitPops,tPrintOrbOccInit,tPrintDoubsUEG
    LOGICAL tHF_S_D_Ref, tHF_S_D, tHF_Ref, tHF_Ref_Explicit, tExplicitAllRDM, tRDMSpinAveraging
    INTEGER NoACDets(2:4),iPopsPartEvery,iWriteHistEvery,NHistEquilSteps,IterShiftBlock
    INTEGER IterRDMonFly, RDMExcitLevel, RDMEnergyIter
    INTEGER CCMCDebug  !CCMC Debugging Level 0-6.  Default 0
    INTEGER FCIMCDebug !FciMC Debugging Level 0-6.  Default 0

    LOGICAL tCCMCLogTransitions !Do we log transitions?  Only possible for very small systems
    LOGICAL tCCMCLogUniq !Do we log only unique clusters
    LOGICAL tSaveBlocking !Do not overwrite blocking files
    INTEGER iWriteBlockingEvery !How often to write out blocking files
    INTEGER IterStartBlocking,HFPopStartBlocking,NoDumpTruncs,iWriteHamilEvery
    INTEGER(TagIntType)  OrbOccsTag,HistInitPopsTag,AllHistInitPopsTag,NoTruncOrbsTag,TruncEvaluesTag
    INTEGER , ALLOCATABLE :: NoTruncOrbs(:),HistInitPops(:,:),AllHistInitPops(:,:)
    real(dp) , ALLOCATABLE :: TruncEvalues(:),OrbOccs(:),DoubsUEG(:,:,:,:),DoubsUEGLookup(:)
    LOGICAL, ALLOCATABLE :: DoubsUEGStore(:,:,:)
    LOGICAL :: tBlockEveryIteration
    LOGICAL tLogDets       ! Write out the DETS and SymDETS files.
    LOGICAL tLogComplexPops     ! Write out complex walker information 
    LOGICAL tMCOutput

    logical :: tCalcInstantS2, tCalcInstSCpts
    integer :: instant_s2_multiplier

    contains

    subroutine SetLogDefaults()
      != Set defaults for Logging data items.

      use default_sets
      implicit none

      PopsfileTimer=0.D0
      tMCOutput=.true.
      tLogComplexPops=.false.
      iWriteBlockingEvery=1000
      tSaveBlocking=.false.
      OffDiagBinRange=0.001
      OffDiagMax=1.D0
      BinRange=0.001
      iNoBins=100000
      tHistEnergies=.false.
      tHistHamil=.false.
      iWriteHamilEvery=-1
      tHistSpawn=.false.
      iWriteHistEvery=-1
      NoACDets(:)=0
      TAutoCorr=.false.
      MaxHistE=50.D0
      NoHistBins=200
      iWritePopsEvery=100000
      TCalcWavevector=.false.
      WavevectorPrint=100
      TPopsFile=.true.
      tIncrementPops = .false.
      tPrintPopsDefault=.true.
      TDistrib=.false.
      ILOGGINGDef=0
      iGlobalTimerLevel=40
      nPrintTimer=10
      HFLOGLEVEL=0
      PreVarLogging=0
      TDetPops=.false.
      TZeroProjE=.false.
      TWriteDetE=.false.
      iPopsPartEvery=1
      tBinPops=.false.
      tROHistogramAll=.false.
      tROFciDump=.true.
      tTruncRODump=.false.
      tTruncDumpbyVal=.false.
      tROHistER=.false.
      tROHistDoubExc=.false.
      tROHistOffDiag=.false.
      tROHistSingExc=.false.
      tROHistOnePartOrbEn=.false.
      tROHistOneElInts=.false.
      tPrintInts=.false.
      tPrintSpinCoupHEl=.false.
      tPrintFCIMCPsi=.false.
      tCalcFCIMCPsi=.false.
      NHistEquilSteps=0
      tPrintDoubsUEG=.false.
      StartPrintDoubsUEG=0
      tPrintOrbOcc=.false.
      StartPrintOrbOcc=0
      tPrintOrbOccInit=.false.
      CCMCDebug=0
      FCIMCDebug=0
      tHFPopStartBlock=.false.
      tIterStartBlock=.false.
      IterStartBlocking=0
      HFPopStartBlocking=100
      tInitShiftBlocking=.false.
      IterShiftBlock=0
      NoDumpTruncs=0
      tWriteTransMat=.false.
      tCCMCLogTransitions=.false.
      tCCMCLogUniq=.true.
      tHistInitPops=.false.
      tHistSpinDist = .false.
      HistInitPopsIter=100000
      hist_spin_dist_iter = 1000
      tLogDets=.false.
      tCalcInstantS2 = .false.
      tCalcInstSCpts = .false.
      instant_s2_multiplier = 1
      tRDMonFly=.false.
      tChangeVarsRDM = .false.
      RDMEnergyIter=100
      tDiagRDM=.false.
      IterRDMonFly=0
      RDMExcitLevel=1
      tDo_Not_Calc_RDMEnergy = .false.
      tExplicitAllRDM = .false.
      tHF_S_D_Ref = .false.
      tHF_S_D = .false.
      tHF_Ref = .false.
      tHF_Ref_Explicit = .false.
      tRDMSpinAveraging = .false.

! Feb08 defaults
      IF(Feb08) THEN
          !Mcpaths set
          ILOGGINGDef=2
      ENDIF

    end subroutine SetLogDefaults



    subroutine LogReadInput()

        ! Read the logging section from the input file

        logical eof
        integer :: i, ierr
        character(100) :: w
        character(*), parameter :: t_r = 'LogReadInput'

      ILogging=iLoggingDef

      logging: do
        call read_line(eof)
        if (eof) then
            exit
        end if
        call readu(w)
        select case(w)

        case("NOMCOUTPUT")
            !No output to stdout from the fcimc or ccmc iterations
            tMCOutput=.false.
        case("LOGCOMPLEXWALKERS")
            !This means that the complex walker populations are now logged.
            tLogComplexPops=.true.

        case("PRINTNEWBLOCKING")
!This is the iteration interval period to write out the blocking files.
            call readi(iWriteBlockingEvery)
        case("SAVEBLOCKING")
!In this case, blocking files are not overwritten each time they are printed out, but 
            tSaveBlocking=.true.
        case("ERRORBLOCKING")
!Performs blocking analysis on the errors in the instantaneous projected energy to get the error involved.
!This is default on, but can be turned off with this keyword followed by OFF.
            IF(item.lt.nitems) THEN
                call readu(w)
                select case(w)
                    case("OFF")
                        tHFPopStartBlock=.false.
                end select
            ELSE
                tHFPopStartBlock=.true.
            ENDIF

        case("SHIFTERRORBLOCKING")
!Performs blocking analysis on the errors in the instantaneous projected energy to get the error involved.
!This is default on, but can be turned off with this keyword followed by OFF.
            IF(item.lt.nitems) THEN
                call readu(w)
                select case(w)
                    case("OFF")
                        tInitShiftBlocking=.false.
                end select
            ELSE
                tInitShiftBlocking=.true.
            ENDIF

        case("BLOCKINGSTARTITER")
!This keyword can be used if we want to start the blocking error analysis at a particular iteration.            
!If it is a negative integer, then this means that the blocking will start when we come out of fixed shift mode.
            tIterStartBlock=.true.
            tHFPopStartBlock=.false.
            call readi(IterStartBlocking)

        case("SHIFTBLOCKINGSTARTITER")
!This keyword can be used if we want to start the blocking error analysis of the shift at a particular 
!iteration after the shift begins to change.            
            call readi(IterShiftBlock)

        case("BLOCKINGSTARTHFPOP")            
!This keyword can be used if we want to start the blocking error analysis at a particular HF population.
!The current default is 100.
            tHFPopStartBlock=.true.
            call readi(HFPopStartBlocking)
 
        case("ROFCIDUMP")
!Turning this option on prints out a new FCIDUMP file at the end of the orbital rotation.  At the moment, the rotation is very slow
!so this will prevent us having to do the transformation every time we run a calculation on a particular system
            IF(item.lt.nitems) THEN
                call readu(w)
                select case(w)
                    case("OFF")
                        tROFCIDUMP=.false.
                end select
            ELSE
                tROFCIDUMP=.true.
            ENDIF

        case("TRUNCROFCIDUMP")
!This options truncates the rotated FCIDUMP file by removing the specified number of virtual orbitals, based on the occupation
!numbers given by diagonalisation of the MP2 variational density matrix.
            tTruncRODump=.true.
            NoDumpTruncs=1
            ALLOCATE(NoTruncOrbs(NoDumpTruncs),stat=ierr)
            CALL LogMemAlloc('NoTruncOrbs',NoDumpTruncs,4,'Logging',NoTruncOrbsTag,ierr)
            NoTruncOrbs(:)=0
            do i=1,NoDumpTruncs
                call readi(NoTruncOrbs(i))
            enddo

        case("MULTTRUNCROFCIDUMP")
!This option allows us to specify multiple truncations, so that one calculation will print out multiple 
!ROFCIDUMP files with different
!levels of truncation - prevents us from having to do multiple identical CISD calculations to get the different truncations.
            tTruncRODump=.true.
            call readi(NoDumpTruncs)
            ALLOCATE(NoTruncOrbs(NoDumpTruncs),stat=ierr)
            CALL LogMemAlloc('NoTruncOrbs',NoDumpTruncs,4,'Logging',NoTruncOrbsTag,ierr)
            NoTruncOrbs(:)=0
            do i=1,NoDumpTruncs
                call readi(NoTruncOrbs(i))
            enddo

        case("MULTTRUNCVALROFCIDUMP")     
!This option allows us to specify particular cutoffs values for the eigenvalues - and print out multiply 
!ROFCIDUMP files with orbitals
!with eigenvalues below these removed.
            tTruncRODump=.true.
            tTruncDumpbyVal=.true.
            call readi(NoDumpTruncs)
            ALLOCATE(TruncEvalues(NoDumpTruncs),stat=ierr)
            CALL LogMemAlloc('TruncEvalues',NoDumpTruncs,8,'Logging',TruncEvaluesTag,ierr)
            TruncEvalues(:)=0.D0
            do i=1,NoDumpTruncs
                call readf(TruncEvalues(i))
            enddo

        case("WRITETRANSFORMMAT")
!This option writes out the transformation matrix used to convert the HF orbitals into the natural orbitals.  
!This can then be read into
!QChem to produce the natural orbital cube files and then visualise them using VMD.  Note : Currently, 
!because of Fortran 90's weird dealings
!with writing and reading binary - this option is only compatible with QChem if the code is compiled using 
!PGI - this will be fixed at 
!some stage.  Also - QChem INTDUMP files must be used to be compatible.  
            tWriteTransMat=.true.


        case("HIST-SPIN-DIST")
            ! Histogram the distribution of walkers within determinants of the
            ! given spatial configuration
            ! --> The determinant is specified using SPIN orbitals, but these
            !     are converted to a spatial structure for use.

            tHistSpinDist = .true.
            call readi(hist_spin_dist_iter)
            if (.not. allocated(nI_spindist)) &
                allocate(nI_spindist(nel))
            nI_spindist = 0
            i = 1
            do while (item < nitems .and. i <= nel)
                call geti(nI_spindist(i))
                i = i+1
            enddo


        case("ROHISTOGRAMALL")
!This option goes with the orbital rotation routine.  If this keyword is included, all possible histograms are included.
!These maybe also turned off/on with individual keywords.
!As it stands, the bins run from -1 to 1 with increments of 0.05. These parameters may be made options in the future.
            tROHistogramAll=.true.
            tROHistOffDiag=.true.
            tROHistDoubExc=.true.
            tROHistSingExc=.true.
            tROHistOneElInts=.true.
            tROHistOnePartOrbEn=.true.
            tROHistER=.true.
            tROHistVirtCoulomb=.true.

       case("ROHISTOFFDIAG")
!This option creates a histogram of the <ij|kl> terms where i<k and j<l.
            IF(item.lt.nitems) THEN
                call readu(w)
                select case(w)
                    case("OFF")
                        tROHistOffDiag=.false.
                end select
            ELSE
                tROHistOffDiag=.true.
            ENDIF

       case("ROHISTDOUBEXC")
!This option creates a histogram of the 2<ij|kl>-<ij|lk> terms, the off diagonal hamiltonian elements for double excitations.
            IF(item.lt.nitems) THEN
                call readu(w)
                select case(w)
                    case("OFF")
                        tROHistDoubExc=.false.
                end select
            ELSE
                tROHistDoubExc=.true.
            ENDIF
 
       case("ROHISTSINGEXC")
!This option creates a histogram of the single excitation hamiltonian elements.
            IF(item.lt.nitems) THEN
                call readu(w)
                select case(w)
                    case("OFF")
                        tROHistSingExc=.false.
                end select
            ELSE
                tROHistSingExc=.true.
            ENDIF

       case("ROHISTER")
!This option creates a histogram of the <ii|ii> terms, the ones that are maximised in the edmiston-reudenberg localisation.
            IF(item.lt.nitems) THEN
                call readu(w)
                select case(w)
                    case("OFF")
                        tROHistER=.false.
                end select
            ELSE
                tROHistER=.true.
            ENDIF
  
       case("ROHISTONEElINTS")
!This option creates a histogram of the one electron integrals, the <i|h|i> terms.
            IF(item.lt.nitems) THEN
                call readu(w)
                select case(w)
                    case("OFF")
                        tROHistOneElInts=.false.
                end select
            ELSE
                tROHistOneElInts=.true.
            ENDIF
         

       case("ROHISTONEPARTORBEN")
!This option creates a histogram of the one particle orbital energies, epsilon_i = <i|h|i> + sum_j [<ij||ij>].
            IF(item.lt.nitems) THEN
                call readu(w)
                select case(w)
                    case("OFF")
                        tROHistOnePartOrbEn=.false.
                end select
            ELSE
                tROHistOnePartOrbEn=.true.
            ENDIF
 
       case("ROHISTVIRTCOULOMB")
!This option creates a histogram of the coulomb integrals, <ij|ij>, where i and j are both virtual and i<j.
            IF(item.lt.nitems) THEN
                call readu(w)
                select case(w)
                    case("OFF")
                        tROHistVirtCoulomb=.false.
                end select
            ELSE
                tROHistVirtCoulomb=.true.
            ENDIF
        
        case("PRINTINTEGRALS")
!This option prints 2 files containing the values of certain integrals at each rotation iteration.  This is so that we can see the
!effect the rotation is having on all values, other than just the one we are max/minimising.
            tPrintInts=.true.

        case("PRINTTRICONNECTIONS")
!This option takes each generated pair of determinant and excitation and finds 3rd determinant to make up a triangular connection.
!The product of the three connecting elements are then histogrammed in two separate files. 
!In one, the triangular connections that combine 
!to be sign coherent are recorded, and in the other, those which are sign incoherent.
            CALL Stop_All(t_r,"PRINTTRICONNECTIONS option depreciated")
!            call readf(TriConMax)
!            call readi(NoTriConBins)
!            tPrintTriConnections=.true.

        case("HISTTRICONNELEMENTS")
!This keyword takes the above triangles of connected determinants and histograms each connecting 
!element that contributes to the triangle.
!It then prints these according to whether they are single or double connecting elements.
!It also prints a histogram and the average size of the Hjk elements (regardless of whether or not they are zero).
            CALL Stop_All(t_r,"HISTTRICONNELEMENTS option depreciated")
!            call readf(TriConHElSingMax)
!            call readf(TriConHElDoubMax)
!            call readi(NoTriConHElBins)
!            tHistTriConHEls=.true.

        case("PRINTHELACCEPTSTATS")
!This keyword prints out an extra file that keeps track of the H elements involved in spawning attempts 
!that are accepted or not accepted.
!It prints out the average H elements where spawning is accepted and the average where it is not accepted.
            CALL Stop_All(t_r,"PRINTHELACCEPTSTATS option depreciated")
!            tPrintHElAccept=.true.

        case("PRINTSPINCOUPHELS")
!This option prints out the number of positive and negative (and their sums) H elements connecting two spin coupled determinants.
            tPrintSpinCoupHEl=.true.

        case("HISTINITIATORPOPS")
!This option prints out a file (at every HistInitPopsIter iteration) containing the 
!natural log of the populations of the initiator determinants 
!and the number with this population. The range of populations histogrammed goes from ln(N_add) -> ln(1,000,000) with 50,000 bins.
            tHistInitPops=.true.
            call readi(HistInitPopsIter)

        case("CALCRDMONFLY")
!This keyword sets the calculation to calculate the reduced density matrix on the fly.  This starts at iteration number IterRDMonFly.
!If RDMExcitLevel = 1, only the 1 electron RDM is found, if RDMExcitLevel = 2, only the 2 electron RDM is found and if RDMExcitLevel = 3, both are found. 
            tRDMonFly=.true.
            call readi(RDMExcitLevel)
            call readi(IterRDMonFly)
            call readi(RDMEnergyIter)

        case("DIAGFLYONERDM")
!This sets the calculation to diagonalise the *1* electron reduced density matrix.  Obviously this doesn't work if RDMExcitLevel = 2.            
!The eigenvalues give the occupation numbers of the natural orbitals (eigenfunctions).
            tDiagRDM=.true.

        case("CALCRDMENERGY")
!This takes the 1 and 2 electron RDM and calculates the energy using the RDM expression.            
!For this to be calculated, RDMExcitLevel must be = 3, so there is a check to make sure this is so if the CALCRDMENERGY keyword is present.
            IF(item.lt.nitems) THEN
                call readu(w)
                select case(w)
                    case("OFF")
                        tDo_Not_Calc_RDMEnergy=.true.
                end select
            ELSE
                tDo_Not_Calc_RDMEnergy=.false.
            ENDIF

        case("EXPLICITALLRDM")
!Explicitly calculates all the elements of the RDM.            
            tExplicitAllRDM = .true.

        case("HFREFRDM")
!Uses the HF as a reference and stochastically calculates the RDM to find the energy - should be same as the averaged projected energy.            
            tHF_Ref = .true.

        case("HFREFRDMEXPLICIT")
!Uses the HF as a reference and explicitly calculates the RDM to find the energy - should be same as projected energy.            
            tHF_Ref_Explicit = .true.

        case("HFSDRDM")
!Calculate the RDM for the HF, singles and doubles only - symmetrically.            
            tHF_S_D = .true.

        case("HFSDREFRDM")
!Uses the HF, singles and doubles as a multiconfigurational reference and calculates the RDM to find the energy.            
            tHF_S_D_Ref = .true.
        
        case("RDMSPINAVERAGING")
!Ensures that all the spin flipped elements of the RDM are the same.            
            IF(item.lt.nitems) THEN
                call readu(w)
                select case(w)
                    case("OFF")
                        tRDMSpinAveraging=.false.
                end select
            ELSE
                tRDMSpinAveraging=.true.
            ENDIF

        case("AUTOCORR")
!This is a Parallel FCIMC option - it will calculate the largest weight MP1 determinants and histogramm them
!HF Determinant is always histogrammed. NoACDets(2) is number of doubles. NoACDets(3) is number of triples and NoACDets(4) is 
!number of quads to histogram.
            TAutoCorr=.true.
            CALL Stop_All("LogReadInput","The ACF code has been commented out in the FCIMCPar module")
            do i=2,4
                IF(item.lt.nitems) call readi(NoACDets(i))
            enddo
        case("DETPOPS")
!This option no longer works...
            TDetPops=.true.
        case("DISTRIBS")
            TDistrib=.true.
        case("HISTPARTENERGIES")
!This will histogram the hamiltonian matrix elements of the particles in the parallel FCIMC algorithm.
            tHistEnergies=.true.
            call readf(BinRange)
            call readi(iNoBins)
            call readf(OffDiagBinRange)
            call readf(OffDiagMax)
            IF(OffDiagMax.lt.0.D0) THEN
                OffDiagMax=-OffDiagMax
            ENDIF
        case("HISTSPAWN")
!This option will histogram the spawned wavevector, averaged over all previous iterations. 
!It scales horrifically and can only be done for small systems
!which can be diagonalized. It requires a diagonalization initially to work. 
!It can write out the average wavevector every iWriteHistEvery.
            tHistSpawn=.true.
            IF(item.lt.nitems) call readi(iWriteHistEvery)
        case("HISTHAMIL")
!This option will histogram the spawned hamiltonian, averaged over all previous iterations. It scales horrifically 
!and can only be done for small systems
!which can be diagonalized. It will write out the hamiltonian every iWriteHamilEvery.
            tHistHamil=.true.
            IF(item.lt.nitems) call readi(iWriteHamilEvery)
        case("BLOCKEVERYITER")
!This will block the projected energy every iteration with the aim of achieving accurate error estimates. 
!However, this does require a small amount of additional communication.
            tBlockEveryIteration=.true.
        case("PRINTFCIMCPSI")
            tPrintFCIMCPsi=.true.
            tCalcFCIMCPsi=.true.
        case("HISTEQUILSTEPS")
!This option sets the histogramming to only be done after the specified number of iterations.            
            call readi(NHistEquilSteps)
        case("PRINTORBOCCS")
!This option initiates the above histogramming of determinant populations and then at the end of the 
!spawning uses these to find the normalised  
!contribution of each orbital to the total wavefunction.  
            tPrintOrbOcc=.true.
            IF(item.lt.nitems) call readi(StartPrintOrbOcc)
        case("PRINTDOUBSUEG")
!This option initiates the above histogramming of doubles for the UEG
!            if (.not.tUEG) call stop_all("Logging","Printdoubs doesn't work with systems other than UEG")
            tPrintDoubsUEG=.true.
            IF(item.lt.nitems) call readi(StartPrintDoubsUEG)
        case("PRINTORBOCCSINIT")
!This option initiates the above histogramming of determinant populations and then at the end of the spawning uses these to find the normalised  
!contribution of each orbital to the total wavefunction.  
            tPrintOrbOcc=.true.
            tPrintOrbOccInit=.true.
            IF(item.lt.nitems) call readi(StartPrintOrbOcc)
        case("POPSFILE")
! This is so that the determinants at the end of the MC run are written
! out, to enable them to be read back in using READPOPS in the Calc section,
! if you want to restart the simulation at a later date.  !iWritePopsEvery
! will write the configuration of particles out each time the iteration
! passes that many.
            TPopsFile=.true.
            IF(item.lt.nitems) THEN
                tPrintPopsDefault=.false.
                call readi(iWritePopsEvery)
                IF(iWritePopsEvery.lt.0) THEN
!If a negative argument is supplied to iWritePopsEvery, then the POPSFILE will never be written out, even at the end of a simulation.
                    TPopsFile=.false.
                ENDIF
            ENDIF
        case("REDUCEDPOPSFILE")
!A reduced popsfile works in exactly the same way as a normal popsfile, but only every iPopsPartEvery particle is printed out.
            TPopsFile=.true.
            call readi(iWritePopsEvery)
            call readi(iPopsPartEvery)
        case("POPSFILETIMER")
            call readf(PopsfileTimer)   !Write out a POPSFILE every "PopsfileTimer" hours.
        case("BINARYPOPS")
!This means that the popsfile (full or reduced) will now be written out in binary format. 
!This should now take up less space, and be written quicker.
            tBinPops=.true.
        case("INCREMENTPOPS")
! Don't overwrite existing POPSFILES.
            tIncrementPops = .true.
        case("CCMCDEBUG")
!CCMC debugging level. Takes an integer 0-6
            call readi(CCMCDebug)
        case("FCIMCDEBUG")
!CCMC debugging level. Takes an integer 0-6
            call readi(FCIMCDebug)
        case("CCMCLOGTRANSITIONS")
            tCCMCLogTransitions=.true.
            do while(item.lt.nitems)
               call readu(w)
               select case(w)
               case("NONUNIQUE")
                  tCCMCLogUniq=.false.
               case("UNIQUE")
                  tCCMCLogUniq=.true.
               case default
                  CALL report("Logging keyword CCMCLOGTRANSITIONS "//trim(w)       &
     &               //" not recognised",.true.)
               end select
            enddo
        case("WRITEDETE")
!This logging option will write out the energies of all determinants which have been spawned at in the simulation
! The two input options are the number of bins, and the maximum determinant energy to be histogrammed.
            TWriteDetE=.true.
            IF(item.lt.nitems) call readi(NoHistBins)
            IF(item.lt.nitems) call readf(MaxHistE)
        case("ZEROPROJE")
! This is for FCIMC when reading in from a POPSFILE. If this is on, then the energy 
! estimator will be restarted.
            TZeroProjE=.true.
        case("WAVEVECTORPRINT")
! This is for FCIMC - if on, it will calculate the exact eigenvector and
! values initially, and then print out the running wavevector every
! WavevectorPrint MC steps. However, this is slower.
            TCalcWavevector=.true.
            call readi(WavevectorPrint)
        case("MCPATHS")
            ILOGGING = IOR(ILOGGING,2**1)
        case("BLOCKING")
            ILOGGING = IOR(ILOGGING,2**13)
        case("PREVAR")
            ILOGGING = IOR(ILOGGING,2**14)
        case("FMCPR")
!  We log the value
            ILOGGING = IOR(ILOGGING,2**0)
            do while(item.lt.nitems)
               call readu(w)
               select case(w)
               case("LABEL")
                   ILOGGING = IOR(ILOGGING,2**2)
               case("RHO")
                   ILOGGING = IOR(ILOGGING,2**3)
               case("1000")
                   ILOGGING = IOR(ILOGGING,2**9)
               case("EXCITATION")
                   ILOGGING = IOR(ILOGGING,2**12)
               case("XIJ")
                   ILOGGING = IOR(ILOGGING,2**6)
               case("")
                   ILOGGING = IOR(ILOGGING,2**2)
               case default
                  CALL report("Logging keyword FMCPR "//trim(w)       &
     &               //" not recognised",.true.)
               end select
            enddo
        case("CALCPATH")
            do while(item.lt.nitems)
               call readu(w)
               select case(w)
               case("LABEL")
                   ILOGGING = IOR(ILOGGING,2**4)
               case("RHO")
                   ILOGGING = IOR(ILOGGING,2**5)
               case("")
                   ILOGGING = IOR(ILOGGING,2**4)
               case default
                  CALL report("Logging keyword CALCPATH "//trim(w)    &
     &               //" not recognised",.true.)
               end select
            enddo
        case("XIJ")
            ILOGGING = IOR(ILOGGING,2**6)
        case("HAMILTONIAN")
            ILOGGING = IOR(ILOGGING,2**7)
        case("PSI")
            ILOGGING = IOR(ILOGGING,2**8)
        case("TIMING")
            do while(item.lt.nitems)
                call readu(w)
                select case(w)
                case("LEVEL")
                    call readi(iGlobalTimerLevel)
                case("PRINT")
                    call readi(nPrintTimer)
                case default
                    call reread(-1)
                    call readi(iGlobalTimerLevel)
                end select
            end do
        case("VERTEX")
            do while(item.lt.nitems)
               call readu(w)
               select case(w)
              ! case("1000")
              !     ILOGGING = IOR(ILOGGING,2**9)
               case("EVERY")
                   ILOGGING = IOR(ILOGGING,2**10)
               case default
                  call reread(-1)
                  call geti(G_VMC_LOGCOUNT)
                  ILOGGING = IOR(ILOGGING,2**9)
!                  CALL report("Logging keyword VERTEX "//trim(w)    &
!     &               //" not recognised",.true.)
               end select
            end do
        case("HFBASIS")
            ILOGGING = IOR(ILOGGING,2**11)
        case("HFLOGLEVEL")
            call geti(HFLOGLEVEL)
        case("SAVEPREVARLOGGING")
             PreVarLogging=iLogging
             iLogging=iLoggingDef
        case("DETS")
            tLogDets=.true.
        case("DETERMINANTS")
            tLogDets=.true.

        case ("INSTANT-S2")
            ! Calculate an instantaneous value for S^2, and output it to the
            ! relevant column in the FCIMCStats file.
            !
            ! The second parameter is a multiplier such that we only calculate
            ! S^2 once for every n update cycles (it must be on an update
            ! cycle such that norm_psi_squared is correct)
            tCalcInstantS2 = .true.
            if (item < nitems) then
                call readi (instant_s2_multiplier)
            endif


        case ("INSTANT-S-CPTS")
            ! Calculate components of the wavefunction with each value of S.
            ! n.b. This is NOT quantitatively correct.
            !      --> Only of QUALITATIVE utility.
            tCalcInstSCpts = .true.


        case("ENDLOG")
            exit logging
        case default
           CALL report("Logging keyword "//trim(w)//" not recognised",.true.)
        end select
      end do logging
    END SUBROUTINE LogReadInput


END MODULE Logging
