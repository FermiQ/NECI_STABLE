#include "macros.h"
MODULE System

    use SystemData

    IMPLICIT NONE

    contains

    subroutine SetSysDefaults()
      != Set defaults for Calc data items.

      use default_sets
      USE SymData, only: tAbelianFastExcitGen
      USE SymData, only: tStoreStateList
      implicit none

!     SYSTEM defaults - leave these as the default defaults
!     Any further addition of defaults should change these after via
!     specifying a new set of DEFAULTS.
      tUMatEps=.false.
      UMatEps=0.D0
      tImportanceSample=.false.
      tExactSizeSpace=.false.
      tMerTwist=.true.
      iRanLuxLev=3      !This is the default level of quality for the random number generator.
      tNoSymGenRandExcits=.false.
      tNonUniRandExcits=.false.
      tCycleOrbs=.false.
      TSTARSTORE=.false.
      TSTARBIN=.false.
      TREADINT=.false.
      THFORDER=.false.
      TDFREAD=.false.
      TPBC=.false.
      TUEG=.false.
      TCPMD=.false.
      tVASP=.false.
      THUB=.false.
      TUEG=.false.
      LMS=0
      TSPN=.false.
      TCSF=.false.
      STOT=0
      TPARITY = .false.
      IParity(:)=0
      NMAXX = 0
      NMAXY = 0
      NMAXZ = 0
      NMSH=32
      BOX=1.d0
      BOA=1.d0
      COA=1.d0
      TUSEBRILLOUIN=.false. 
      FUEGRS=0.D0
      iPeriodicDampingType=0
      fRc=0.D0
      TEXCH=.true.
      FCOUL=1.D0
      UHUB = 4
      BHUB = -1
      TREAL = .false.
      TTILT = .false.
      TALPHA = .false.
      ISTATE = 1
      OrbECutoff=1e20
      tStoreAsExcitations=.false.
      TBIN=.false.
      tAbelianFastExcitGen=.true.
      TNoRenormRandExcits=.false.
      tStoreStateList=.false.       !This will be turned to true by default if not in abelian symmetry
      tAssumeSizeExcitgen=.false.
      tLagrange=.false.
      tShake=.false.
      lNoSymmetry=.false.
      tRotateOrbs=.false.
      TimeStep=0.01
      ConvergedForce=0.001
      ShakeConverged=0.001
      tShakeApprox=.false.
      tShakeDelay=.false.
      ShakeStart=1
      tROIteration=.false.
      ROIterMax=5000
      tShakeIter=.false.
      ShakeIterMax=5
      tSeparateOccVirt=.false.
      tOffDiagSqrdMin=.false.
      tOffDiagSqrdMax=.false.
      tOffDiagMin=.false.
      tOffDiagMax=.false.
      tDoubExcMin=.false.
      tOneElIntMax=.false.
      tOnePartOrbEnMax=.false.
      tERLocalization=.false.
      tRotateOccOnly=.false.
      tRotateVirtOnly=.false.
      ERWeight=1.D0
      OffDiagWeight=1.D0
      OrbEnMaxAlpha=1.D0

!Feb08 defaults:
      IF(Feb08) THEN
          !...add defaults...
      ENDIF

! Coulomb damping function currently removed.
!      FCOULDAMPBETA=-1.D0
!      COULDAMPORB=0
        
    end subroutine SetSysDefaults

    SUBROUTINE SysReadInput()
      USE input
      USE SymData, only: tAbelianFastExcitGen
      USE SymData, only: tStoreStateList
      IMPLICIT NONE
      LOGICAL eof
      CHARACTER (LEN=100) w
      INTEGER I
      
      ! The system block is specified with at least one keyword on the same
      ! line, giving the system type being used.
      call readu(w)
      select case(w)

! The following systems are retained for backward compatibility:
! StarStoreRead, StarBinRead, DFRead, BinRead.  For these "systems", 
! the system should be given as Read and the appropriate option given
! in the main System section.
! At some point, these four options will be removed.
      case("STARSTOREREAD")      ! Instead, specify StarStore within the system block.
          TSTARSTORE = .true.
          TREADINT = .true.
          call readu(w)
          select case(w)
          case("ORDER")
              THFORDER = .true.
          end select
      case("STARBINREAD")        ! Instead, specify StarStore Binary within the system block.
          TSTARSTORE=.true.
          TBIN=.true.
          TREADINT=.true.
          call readu(w)
          select case(w)
          case("ORDER")
              THFORDER=.true.
          end select
      case("DFREAD")             ! Instead, specify DensityFitted within the system block.
          TREADINT = .true.
          TDFREAD = .true.
          call readu(w)
          select case(w)
          case("ORDER")
              THFORDER = .true.
          end select
      case("BINREAD")            ! Instead, specify Binary within the system block.
          TREADINT=.true.
          TBIN=.true.
          call readu(w)
          select case(w)
          case("ORDER")
              THFORDER=.true.
          end select

      case("READ","GENERIC")
          TREADINT = .true.
          call readu(w)
          select case(w)
          case("ORDER")
              THFORDER = .true.
          end select
      case("HUBBARD")
          THUB = .true.
          TPBC=.true.
      case("UEG")
          TUEG = .true.
      case("VASP")
          tVASP= .true.
      case("CPMD")
          TCPMD = .true.
          call readu(w)
          select case(w)
          case("ORDER")
              THFORDER = .true.
          end select
      case("BOX")
      case default
          call report("System type "//trim(w)//" not valid",.true.)
      end select
      
      ! Now parse the rest of the system block.
      system: do
        call read_line(eof)
        if (eof) then
            call report("Incomplete input file",.true.)
        end if
        call readu(w)
        select case(w)

        ! Options for molecular (READ) systems: control how the integral file 
        ! is read in.
        case("STARSTORE")
            tStarStore=.true.
            if (item.lt.nitems) then
                call readu(w)
                select case(w)
                case("BINARY")
                    tBin=.true.
                end select
            end if
        case("BINARY")
            tBin=.true.
        case("DENSITYFITTED")
            tDFRead=.true.

        ! General options.
        case("ELECTRONS","NEL")
            call geti(NEL)
        case("SPIN-RESTRICT")
            if(item.lt.nitems) then
               call geti(LMS)
            else
               LMS=0
            endif
            TSPN = .true.
        case("CSF")
            if(item.lt.nitems) then
               call geti(STOT)
            else
               STOT=0
            endif
            TCSF = .true.
        case("NOSYMMETRY")
            lNoSymmetry=.true.
            IF(tHub) THEN
                CALL Stop_All("SysReadInput","Cannot turn off symmetry with the hubbard model.")
            ENDIF
        case("SYM")
            TPARITY = .true.
            do I = 1,4
              call geti(IPARITY(I))
            end do
! the last number is the symmetry specification - and is placed in position 5
            IPARITY(5)=IPARITY(4)
            IPARITY(4)=0
        case("USEBRILLOUINTHEOREM")
          TUSEBRILLOUIN=.TRUE. 
        case("RS")
            call getf(FUEGRS)
        case("EXCHANGE-CUTOFF")
            iPeriodicDampingType=2
            if(item.lt.nitems) then
               call getf(fRc)
            endif
        case("EXCHANGE-ATTENUATE")
            iPeriodicDampingType=1
            if(item.lt.nitems) then
               call getf(fRc)
            endif
        case("EXCHANGE")
            call readu(w)
            select case(w)
               case("ON")
                  TEXCH=.TRUE.
               case("OFF")
                  TEXCH=.FALSE.
               case default
                  call report("EXCHANGE "//trim(w)//" not valid",.true.)
            end select
        case("COULOMB")
            call getf(FCOUL)
        case("COULOMB-DAMPING")
            call report("Coulomb damping feature removed",.true.)
!            call readu(w)
!            select case(w)
!            case("ENERGY")
!               call getf(FCOULDAMPMU)
!               call getf(FCOULDAMPBETA)
!            case("ORBITAL")
!               call geti(COULDAMPORB)
!               call getf(FCOULDAMPBETA)
!            end select
        case("ENERGY-CUTOFF")
          call getf(OrbECutoff)
        case("STORE-AS-EXCITATIONS")
           tStoreAsExcitations=.true.  

        ! Options for model systems (electrons in a box/Hubbard).   
        case("CELL")
            call geti(NMAXX)
            call geti(NMAXY)
            call geti(NMAXZ)
        case("MESH")
            call geti(NMSH)
        case("BOXSIZE")
            call getf(BOX)
            if(item.lt.nitems) then
               call getf(BOA)
               call getf(COA)
            else
               BOA=1.D0
               COA=1.D0
            endif
        case("U")
            call getf(UHUB)
        case("B")
            call getf(BHUB)
        case("REAL")
            TREAL = .true.
        case("APERIODIC")
            TPBC = .false.
        case("TILT")
            TTILT = .true.
            call geti(ITILTX)
            call geti(ITILTY)
        case("ALPHA")
            TALPHA = .true.
            call getf(ALPHA)
        case("STATE")
            call geti(ISTATE)
            if ( ISTATE /= 1 ) then
                call report("Require ISTATE to be left set as 1",.true.)
            end if
        case("FAST-EXCITGEN")
            tAbelianFastExcitGen=.true.
    ! tAbelianFastExcitGen is a temporary flag. 
    !  It is used to indicate that if an Abelian symmetry group is presents
    !   the excitation generators should use optimized routines
    !   to take this into account.  Not all excitation generator functions
    !   currently work with this.  USE WITH CARE
            if (item.lt.nitems) then
                call readu(w)
                select case(w)
                case("OFF")
                   tAbelianFastExcitGen=.false.
                end select
            end if
        case("NORENORMRANDEXCITS")
!    Since we have already calculated the number of excitations possible for each symmetry type, there
!    no need to renormalise all excitations with weight 1. As long as pairs of allowed occupied and
!    virtual orbitals can be chosen without any bias, then we can generate random excitations in O[1] time.
!    This is default off since it will change previous results, however it is strongly recommended to be
!    on for virtually all unweighted MC calculations, since it should speed up generation, especially in
!    low symmetry and/or large systems.
            tNoRenormRandExcits=.true.
        case("STORESTATELIST")
!This flag indicates that we want to store the full list of symmetry state pairs.
!This is done by default in non-abelian symmetries, but in abelian symmetries, will
!only be done if specified. This may be wanted, since it means that random excitations
!will be created quicker currently, since NoRenormRandExcits can only work with it on in 
!abelian symmetry.
            tStoreStateList=.true.
        case("ASSUMESIZEEXCITGEN")
!This flag indicates that we want to setup the excitations faster, by returning a maximum size of the
!generators instantly in the first setup, and then we do not need to run through the excitations twice.
!However, certain bits of the generator are not stored, namely nAllowPPS and SymProds, as well as the
!iterator information. This means that we can only randomly generate excitations, and any attempt to
!use these assumed size excitation generators to generate the whole list of excitations, will result 
!in bad, bad times.
            tAssumeSizeExcitgen=.true.


! The ROTATEORBS calculation initiates a routine which takes the HF orbitals
! and finds the optimal set of transformation coefficients to fit a particular criteria specified below.
! This new set of orbitals can then used to produce a ROFCIDUMP file and perform the FCIMC calculation.
        case("ROTATEORBS")
            tRotateOrbs=.true.
            call Getf(TimeStep)
            call Getf(ConvergedForce)

        case("OFFDIAGSQRDMIN")
            tOffDiagSqrdMin=.true.
            IF(item.lt.nitems) THEN
                call Getf(OffDiagWeight)
            ELSE
                OffDiagWeight=1.0
            ENDIF
! This sets the orbital rotation to find the coefficients which minimise the sum of the |<ij|kl>|^2 elements.
! The following real value sets the importance of the minimisation relative to the ER maximisation, providing 
! the ERLOCALIZATION keyword is also present.  This is the same for all OFFDIAG keywords below.

        case("OFFDIAGSQRDMAX")
            tOffDiagSqrdMax=.true.
            IF(item.lt.nitems) THEN
                call Getf(OffDiagWeight)
            ELSE
                OffDiagWeight=1.0
            ENDIF
! This sets the orbital rotation to find the coefficients which maximise the sum of the |<ij|kl>|^2 elements.

        case("OFFDIAGMIN")
            tOffDiagMin=.true.
            IF(item.lt.nitems) THEN
                call Getf(OffDiagWeight)
            ELSE
                OffDiagWeight=1.0
            ENDIF
! This sets the orbital rotation to find the coefficients which minimise the sum of the <ij|kl> elements.

        case("OFFDIAGMAX")
            tOffDiagMax=.true.
            IF(item.lt.nitems) THEN
                call Getf(OffDiagWeight)
            ELSE
                OffDiagWeight=1.0
            ENDIF
! This sets the orbital rotation to find the coefficients which maximise the sum of the <ij|kl> elements.

        case("DOUBEXCITEMIN")
            tDoubExcMin=.true.
            IF(item.lt.nitems) THEN
                call Getf(OffDiagWeight)
            ELSE
                OffDiagWeight=1.0
            ENDIF
! This sets the orbital rotation to find the coefficients which minimise the double excitation hamiltonian elements.

        case("ONEELINTMAX")
            tOneElIntMax=.true.
            tRotateVirtOnly=.true.
! This sets the orbital rotation to find the coefficients which maximise the one electron integrals, <i|h|i>.

        case("ONEPARTORBENMAX")
            tOnePartOrbEnMax=.true.
            tRotateVirtOnly=.true.
            IF(item.lt.nitems) THEN
                call Getf(OrbEnMaxAlpha)
            ELSE
                OrbEnMaxAlpha=1.D0
            ENDIF
! This sets the orbital rotation to find the coefficients which maximise the one particle orbital energies.
! i.e maximise the fock energies, epsilon_i = <i|h|i> + sum_j [<ij||ij>].

        case("ERLOCALIZATION")
            tERLocalization=.true.
            IF(item.lt.nitems) THEN
                call Getf(ERWeight)
            ELSE
                ERWeight=1.0
            ENDIF
! This sets the orbital rotation to an Edmiston-Reudenberg localisation.  This maximises the self repulsion energy, i.e 
! maximises the sum of the <ii|ii> terms.    

        case("SHAKE")
! This will use the shake algorithm to iteratively enforce orthonormalisation on the rotation coefficients calculated in the ROTATEORBS
! routine.  It finds a force matrix which moves the coefficients at a tangent to the constraint surface, from here, a normalisation
! will require just a small adjustment to ensure complete orthonormalisation, but not majorly affecting the new coefficients.
            tShake=.true.
            IF(item.lt.nitems) THEN
               call getf(ShakeConverged)
            ENDIF

        case("SHAKEAPPROX")
! This turns on the shake approximation algorithm.  To be used if the matrix inversion required in the full shake algorithm cannot 
! be performed.
! The approximation applies the iterative scheme to find lambda, to each constraint in succession, rather than simultaneously.
            tShakeApprox=.true.
        
        case("SHAKEITER")
! Much like 'ROIteration', this overwrites the convergence criteria for the iterations of the shake constraints
! and instead performs only the number of iterations specified on this line.
            tShakeIter=.true.
            call Geti(ShakeIterMax)
        
        case("SHAKEDELAY")
! This option sets the shake orthonomalisation algorithm to only kick in after a certain number of rotatation iterations.  This 
! potentially allows a large shift in the coefficients away from their starting point, followed by orthonormalisation to a 
! significantly different position.
            tShakeDelay=.true.
            call Geti(ShakeStart)

        case("LAGRANGE")
! This will use a non-iterative lagrange multiplier for each component of each rotated vector in the rotateorbs routines in order to 
! attempt to maintain orthogonality. This currently does not seem to work too well!
            tLagrange=.true.

        case("SEPARATEOCCVIRT")
! This option applies to the orbital rotation.  If present, the virtual and occuppied orbitals are localised separately.  This has the 
! advantage of keeping the HF reference determinant the same.
            tSeparateOccVirt=.true.

        case("ROTATEOCCONLY")
! This option applies to orbital rotation.  It separates the orbitals into occupied and virtual, and rotates the occupied while keeping the 
! virtual as the HF.
            tRotateOccOnly=.true.

        case("ROTATEVIRTONLY")
! This option rotates the virtual orbitals while keeping the occupied as the HF.            
            tRotateVirtOnly=.true.

        case("ROITERATION")
! Specifying this keyword overwrites the convergence limit from the ROTATEORBS line, and instead runs the orbital rotation for as many
! iterations as chosen on this line.
            tROIteration=.true.
            call Geti(ROIterMax)

        case("ROTATEDORBS")
! This is a flag which is to be included if the FCIDUMP being read in is one containing rotated orbitals.  The only difference is that the 
! H elements for single excitations are no longer 0 (as for HF), and walkers on singly excited determinants must be included in the energy 
! calculations.
            tRotatedOrbs=.true.

        case("RANLUXLEV")
!This is the level of quality for the random number generator. Values go from 1 -> 4. 3 is default.
            call readi(iRanLuxLev)

        case("MERSENNETWIST")
!An alternative random number generator.
            IF(item.lt.nitems) THEN
                call readu(w)
                select case(w)
                    case("OFF")
                        tMerTwist=.false.
                end select
            ELSE
                tMerTwist=.true.
            ENDIF

        case("CALCEXACTSIZESPACE")
!This option will calculate the exact size of the symmetry allowed space of determinants. Will scale badly.
            tExactSizeSpace=.true.

        case("NONUNIFORMRANDEXCITS")
!This indicates that the new, non-uniform O[N] random excitation generators are to be used.
!CYCLETHRUORBS can be useful if we have small basis sets or v high restrictive symmetry and will eliminate
!large numbers of unsuccessful random draws of orbitals by calculating how many allowed orbitals there are
!and cycling through them until the allowed one is drawn, rather than randomly drawing and redrawing until
!an allowed orbital is found. For large basis sets, the chance of drawing a forbidden orbital is small
!enough that this should be an unneccesary expense.
            tNonUniRandExcits=.true.
            do while (item.lt.nitems)
                call readu(w)
                select case(w)
                    case("CYCLETHRUORBS")
                        tCycleOrbs=.true.
                    case("NOSYMGEN")
!Do not generate symmetry-allowed excitations only, but all excitations. Spin-symmetry is still taken into account.
                        tNoSymGenRandExcits=.true.
                    case("IMPORTANCESAMPLE")
!Importance sample the excitations for FCIMCPar
                        tImportanceSample=.true.
                    case default
                        call Stop_All("ReadSysInp",trim(w)//" not a valid keyword")
                end select
            enddo
        case("UMATEPSILON")
!This is an option for systems which are reaad in from an FCIDUMP file. Any two-electron integrals which are smaller in
!magnitude than the value set for UMatEps will be set to zero.
            call readf(UMatEps)
            tUMatEps=.true.
        case("ENDSYS") 
            exit system
        case default
            call report("Keyword "                                    &
   &          //trim(w)//" not recognized in SYSTEM block",.true.)
        end select
      end do system

      if(NEL.eq.0)                                                    &
   &     call report("Number of electrons cannot be zero.",.true.)
      if(THUB.OR.TUEG.OR..NOT.(TREADINT.OR.TCPMD.or.tVASP)) then
         if(NMAXX.EQ.0)                                               &
   &        call report("Must specify CELL "                          &
   &        //"- the number of basis functions in each dim.",         &
   &        .true.)
         if(.NOT.THUB.AND.BOX.EQ.0.D0)                                &
   &        call report("Must specify BOX size.",.true.)
         if(TTILT.AND..NOT.THUB)                                      &
   &        call report("TILT can only be specified with HUBBARD.",.true.)
      endif

    END SUBROUTINE SysReadInput


        
    Subroutine SysInit
      Use global_utilities
      use SymData, only: tAbelian,TwoCycleSymGens
      implicit none
      character(25), parameter :: this_routine='SysInit'
      integer ierr

      CHARACTER CPAR(3)*1,CPARITY*3
! For init of mom
      TYPE(BasisFN) G
      INCLUDE 'csf.inc'
      INCLUDE 'cons.inc'
        
!  For the UEG
      REAL*8 FKF,Rs
        
! General variables
      INTEGER i,j,k,l,iG
      INTEGER len
      type(timer), save :: proc_timer
      REAL*8 SUM
! Called functions
      type(Symmetry) TotSymRep
      TYPE(BasisFN) FrzSym
      logical kallowed

!      write (6,*)
!      call TimeTag()
!      if (.not.TCPMD) call Envir()
!      write (6,*)

      ECORE=0.D0
      
! //AJWT TBR
!      IFDET=0
!      TRHOIJND=.false.
      proc_timer%timer_name='SysInit   '
      call set_timer(proc_timer)

!C ==-------------------------------------------------------------------==
!C..Input parameters
      WRITE(6,*) ' NUMBER OF ELECTRONS : ' , NEL
      WRITE(6,*) ' TSPN : ' , TSPN
      NBASISMAX(1:5,1:7)=0
      TSPINPOLAR=.FALSE.
      DO I=1,3
         SymRestrict%k(I)=IPARITY(I)
      ENDDO
      SymRestrict%Ms=IPARITY(4)
      SymRestrict%Sym%s=IPARITY(5)

      if(tUseBrillouin) THEN
         WRITE(6,*) "Using Brillouin's Theorem to ignore single excitations"
      endif
      if(tStoreAsExcitations) THEN
         write(6,*) "Storing determinants as excitations from the HF determinant.  WARNING this may not work!"
         IF(nEL.lt.8) STOP 'tStoreAsExcitations requires nEl>=8.'
      endif
      IF(TSPN) THEN
!C.. If we're doing monte carlo without generating a list of
!C.. determinants, we cannot as yet force spin or parity, except by
!C.. restricting the basis set.  This will only work for Ms=NEL/2
!C         IF((.NOT.TBLOCK).AND.(.NOT.TCALCHMAT.OR.NTAY.LE.0)) THEN
!C            WRITE(6,*) 'TSPN set to TRUE.  Determinant list not being',
!C     &         ' used for MC.  Forcing MS=Nel/2'
!C            IF(MOD(NEL,2).EQ.0) THEN
!C               LMS=NEL/2
!C            ELSE
!C               LMS=NEL
!C            ENDIF
!C            TSPINPOLAR=.TRUE.
!C         ENDIF
         IF(MOD(LMS+NEL*2,2).NE.MOD(NEL,2)) THEN
           WRITE(6,*) 'LMS=',LMS,' not achievable with',NEL,' electrons'
           WRITE(6,*) 'Resetting LMS'
           LMS=MOD(NEL,2)
         ENDIF
         LMS2=LMS
      ENDIF
      WRITE(6,*) ' GLOBAL MS : ' , LMS
      IF(TCSF) THEN
         WRITE(6,*) "Using CSFs."
         IF(TSPN) THEN
            WRITE(6,*) "Restricting total spin*2 to ",STOT
            IF(LMS.GT.STOT) STOP "Cannot have LMS>STOT"
!C.. Encode the symmetry for the total spin in LMS
            LMS2=LMS+STOT*CSF_NBSTART
         ENDIF
         NBASISMAX(4,7)=1
      ENDIF
      

      TwoCycleSymGens=.false.
      IF(TCPMD) THEN
         WRITE(6,*) ' *** GENERIC SYSTEM USING KOHN-SHAM ORBITALS *** '
         CALL CPMDSYSTEMINIT(LEN)   
         IF(TPARITY) THEN
            WRITE(6,"(A)",advance='no') ' SYMMETRIES : '
            CALL WRITEALLSYM(5,SymRestrict)
         ENDIF
         IF(THFORDER) WRITE(6,*)      "Ordering according to 1-electron energies."
      ELSEIF(tVASP) THEN
         WRITE(6,*) ' *** GENERIC SYSTEM USING HF ORBITALS PRODUCED BY VASP *** '
         CALL VASPSystemInit(LEN)   
      ELSEIF(TREADINT) THEN
!C.. we read in the integrals from FCIDUMP and ignore most config
!C..   
         WRITE(6,*) ' *** GENERIC SYSTEM *** '
         IF(THUB) THEN
            THUB=.FALSE.
            WRITE(6,*) "Setting THUB=.FALSE."
         ENDIF
         TwoCycleSymGens=.true.
         IF(TDFREAD) THEN
            WRITE(6,*) "Reading Density fitted integrals."
            LMSBASIS=LMS
            CALL InitDFBasis(nEl,nBasisMax,Len,LMsBasis)
         ELSE
            IF(TSTARSTORE) THEN
                WRITE(6,*) "Reading 2-vertex integrals of double excitations only"
            ENDIF
            LMSBASIS=LMS
            WRITE(6,*) "TBIN:",tBin
            CALL INITFROMFCID(NEL,NBASISMAX,LEN,LMSBASIS,TBIN)
!C.. say we're a UHF det so all singles are 0
            IF(LMS.EQ.0) THEN
               NBASISMAX(4,5)=1
            ELSE
               NBASISMAX(4,5)=2
            ENDIF
            IF(NBASISMAX(2,3).EQ.1) then
                WRITE(6,*) "Unrestricted calculation.  Cave Arthropodia"
            ENDIF
         ENDIF 
      ELSE   

      IF(TUEG) THEN
         WRITE(6,*) ' *** UNIFORM ELECTRON GAS CALCULATION ***' 
         IF(FUEGRS.NE.0.D0) THEN
            WRITE(6,*) 'Electron Gas Rs set to ',FUEGRS
            OMEGA=BOX*BOX*BOX*BOA*COA
!C.. required density is (3/(4 pi rs^3))
!C.. need omega to be (NEL* 4 pi rs^3 / 3)
!C.. need box to be (NEL*4 pi/(3 BOA COA))^(1/3) rs
            BOX=(NEL*4.D0*PI/(3.D0*BOA*COA))**(1.D0/3.D0)
            BOX=BOX*FUEGRS
            WRITE(6,*) "Resetting box size to ", BOX
         ENDIF
      ENDIF
      IF(THUB) WRITE(6,*) ' *** HUBBARD MODEL ***' 
!C..
      IF(.NOT.THUB.AND..NOT.TUEG) THEN
         WRITE(6,*) "Electron in cubic box."
         IF(TPARITY) THEN
            WRITE(6,*) ' ******************************* '
            WRITE(6,*) ' PARITY IS ON '
            DO I=1,3
               IF(IPARITY(I).EQ.1) THEN
                  CPAR(I)='G'
                ELSEIF(IPARITY(I).EQ.-1) THEN
                  CPAR(I)='U'
                ELSE 
                  STOP ' !!! PROBLEM WITH PARITY !!! '
                ENDIF
            ENDDO
            CPARITY=CPAR(1)//CPAR(2)//CPAR(3)
            WRITE(6,*) ' PARITY : ' , CPARITY
         ELSE
            WRITE(6,*) ' PARITY IS OFF '
         ENDIF
         WRITE(6,*) ' ******************************* '
         
!  //TBR
!         IF((.NOT.TBLOCK).AND.(.NOT.TCALCHMAT.OR.NTAY.LT.0)) STOP 'CANNOT USE PARITY WITHOUT LIST OF DETS' 
      ELSE
         IF(TPARITY) THEN
            WRITE(6,*) ' MOMENTUM : ',(IPARITY(I),I=1,3)
         ENDIF
      ENDIF
!C..
      NMAX=MAX(NMAXX,NMAXY,NMAXZ)
      NNR=NMSH*NMSH*NMSH
      WRITE(6,*) ' NMAXX : ' , NMAXX
      WRITE(6,*) ' NMAXY : ' , NMAXY
      WRITE(6,*) ' NMAXZ : ' , NMAXZ
      WRITE(6,*) ' NMSH : ' , NMSH 
!C.. 2D check
      IF(NMAXZ.EQ.0) THEN
         WRITE(6,*) 'NMAXZ=0.  2D calculation using C/A=1/A'
         COA=1/BOX
      ENDIF
      PI=ACOS(-1.D0)

!C..
      IF(THUB) THEN
         WRITE(6,'(1X,A,F19.5)') ' HUBBARD T : ' , BHUB
         WRITE(6,'(1X,A,F19.5)') ' HUBBARD U : ' , UHUB
         IF(TTILT) WRITE(6,*) 'TILTED LATTICE: ',ITILTX, ",",ITILTY
         IF(TTILT.AND.ITILTX.GT.ITILTY) STOP 'ERROR: ITILTX>ITILTY'
      ELSE
         WRITE(6,'(1X,A,F19.5)') ' BOX LENGTH : ' , BOX
         WRITE(6,'(1X,A,F19.5)') ' B/A : ' , BOA
         WRITE(6,'(1X,A,F19.5)') ' C/A : ' , COA
         TTILT=.FALSE.
      ENDIF
      ALAT(1)=BOX
      ALAT(2)=BOX*BOA
      ALAT(3)=BOX*COA
      IF(fRc.EQ.0.0.AND.iPeriodicDampingType.NE.0) THEN
         ALAT(4)=BOX*((BOA*COA)/(4*PI/3))**THIRD
      ELSE
         ALAT(4)=fRc
      ENDIF
!      ALAT(4)=2*BOX*(BOA*COA)**(1/3.D0)
      
      IF(THUB) THEN
         WRITE(6,*) ' X-LENGTH OF HUBBARD CHAIN:',(NMAXX)
         WRITE(6,*) ' Y-LENGTH OF HUBBARD CHAIN:',(NMAXY)
         WRITE(6,*) ' Z-LENGTH OF HUBBARD CHAIN:',(NMAXZ)
         WRITE(6,*) ' Periodic Boundary Conditions:',TPBC
         WRITE(6,*) ' Real space basis:',TREAL
         IF(TTILT.AND.THUB) THEN
            OMEGA=DFLOAT(NMAXX)*NMAXY*(ITILTX*ITILTX+ITILTY*ITILTY)
         ELSE
            OMEGA=DFLOAT(NMAXX)*(NMAXY)*(NMAXZ)
         ENDIF
         RS=1.D0
      ELSE
         OMEGA=ALAT(1)*ALAT(2)*ALAT(3)
         RS=(3.D0*OMEGA/(4.D0*PI*NEL))**THIRD
         ALAT(5)=RS
         IF(iPeriodicDampingType.NE.0) THEN
            IF(iPeriodicDampingType.EQ.1) THEN
               WRITE(6,*) "Using attenuated Coulomb potential for exchange interactions."
            ELSEIF(iPeriodicDampingType.EQ.2) THEN
               WRITE(6,*) "Using cut-off Coulomb potential for exchange interactions."
            ENDIF
      
            WRITE(6,*) "Rc cutoff: ",ALAT(4)
         ENDIF
         WRITE(6,*) "Wigner-Seitz radius Rs=",RS
         FKF=(9*PI/4)**THIRD/RS
         WRITE(6,*) "Fermi vector kF=",FKF
         WRITE(6,*) "Fermi Energy EF=",FKF*FKF/2
         WRITE(6,*) "Unscaled Fermi Energy nmax**2=",(FKF*FKF/2)/(0.5*(2*PI/ALAT(5))**2)
      ENDIF
      IF(OrbECutoff.ne.1e-20) WRITE(6,*) "Orbital Energy Cutoff:",OrbECutoff
      WRITE(6,'(1X,A,F19.5)') ' VOLUME : ' , OMEGA
      WRITE(6,*) ' TALPHA : ' , TALPHA
      WRITE(6,'(1X,A,F19.5)') ' ALPHA : ' , ALPHA
      ALPHA=MIN(ALAT(1),ALAT(2),ALAT(3))*ALPHA
      WRITE(6,'(1X,A,F19.5)') ' SCALED ALPHA : ' , ALPHA

!C..
!C..Calculate number of basis functions
!C.. UEG allows from -NMAX->NMAX      
      IF(TSPINPOLAR) THEN
         NBASISMAX(4,1)=1 
!C.. spinskip
         NBASISMAX(2,3)=1
      ELSE
         NBASISMAX(4,1)=-1
!C.. spinskip
!  If spinskip is unset
         IF(NBASISMAX(2,3).EQ.0) NBASISMAX(2,3)=2
      ENDIF
      NBASISMAX(4,2)=1
      IF(THUB) THEN
         IF(TTILT) THEN
            CALL SETBASISLIM_HUBTILT(NBASISMAX,NMAXX,NMAXY,NMAXZ,LEN,TPBC,ITILTX,ITILTY)
            IF(TREAL) STOP 'REAL TILTED HUBBARD NOT SUPPORTED'
          ELSE
            CALL SETBASISLIM_HUB(NBASISMAX,NMAXX,NMAXY,NMAXZ,LEN,TPBC,TREAL)
         ENDIF
      ELSEIF(TUEG) THEN
         NBASISMAX(1,1)=-NMAXX
         NBASISMAX(1,2)=NMAXX
         NBASISMAX(2,1)=-NMAXY
         NBASISMAX(2,2)=NMAXY
         NBASISMAX(3,1)=-NMAXZ
         NBASISMAX(3,2)=NMAXZ
         NBASISMAX(1,3)=-1
         LEN=(2*NMAXX+1)*(2*NMAXY+1)*(2*NMAXZ+1)*((NBASISMAX(4,2)-NBASISMAX(4,1))/2+1)
!C.. UEG
         NBASISMAX(3,3)=-1
      ELSE
         NBASISMAX(1,1)=1
         NBASISMAX(1,2)=NMAXX
         NBASISMAX(2,1)=1
         NBASISMAX(2,2)=NMAXY
         NBASISMAX(3,1)=1
         NBASISMAX(3,2)=NMAXZ
         NBASISMAX(1,3)=0
         LEN=NMAXX*NMAXY*NMAXZ*((NBASISMAX(4,2)-NBASISMAX(4,1))/2+1)
         NBASISMAX(1,3)=0
!C.. particle in box
         NBASISMAX(3,3)=-2
         tAbelian=.true.
      ENDIF
      ENDIF
!C..         (.NOT.TREADINT)


!C.. we actually store twice as much in arr as we need.
!C.. the ARR(1:LEN,1) are the energies of the orbitals ordered according to
!C.. BRR.  ARR(1:LEN,2) are the energies of the orbitals with default 
!C.. ordering.
!C.. ARR is reallocated in IntFreezeBasis if orbitals are frozen so that it
!C.. has the correct size and shape to contain the eigenvalues of the active
!C.. basis.
      WRITE(6,*) "# basis", Len
      Allocate(Arr(LEN,2),STAT=ierr)
      LogAlloc(ierr,'Arr',2*LEN,8,tagArr)
! // TBR
!      IP_ARRSTORE=IP_ARR
      ARR=0.d0
      Allocate(Brr(LEN),STAT=ierr)
      LogAlloc(ierr,'Brr',LEN,4,tagBrr)
      BRR(1:LEN)=0
      Allocate(G1(Len),STAT=ierr)
      LogAlloc(ierr,'G1',LEN,BasisFNSizeB,tagG1)
      G1(1:LEN)=BasisFN((/0,0,0/),0,Symmetry(0))
      IF(TCPMD) THEN
         WRITE(6,*) ' *** INITIALIZING BASIS FNs FROM CPMD *** '
         CALL CPMDBASISINIT(NBASISMAX,ARR,BRR,G1,LEN) 
         NBASIS=LEN
         iSpinSkip=NBasisMax(2,3)
      ELSEIF(tVASP) THEN
         WRITE(6,*) ' *** INITIALIZING BASIS FNs FROM VASP *** '
         CALL VASPBasisInit(ARR,BRR,G1,LEN) ! This also modifies nBasisMax
         NBASIS=LEN
         iSpinSkip=NBasisMax(2,3)
      ELSEIF(TREADINT.AND.TDFREAD) THEN
         WRITE(6,*) ' *** Creating Basis Fns from Dalton output ***'
         call InitDaltonBasis(nBasisMax,Arr,Brr,G1,Len)
         nBasis=Len
         call GenMolpSymTable(1,G1,nBasis,Arr,Brr)
      ELSEIF(TREADINT) THEN
         WRITE(6,*) ' *** CREATING BASIS FNs FROM FCIDUMP *** '
         CALL GETFCIBASIS(NBASISMAX,ARR,BRR,G1,LEN,TBIN) 
         NBASIS=LEN
!C.. we're reading in integrals and have a molpro symmetry table
         IF(lNoSymmetry) THEN
            WRITE(6,*) "Turning Symmetry off"
            DO I=1,nBasis
               G1(I)%Sym%s=0
            ENDDO
            CALL GENMOLPSYMTABLE(1,G1,NBASIS,ARR,BRR)
            DO I=1,nBasis
               G1(I)%Sym%s=0
            ENDDO
         ELSE
            CALL GENMOLPSYMTABLE(NBASISMAX(5,2)+1,G1,NBASIS,ARR,BRR)
         ENDIF
      ELSE
!C.. Create plane wave basis functions
         IG=0
         DO I=NBASISMAX(1,1),NBASISMAX(1,2)
           DO J=NBASISMAX(2,1),NBASISMAX(2,2)
             DO K=NBASISMAX(3,1),NBASISMAX(3,2)
               DO L=NBASISMAX(4,1),NBASISMAX(4,2),2
                  G%k(1)=I
                  G%k(2)=J
                  G%k(3)=K
                  G%Ms=L
                  IF((THUB.AND.(TREAL.OR..NOT.TPBC)).OR.KALLOWED(G,NBASISMAX)) THEN
                    IF(THUB) THEN
!C..Note for the Hubbard model, the t is defined by ALAT(1)!
                       IF(TPBC) THEN
                       CALL HUBKIN(I,J,K,NBASISMAX,BHUB,TTILT,SUM,TREAL)
                       ELSE
                      CALL HUBKINN(I,J,K,NBASISMAX,BHUB,TTILT,SUM,TREAL)
                       ENDIF
                    ELSE
                       SUM=(BOX**2)*((I*I/ALAT(1)**2)+(J*J/ALAT(2)**2)+(K*K/ALAT(3)**2))
                    ENDIF
                    IF(SUM.GT.OrbECutoff) CYCLE
                    IG=IG+1
                    ARR(IG,1)=SUM
                    ARR(IG,2)=SUM
                    BRR(IG)=IG
!C..These are the quantum numbers: n,l,m and sigma
                    G1(IG)%K(1)=I
                    G1(IG)%K(2)=J
                    G1(IG)%K(3)=K
                    G1(IG)%MS=L
                    G1(IG)%Sym=TotSymRep()
                  ENDIF
               ENDDO
             ENDDO
           ENDDO
         ENDDO
!C..Check to see if all's well
         WRITE(6,*) ' NUMBER OF BASIS FUNCTIONS : ' , IG 
         NBASIS=IG
         IF(LEN.NE.IG) THEN
            IF(OrbECutoff.gt.-1e20) then
               write(6,*) "Have removed ", LEN-IG, " high energy orbitals"
            else
               WRITE(6,*) "LEN=",LEN,"IG=",IG
               STOP ' LEN NE IG ' 
            endif
         ENDIF
         CALL GENMOLPSYMTABLE(1,G1,NBASIS,ARR,BRR)
      ENDIF
!C..        (.NOT.TREADINT)
!C.. Set the initial symmetry to be totally symmetric
      FrzSym=BasisFN((/0,0,0/),0,Symmetry(0))
      FrzSym%Sym=TotSymRep()
      CALL SetupFreezeSym(FrzSym)
!C..Now we sort them using SORT2 and then SORT

!C.. This sorts ARR and BRR into order of ARR [AJWT]
      CALL ORDERBASIS(NBASIS,ARR,BRR,ORBORDER,NBASISMAX,G1)
      CALL WRITEBASIS(6,G1,nBasis,ARR,BRR)
      IF(NEL.GT.NBASIS) STOP 'MORE ELECTRONS THAN BASIS FUNCTIONS'
      CALL FLUSH(6)
      IF(TREAL.AND.THUB) THEN
!C.. we need to allow integrals between different spins
         NBASISMAX(2,3)=1
      ENDIF      
      
      !This is used in a test in UMatInd
      NOCC=NEl/2 
      IF(TREADINT) THEN
!C.. we're reading in integrals and have a molpro symmetry table
         IF(lNoSymmetry) THEN
            WRITE(6,*) "Turning Symmetry off"
            CALL GENMOLPSYMREPS(1,G1,NBASIS,ARR,BRR) 
         ELSE
            CALL GENMOLPSYMREPS(NBASISMAX(5,2)+1,G1,NBASIS,ARR,BRR) 
         ENDIF
      ELSEIF(TCPMD) THEN
!C.. If TCPMD, then we've generated the symmetry table earlier,
!C.. but we still need the sym reps table.
         CALL GENCPMDSYMREPS(G1,NBASIS,ARR,BRR,1.d-5)
      ELSEIF(tVASP) THEN
!C.. If VASP-based calculation, then we've generated the symmetry table earlier,
!C.. but we still need the sym reps table. DEGENTOL=1.d-6. CHECK w/AJWT.
         CALL GENSYMREPS(G1,NBASIS,ARR,BRR,1.d-6)
      ELSEIF(THUB.AND..NOT.TREAL) THEN
         CALL GenHubMomIrrepsSymTable(G1,nBasis,nBasisMax)
         CALL GENHUBSYMREPS(nBasis/2,G1,NBASIS,ARR,BRR)
         CALL WRITEBASIS(6,G1,nBasis,ARR,BRR)
      ELSE
!C.. no symmetry, so a simple sym table
         CALL GENMOLPSYMREPS(1,G1,NBASIS,ARR,BRR) 
      ENDIF

!C..
!// TBR
!      WRITE(6,*) ' TREAD : ' , TREAD


!// TBR
!      WRITE(6,*) ' ETRIAL : ',ETRIAL
      IF(FCOUL.NE.1.D0)  WRITE(6,*) "WARNING: FCOUL is not 1.D0. FCOUL=",FCOUL
      IF(FCOULDAMPBETA.GT.0) WRITE(6,*) "FCOUL Damping.  Beta ",FCOULDAMPBETA," Mu ",FCOULDAMPMU
      call halt_timer(proc_timer)
    End Subroutine SysInit



    Subroutine SysCleanup()

      CALL ENDSYM()

    End Subroutine SysCleanup

    

    logical function AreSameSpatialOrb(i,j)
      ! Test whether spin orbitals i and j are from the same spatial orbital.
      ! Returns true if i and j are the *same* spin orbital or are the alpha
      ! and beta spin orbitals of the same spatial orbital.
      integer :: i,j
      integer :: a,b
      AreSameSpatialOrb=.false.
      if (i.eq.j) then
          AreSameSpatialOrb=.true.
      else
          a=min(i,j)
          b=max(i,j)
          if (G1(a)%Ms.eq.-1.and.b-a.eq.1) then
              ! a is the alpha and b is the beta of the same spatial orbital.
              AreSameSpatialOrb=.true.
          end if
      end if
    end function AreSameSpatialOrb
    
    

END MODULE System

SUBROUTINE WRITEBASIS(NUNIT,G1,NHG,ARR,BRR)
  ! Write out the current basis to unit nUnit
  use SystemData, only: Symmetry,SymmetrySize,SymmetrySizeB
  use SystemData, only: BasisFN,BasisFNSize,BasisFNSizeB
  IMPLICIT NONE
  INTEGER NUNIT,NHG,BRR(NHG),I
  TYPE(BASISFN) G1(NHG)
  REAL*8 ARR(NHG,2)
  DO I=1,NHG
      WRITE(NUNIT,'(6I7)',advance='no') I,BRR(I),G1(BRR(I))%K(1), G1(BRR(I))%K(2),G1(BRR(I))%K(3), G1(BRR(I))%MS
      CALL WRITESYM(NUNIT,G1(BRR(I))%SYM,.FALSE.)
      WRITE(NUNIT,'(2F19.9)')  ARR(I,1),ARR(BRR(I),2)
  ENDDO
  RETURN
END SUBROUTINE WRITEBASIS



SUBROUTINE ORDERBASIS(NBASIS,ARR,BRR,ORBORDER,NBASISMAX,G1)
  use SystemData, only: BasisFN
  implicit none
  INTEGER NBASIS,BRR(NBASIS),ORBORDER(8,2),nBasisMax(5,*)
  INTEGER BRR2(NBASIS)
  TYPE(BASISFN) G1(NBASIS)
  REAL*8 ARR(NBASIS,2),ARR2(NBASIS,2)
  INTEGER IDONE,I,J,IBFN,ITOT,ITYPE,K,ISPIN
  REAL*8 OEN
  IDONE=0
  ITOT=0
!.. copy the default ordered energies.
  CALL DCOPY(NBASIS,ARR(1,1),1,ARR(1,2),1)
  CALL DCOPY(NBASIS,ARR(1,1),1,ARR2(1,2),1)
  WRITE(6,"(A,8I4)") "Ordering Basis (Closed): ", (ORBORDER(I,1),I=1,8)
  WRITE(6,"(A,8I4)") "Ordering Basis (Open  ): ", (ORBORDER(I,2),I=1,8)
  IF(NBASISMAX(3,3).EQ.1) THEN
!.. we use the symmetries of the spatial orbitals
     DO ITYPE=1,2
        IBFN=1
        DO I=1,8
           DO J=1,ORBORDER(I,ITYPE)
              DO WHILE(IBFN.LE.NBASIS.AND.(G1(IBFN)%SYM%s.LT.I-1.OR.BRR(IBFN).EQ.0))
                 IBFN=IBFN+1
              ENDDO
              IF(IBFN.GT.NBASIS) THEN
                 STOP "Cannot find enough basis fns of correct symmetry"
              ENDIF
              IDONE=IDONE+1 
              BRR2(IDONE)=IBFN
              BRR(IBFN)=0
              ARR2(IDONE,1)=ARR(IBFN,1)
              IBFN=IBFN+1
           ENDDO
        ENDDO
! Beta sort
        CALL SORT2SKIP(IDONE-ITOT,ARR2(ITOT+1,1),BRR2(ITOT+1),2)
! Alpha sort
        CALL SORT2SKIP(IDONE-ITOT,ARR2(ITOT+2,1),BRR2(ITOT+2),2)
        ITOT=IDONE
     ENDDO
     DO I=1,NBASIS
        IF(BRR(I).NE.0) THEN
           ITOT=ITOT+1
           BRR2(ITOT)=BRR(I)
           ARR2(ITOT,1)=ARR(I,1)
        ENDIF
     ENDDO
     CALL NECI_ICOPY(NBASIS,BRR2,1,BRR,1)
     CALL DCOPY(NBASIS,ARR2,1,ARR,1) 
  ENDIF
! beta sort
  CALL SORT2SKIP(NBASIS-IDONE,ARR(IDONE+1,1),BRR(IDONE+1),2)
! alpha sort
  CALL SORT2SKIP(NBASIS-IDONE,ARR(IDONE+2,1),BRR(IDONE+2),2)
!.. We need to now go through each set of degenerate orbitals, and make
!.. the correct ones are paired together in BRR otherwise bad things
!.. happen in FREEZEBASIS
!.. We do this by ensuring that within a degenerate set, the BRR are in
!.. ascending order
!         IF(NBASISMAX(3,3).EQ.1) G1(3,BRR(1))=J
  DO ISPIN=0,1
     OEN=ARR(1+ISPIN,1)
     J=1+ISPIN
     ITOT=2
     DO I=3+ISPIN,NBASIS,2
        IF(ABS(ARR(I,1)-OEN).GT.1.D-4) THEN
!.. We don't have degenerate orbitals
!.. First deal with the last set of degenerate orbitals
!.. We sort them into order of BRR
           CALL SORT2SKIP_(ITOT,BRR(I-ITOT), ARR(I-ITOT,1),2)
!.. now setup the new degenerate set.
           J=J+2
           ITOT=2
        ELSE
           ITOT=ITOT+2
        ENDIF
        OEN=ARR(I,1)
        IF(NBASISMAX(3,3).EQ.1) THEN
!.. If we've got a generic spatial sym or hf we mark degeneracies
!               G(3,BRR(I))=J
        ENDIF
     ENDDO
     CALL SORT2SKIP_(ITOT,BRR(I-ITOT),ARR(I-ITOT,1),2)
  ENDDO
END subroutine ORDERBASIS



LOGICAL FUNCTION KALLOWED(G,NBASISMAX)
  ! See if a given G vector is within a (possibly tilted) unit cell.
  ! Used to generate the basis functions for the hubbard model (or perhaps electrons in boxes)
  IMPLICIT NONE
  INTEGER G(5),nBasisMax(5,*),NMAXX,I,J,AX,AY
  INTEGER KX,KY
  REAL*8 MX,MY,XX,YY
  LOGICAL TALLOW
  TALLOW=.TRUE.
  IF(NBASISMAX(3,3).EQ.1) THEN
!.. spatial symmetries
      IF(G(1).NE.0) TALLOW=.FALSE.
  ELSEIF(NBASISMAX(3,3).EQ.0) THEN
!.. Hubbard
      IF(NBASISMAX(1,3).EQ.1) THEN
!.. Tilted hubbard
          NMAXX=NBASISMAX(1,5)
!         NMAXY=
          AX=NBASISMAX(1,4)
          AY=NBASISMAX(2,4)
!.. (XX,YY) is the position of the bottom right corner of the unit cell
          XX=((AX+AY)/2.D0)*NMAXX
          YY=((AY-AX)/2.D0)*NMAXX
          MX=XX*AX+YY*AY
          MY=XX*AY-YY*AX
          I=G(1)
          J=G(2)
          KX=I*AX+J*AY
          KY=I*AY-J*AX
          IF(KX.GT.MX) TALLOW=.FALSE.
          IF(KY.GT.MY) TALLOW=.FALSE.
          IF(KX.LE.-MX) TALLOW=.FALSE.
          IF(KY.LE.-MY) TALLOW=.FALSE.
      ELSEIF(NBASISMAX(1,3).GE.4.OR.NBASISMAX(1,3).EQ.2) THEN
!.. Real space Hubbard
          IF(G(1).EQ.0.AND.G(2).EQ.0.AND.G(3).EQ.0) THEN
             TALLOW=.TRUE.
          ELSE
              TALLOW=.FALSE.
          ENDIF
!      ELSEIF(NBASISMAX(1,3).EQ.2) THEN
!.. mom space non-pbc non-tilt hub - parity sym
!          IF(  (G(1).EQ.0.OR.G(1).EQ.1)
!     &       .AND.(G(2).EQ.0.OR.G(2).EQ.1)
!     &       .AND.(G(3).EQ.0.OR.G(3).EQ.1)) THEN
!              TALLOW=.TRUE.
!          ELSE
!              TALLOW=.FALSE.
!          ENDIF
!      ELSEIF(NBASISMAX(1,3).EQ.2) THEN
!.. non-pbc hubbard
!          TALLOW=.TRUE.
!          IF(G(1).GT.NBASISMAX(1,2).OR.G(1).LT.NBASISMAX(1,1))
!     &       TALLOW=.FALSE.
!          IF(G(2).GT.NBASISMAX(2,2).OR.G(2).LT.NBASISMAX(2,1))
!     &       TALLOW=.FALSE.
!          IF(G(3).GT.NBASISMAX(3,2).OR.G(3).LT.NBASISMAX(3,1))
!     &       TALLOW=.FALSE.
      ELSE
!.. Normal Hubbard
          TALLOW=.TRUE.
          IF(G(1).GT.NBASISMAX(1,2).OR.G(1).LT.NBASISMAX(1,1)) TALLOW=.FALSE.
          IF(G(2).GT.NBASISMAX(2,2).OR.G(2).LT.NBASISMAX(2,1)) TALLOW=.FALSE.
          IF(G(3).GT.NBASISMAX(3,2).OR.G(3).LT.NBASISMAX(3,1)) TALLOW=.FALSE.
      ENDIF
  ENDIF         
  KALLOWED=TALLOW
  RETURN
END FUNCTION KALLOWED
