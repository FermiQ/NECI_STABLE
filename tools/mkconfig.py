#!/usr/bin/python
'''Produce a makefile for compiling the neci source code for a specified target/configuration.

Usage:
    mkconfig.py [options] configuration_file

A platform is defined using a simple ini file, consisting of three sections:
main, opt and dbg.  For instance::

    [main]
    cc = gcc
    ld = gcc
    libs = -llapack -lblas

    [opt]
    cflags = -O3

    [dbg]
    cflags = -g

The 'opt' and 'dbg' sections inherit settings from the 'main' section.  The settings
in 'opt' are used by default; the debug options can be selected by passing the
-g option to mkconfig.py.

Available options are:

fc [required]
    Set the fortran compiler.
fflags
    Set flags to be passed to the fortran compiler during compilation.
f77flags
    Set flags to be passed to the fortran compiler during compilation of *.F files.
f90flags
    Set flags to be passed to the fortran compiler during compilation of *.F90 files.
cc [required]
    Set the C compiler.
cflags
    Set flags to be passed to the C compiler during compilation.
cpp [required]
    Set the C pre-processor (only used with *.F and *.F90 files, as the
    C compiler handles pre-processing of C source files).
cppdefs
    Set definitions and flags to be used in the C pre-processing step.
    Those for setting the VCS information and memory availability are already
    included.
ld [required]
    Set the linker program.
ldflags
    Set flags to be passed to the linker during linking of the compiled objects.
libs [required]
    Set libraries to be used during the linking step.
module_flag [required]
    Set the flag used by the compiler which is used to specify the directory
    where module (.mod) files are placed when created and where they should be
    searched for.
compiler
    Set the compiler name used by compare_module_files.pl to avoid cascade
    compilation.
'''

import ConfigParser
import optparse
import os
import pprint
import sys

#======================================================================

MAKEFILE_TEMPLATE='''# Generated by mkconfig.py.
# Using the %(config)s %(opt_level)s configuration. 

SHELL = /bin/bash # For our sanity!

#-----
# Compiler configuration

# pre-processing.
CPP = %(cpp)s
CPPFLAGS = %(cppflags)s -DMAXMEM='$(MAXMEM)' -D_VCS_VER='$(VCS_VERSION)' $(WORKING_DIR_CHANGES) 

# use compiler with perl scripts to avoid cascade compilation.
compiler = %(compiler)s

# fortran compiler and flags.
FC = %(fc)s
FFLAGS = %(fflags)s
F77FLAGS = %(f77flags)s
F90FLAGS = %(f90flags)s

# c compiler and flags.
CC = %(cc)s
CFLAGS = %(cflags)s

# linker, linker flags and libraries.
LD = %(ld)s
LDFLAGS = %(ldflags)s
LIBS = %(libs)s

# For building neci library.
AR = ar
ARFLAGS = -rcs

#-----
# Directory structure and setup

# Directories containing source files (space separated list).
SRC = src

# Directories in which compiled objects are placed.
DEST = dest/opt
# REAL (molecular and gamma-point) objects
GDEST = $(DEST)/real
# COMPLEX (k-point) objects
KDEST = $(DEST)/cmplx

# Directory for compiled executable.
EXE = bin

# Directory for neci libraries.
LIB = lib

# Directory containing scripts to avoid cascade compilation
TOOLS = tools

# Directories that make searches for pre-requisites in addition to the local directory (./).
# Colon separated list.
# We include $(DEST) in this so we can do pre-processing and compilation in 2 steps.
empty :=
space := $(empty) $(empty) # stupid make language...
VPATH = $(subst $(space),:,$(SRC) $(DEST))

# Create output directories if they don't exist.
make_gdest := $(shell test -e $(GDEST) || mkdir -p $(GDEST))
make_kdest := $(shell test -e $(KDEST) || mkdir -p $(KDEST))
make_exe := $(shell test -e $(EXE) || mkdir -p $(EXE))
make_lib := $(shell test -e $(LIB) || mkdir -p $(LIB))

#-----
# VCS info.

# Get the version control id.  Git only.  Outputs a string.
VCS_VERSION := $(shell set -o pipefail && echo -n \\" && ( git log --max-count=1 --pretty=format:%%H || echo -n 'Not under version control.' ) 2> /dev/null | tr -d '\\r\\n'  && echo -n \\")

# Test to see if the working directory contains changes.  Git only.  If the
# working directory contains changes (or is not under version control) then
# the _WORKING_DIR_CHANGES flag is set.
WORKING_DIR_CHANGES := $(shell git diff --quiet --cached && git diff --quiet 2> /dev/null || echo -n "-D_WORKING_DIR_CHANGES")

#-----
# Additional info.

MAXMEM = %(max_mem)i # RAM available, in MB.  Used by the memory logger.

#-----
# Find source files and resultant object files.

# Source extensions.
EXTS = .F90 .F .C .c

# Source filenames.
find_files = $(wildcard $(1)/*$(2))
FSRCFILES := $(foreach dir,$(SRC),$(call find_files,$(dir),.F))
F90SRCFILES := $(foreach dir,$(SRC),$(call find_files,$(dir),.F90))
CSRCFILES := $(foreach dir,$(SRC),$(call find_files,$(dir),.C))
cSRCFILES := $(foreach dir,$(SRC),$(call find_files,$(dir),.c))
SRCFILES := $(FSRCFILES) $(F90SRCFILES) $(CSRCFILES) $(cSRCFILES)

# Objects (strip path and replace extension of source files with .o).
FOBJ_bare := $(addsuffix .o,$(basename $(notdir $(FSRCFILES))))
F90OBJ_bare := $(addsuffix .o,$(basename $(notdir $(F90SRCFILES))))
COBJ_bare := $(addsuffix .o,$(basename $(notdir $(CSRCFILES))))
cOBJ_bare := $(addsuffix .o,$(basename $(notdir $(cSRCFILES))))

# Full path to all objects (gamma-point).
FOBJ := $(addprefix $(GDEST)/, $(FOBJ_bare))
F90OBJ := $(addprefix $(GDEST)/, $(F90OBJ_bare))
COBJ := $(addprefix $(GDEST)/, $(COBJ_bare))
cOBJ := $(addprefix $(GDEST)/, $(cOBJ_bare))
OBJECTS := $(FOBJ) $(F90OBJ) $(COBJ) $(cOBJ)

# Similarly for the kpoint objects.
KFOBJ := $(addprefix $(KDEST)/, $(FOBJ_bare))
KF90OBJ := $(addprefix $(KDEST)/, $(F90OBJ_bare))
KCOBJ := $(addprefix $(KDEST)/, $(COBJ_bare))
KcOBJ := $(addprefix $(KDEST)/, $(cOBJ_bare))

# Objects for standalone NECI.
# We don't need libstub.
OBJECTS_NECI := $(filter-out %%libstub.o,$(OBJECTS))

# Objects for CPMD library.
# We don't need necimain.o, cpmdstub.o, init_coul.o, init_could2D.o.  We keep libstub though.
OBJECTS_RCPMD := $(filter-out %%necimain.o %%cpmdstub.o %%init_coul.o %%init_could2D.o,$(OBJECTS)) 
OBJECTS_KCPMD := $(addprefix $(KDEST)/,$(notdir $(OBJECTS_RCPMD)))

# Objects for VASP library.
# We don't need necimain.o, vaspstub.o, init_coul.o, init_could2D.o.  We keep libstub though.
OBJECTS_RVASP := $(filter-out %%necimain.o %%vaspstub.o %% %%init_coul.o %%init_could2D.o, $(OBJECTS)) 
OBJECTS_KVASP := $(addprefix $(KDEST)/,$(notdir $(OBJECTS_RVASP)))

#-----
# Dependency files.

# Fortran dependencies.
# We need these before compiling any fortran files.
FRDEPEND = $(GDEST)/.depend
FCDEPEND = $(KDEST)/.depend
FDEPEND = $(FRDEPEND) $(FCDEPEND)

# C dependencies.
# We don't need these when we first compile, only when we recompile.
# We achieve this (most of the time) by recompiling the C dependencies every
# time we compile.
CDEPEND_FILES = $(COBJ:.o=.d)
cDEPEND_FILES = $(cOBJ:.o=.d)
KCDEPEND_FILES = $(KCOBJ:.o=.d)
KcDEPEND_FILES = $(KcOBJ:.o=.d)
CDEPEND = $(CDEPEND_FILES) $(cDEPEND_FILES) $(KCDEPEND_FILES) $(KcDEPEND_FILES)

#-----
# Goals

.PHONY: clean depend help neci.x

# First, some helpful macros.

# Rebuild of environment_report.
GBLD_ENV = rm $(GDEST)/environment_report.* && $(MAKE) $(GDEST)/environment_report.o
KBLD_ENV = rm $(KDEST)/environment_report.* && $(MAKE) $(KDEST)/environment_report.o

# Creating an archive from *.o files.
ARCHIVE = $(AR) $(ARFLAGS) $@ $^

$(EXE)/neci.x : $(OBJECTS_NECI)
	$(GBLD_ENV)
	$(LD) $(LDFLAGS) -o $@ $(OBJECTS_NECI) $(LIBS)

$(LIB)/gneci-cpmd.a : $(OBJECTS_RCPMD)
	$(GBLD_ENV)
	$(ARCHIVE)

$(LIB)/kneci-cpmd.a : $(OBJECTS_KCPMD)
	$(KBLD_ENV)
	$(ARCHIVE)

$(LIB)/gneci-vasp.a : $(OBJECTS_RVASP)
	$(GBLD_ENV)
	$(ARCHIVE)

$(LIB)/kneci-vasp.a : $(OBJECTS_KVASP)
	$(KBLD_ENV)
	$(ARCHIVE)

clean: 
	  rm -f {$(GDEST),$(KDEST)}/*.{f,f90,mod,o,c,x,a,d} $(EXE)/neci.x $(LIB)/*.a

# Generate dependency files.
$(FRDEPEND):
	$(TOOLS)/sfmakedepend --file - --silent $(SRCFILES) --objdir \$$\(GDEST\) --moddir \$$\(GDEST\) > $(FRDEPEND)

$(FCDEPEND):
	$(TOOLS)/sfmakedepend --file - --silent $(SRCFILES) --objdir \$$\(KDEST\) --moddir \$$\(KDEST\) > $(FCDEPEND)

depend: 
	$(MAKE) -B $(FDEPEND) $(CDEPEND)

#-----
# Shortcut goals

neci.x: $(EXE)/neci.x

gneci-cpmd: $(LIB)/gneci-cpmd.a
kneci-cpmd: $(LIB)/kneci-cpmd.a
cpmdlibs: gneci-cpmd kneci-cpmd

gneci-vasp: $(LIB)/gneci-vasp.a
kneci-vasp: $(LIB)/kneci-vasp.a
vasplibs: gneci-vasp kneci-vasp

libs: cpmdlibs vasplibs

#-----
# Compilation macros (explicit rules)

.SUFFIXES:
.SUFFIXES: $(EXTS) .f .f90

# Some more helpful macros.
CPP_BODY = $(CPPFLAGS) $< $@
C_BODY = $(CFLAGS) -c $< -o $@ 
MAKE_C_GDEPS = $(CC) $(CFLAGS) -MM -MT \$$\(GDEST\)/$(addsuffix .o,$(basename $(notdir $@))) $< -o $@
MAKE_C_KDEPS = $(CC) $(CFLAGS) -MM -MT \$$\(KDEST\)/$(addsuffix .o,$(basename $(notdir $@))) $< -o $@

# Compiling fortran source files...

# 1. Pre-processing.
# a) gamma-point.
$(GDEST)/%%.f90: %%.F90
	$(CPP) $(CPP_BODY)

$(GDEST)/%%.f: %%.F
	$(CPP) $(CPP_BODY)

# b) k-point.
$(KDEST)/%%.f90: %%.F90
	$(CPP) -D__CMPLX $(CPP_BODY)

$(KDEST)/%%.f: %%.F
	$(CPP) -D__CMPLX $(CPP_BODY)

# 2. Compile.
$(F90OBJ) $(KF90OBJ): %%.o: %%.f90
	perl -w $(TOOLS)/compile_mod.pl -cmp "perl -w $(TOOLS)/compare_module_file.pl -compiler $(compiler)" -fc "$(FC) $(FFLAGS) $(F90FLAGS) %(module_flag)s$(dir $@) -I $(SRC) -c $< -o $@" -provides "$@" -requires "$^"

$(FOBJ) $(KFOBJ): %%.o: %%.f
	perl -w $(TOOLS)/compile_mod.pl -cmp "perl -w $(TOOLS)/compare_module_file.pl -compiler $(compiler)" -fc "$(FC) $(FFLAGS) $(F77FLAGS) %(module_flag)s$(dir $@) -I $(SRC) -c $< -o $@" -provides "$@" -requires "$^"

# Compiling C source files...
# a) gamma-point.
$(COBJ): $(GDEST)/%%.o: %%.C
	$(CC) $(CPPFLAGS) $(C_BODY)

$(cOBJ): $(GDEST)/%%.o: %%.c
	$(CC) $(C_BODY)

# b) k-point.
$(KCOBJ): $(KDEST)/%%.o: %%.C
	$(CC) $(CPPFLAGS) -D__CMPLX $(C_BODY)

$(KcOBJ): $(KDEST)/%%.o: %%.c
	$(CC) $(C_BODY)

# Update C dependency files.
# a) gamma-point.
$(cDEPEND_FILES): $(GDEST)/%%.d: %%.c
	$(MAKE_C_GDEPS)

$(CDEPEND_FILES): $(GDEST)/%%.d: %%.C
	$(MAKE_C_GDEPS)

# b) k-point.
$(KcDEPEND_FILES): $(KDEST)/%%.d: %%.c
	$(MAKE_C_KDEPS)

$(KCDEPEND_FILES): $(KDEST)/%%.d: %%.C
	$(MAKE_C_KDEPS)

#-----
# Include dependency files

# Dependency files will be generated if they don't exist.
include $(FDEPEND)
include $(CDEPEND)
'''

def parse_options(my_args):
    parser = optparse.OptionParser(usage='mkconfig.py [options] configuration_file')
    parser.add_option('-l', '--ls', action='store_true', default=False, help='Print list of available configurations.')
    parser.add_option('-d', '--dir', default='config/', help='Set directory containing the configuration files. Default: %default.')
    parser.add_option('-g', '--debug', action='store_true', default=False, help='Use the debug settings.  Default: use optimised settings.')
    parser.add_option('-p', '--print', dest='print_conf', action='store_true', default=False, help='Print settings in configuration file specified, or all settings if no configuration file is specified.')
    (options, args) = parser.parse_args(my_args)
    if not (options.print_conf or options.ls) and len(args) != 1:
        print 'Incorrect arguments.'
        parser.print_help()
        sys.exit(1)
    elif len(args) == 1:
        config_file = args[0]
    else:
        config_file = None
    return (options, config_file)

def list_configs(config_dir):
    '''List all config files in config dir.  We assume only config files are in config_dir'''
    if os.path.isdir(config_dir):
        return os.listdir(config_dir)
    else:
        raise IOError, 'Config directory specified is not a directory: %s.' % (config_dir)

def parse_config(config_dir, config_file):
    '''Parse the configuration file config_file located in the directory config_dir.'''
    parser = ConfigParser.RawConfigParser()

    valid_sections = ['main', 'opt', 'dbg']

    valid_sections_upper = [s.upper() for s in valid_sections]

    valid_options = ['fc', 'fflags', 'f77flags', 'f90flags', 'module_flag', 'compiler', 'cc', 'cflags', 'cpp', 'cppflags', 'ld', 'ldflags', 'libs', 'max_mem']

    minimal_options = ['fc', 'module_flag', 'cc', 'cpp', 'ld', 'libs']

    file = os.path.join(config_dir, config_file)

    parser.read(file)

    for s in parser.sections():
        if s not in valid_sections and s not in valid_sections_upper:
            raise IOError, 'Invalid section in configuration file: %s.' % (s)

    for s in valid_sections:
        if s not in parser.sections() and s.upper() not in parser.sections():
            raise IOError, 'Section not present in configuration file: %s.' % (s)             

    if not parser.sections():
        raise IOError, 'No sections in configuration file: %s.' % (s)

    config = {}

    for s in valid_sections:
        config[s] = dict(parser.items('main'))
        if s in parser.sections():
            config[s].update(parser.items(s))
        elif s.upper() in parser.sections():
            config[s].update(parser.items(s.upper()))

    for s in valid_sections:
        for opt in config[s].keys():
            if opt not in valid_options:
                raise IOError, 'Invalid option in configuration file: %s.' % (opt)
        # Fill in blanks
        for opt in valid_options:
            if opt not in config[s].keys():
                if opt == 'max_mem':
                    config[s][opt] = 1024
                else:
                    config[s][opt] = ''

    config.pop('main')

    for s in config.keys():
        # Check minimal options.
        for opt in minimal_options:
            if not config[s][opt]:
                raise IOError, 'Required option not set: %s' % (opt)
        # Treat module_flag specially: append a space if it doesn't end in =.
        # This is to allow the same template to be used no matter how the compiler
        # insists on handling this flag.
        if not config[s]['module_flag'][-1] == '=':
            config[s]['module_flag'] = '%s ' % (config[s]['module_flag'])

    return config

def create_makefile(config_dir, config_file, use_debug=False):
    '''Create the Makefile using the options given in the config_file located in config_dir.'''
    if use_debug:
        config = parse_config(config_dir, config_file)['dbg']
        config.update(opt_level='debug')
    else:
        config = parse_config(config_dir, config_file)['opt']
        config.update(opt_level='optimised')
    config.update(config=config_file)
    f=open('Makefile', 'w')
    f.write(MAKEFILE_TEMPLATE % config)
    f.close()

if __name__=='__main__':
    args=sys.argv[1:]
    (options, config_file) = parse_options(args)
    if options.ls:
        print 'Available configurations are: %s.' % (', '.join(list_configs(options.dir)))
    elif options.print_conf:
        if config_file:
            config_files = [config_file]
        else:
            config_files = list_configs(options.dir)
        for config_file in config_files:
            config = parse_config(options.dir, config_file)
            print 'Settings in configuration file: %s' % (config_file)
            pprint.pprint(config)
            print
    else:
        create_makefile(options.dir, config_file)
