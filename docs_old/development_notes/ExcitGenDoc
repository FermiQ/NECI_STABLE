This document is intended to describe the algorithm for finding excitations of determinants in detail, as well as describing the variables in use.

It is initially going to describe the setup of the abelian excitation generators and random excitation generation.
Tasks to do and optimisation opportunities will be listed to work on. Feel free to add to this - its a work in progress.

TO DO
=====

Remove all ICOPYs
Return ij->ab matrix for calculating matrix elements without finding these again.
Bug in DF
Bug in NN system - See bari:/home/ghb24/necitest/ExitGenTest/MemoryCheck/
One of the inner loops in SymSetupExcitsAbelian_CountVirtProds can be unwould and the data precalculated in the SymSetupExcits_CreateClassSymProds routine. - AJWT
Remove Class Remainder info for the fast abelian excitation generators (symrem) and create a SSEA_StoreSingles/SSEA_CountSingles routine which loops over classes and spins.
Seperate flag for parallel excitation generation?
StoreOccPairs could be made much simpler for abelian symmetries. Can we get away without storing occupied pairs? If we do this, can we simply precalculate the 
    memory needed for the generator, so that it doesn't need to be called twice, but just once? Amount of memory is also important - not just for memory
    considerations, but for the fact that ~12% of the time in an FCIMC calculation is spent moving excitation generators around!
Save memory in NALLOWPPS by letting it go from 1:nPr for abelian systems
So far mainly concentrated on improving the excitation setup efficiency, however the actual random excitation generation takes much more time (48% in an FCIMC calc).
    How can this be improved for abelian symmetry?? Especially enumExcitweights and lower routines.


Further Project
---------------
Create one-shot random excitation (or just smaller memory excitgens). What is the algorithm to do this most efficiently?
    Potential Algorithm:   Setup mainly wants to just find NAllowPPS... 
    

THEORY
======

Excitations from a determinant Di, to an excitated determinant De are restricted by the symmetry of the two determinants.
In essence, the symmetry product of all orbitals in both Di and De must contain the totally symmetric representation.

    Single excitations
    ------------------

Spin symmetry must be conserved - Ms must be the same for Di and De.
Therefore, the spin of the occupied orbital (i) must be the same as the spin of the excited orbital (a).
For spatial symmetry, we must choose i and a such that we keep the symmetric representation in the symmetry product of the determinants.
For abelian symmetries, this means that i and a must come from the same symmetry class.

    Double excitations
    ------------------

For spatial symmetry, we find that the symmetry product of i x j x a x b must contain the totally symmetry representation.
We find the total possible i,j,a,b's by precomputing a list of all orbital pairs and their symmetry products.
In the excitation generator setup, the list of occupied pair symmetries is also calculated. Finally, the virtual pair symmetry list is created
by removing occupied orbitals from the list of all orbital pairs.
Allowed excitations then correspond to the case where a pair of orbitals from the occupied list and virtual list have a 
symmetry product which contains A1.

The excitation can then be generated by choosing a symmetry of the ij pair, choosing the actual ij pair from the list of 
occupied orbital pairs with that symmetry, and then running through the a,b pairs with complimentary symmetry, which would give a
symmetry product containing A1. From these a,b pairs, we have to remove pairs where one or both of the orbitals are in Di, count them
and choose a pair with a normalised probability. We then multiply this by the probability of choosing a double rather than single,
and the probability of choosing the symmetry class given by ab to get the final probability.

Spin symmetry also need to be included in this. I.e. alpha,alpha ij pair will need a alpha,alpha ab pair.

    Expected Algorithm
    ------------------

In the setup phase, we will run through the occupied orbital pairs, finding symmetry products of all pairs. This is done twice,
first to find how many, and second to store them all. In addition, we need to count the number of single and double excitations. For
singles and abelian symmetry, for every i, we sum the number of other orbitals in the same symmetry class, which are not members of Di.
For doubles, we need to find the number and symmetry of the pairs of orbitals which do not have any orbitals in common with Di.

When we generate the random excitation, we want to first pick whether to excite to a single or double and the symmetry, given by a normalised
probability, given by the sum of the number of occupied orbitals (for single excitations) and ij pairs of that symmetry.

To Finish

PRE-SETUP SYMMETRY CALCULATIONS
===============================

    Types
    -----

Symmetry    -   S:      INTEGER*8   Symmetries are stored as a bit string in an integer*8. Abelian symmetries then decompose this into three seperate
                                    integers to represent symmetry. For molecular systems, symmetry is a maximum of D2h, and so the symmetry values
                                    are 0 -> 7/3/1/0.

BasisFN     -   k(3):   INTEGER     These indicate quantum numbers for the basis function for systems such as Hubbard model.
                Ms:     INTEGER     This is the spin of the orbital - can take values of +-1. Alpha = -1, Beta = 1.
                Sym:    Type(Symmetry)  The symmetry irrep of the orbital.

SymPairProd types are used to hold information about pairs of orbitals according to their symmetry product.

SymPairProd -   Sym:    Type(Symmetry)  The symmetry product of the pair of orbitals.
                nPairs: INTEGER         The number of pairs of orbitals (or symmetries for abelian groups) with symmetry Sym
                nIndex: INTEGER         The complete list of symmetry pairs (ordered by symmetry) is called SymStatePairs. 
                                        nIndex is a pointer to the first pair in SymStatePairs with that symmetry.
                nPairsStateSS:  INTEGER For abelian symmetries, SymPairProds holds a list of pair symmetry products, rather than State products. 
                                        In this case, it is the same as pairs of symmetry classes. This value is then the number of pairs 
                                        of orbitals with the same spin which could be generated with this symmetry product.
                nPairsStateOS:  INTEGER This is the same but for opposite spin.

SymClass is used internally in the setup of the excitation generators. Each SymClass corresponds to a single symmetry of an orbital in Di

SymClass    -   SymRem: Type(Symmetry)  The resultant symmetry of Di when we remove an orbital with this symmetry.
                SymLab: INTEGER         The symmetry of the orbital being removed (i.e. its value in SymClasses)

    Orbital Information
    -------------------

Arr( NSpinOrbitals , 2)     REAL*8      List of orbital energies.
                                        Arr(:,1)
                                        ordered by energy.  Moreover when we have a set of degenerate orbitals with
                                        different symmetry, they are ordered within that set such that orbitals with
                                        the same symmetry are next to each other, and then by Ms=-1,1.
                                        Arr(10,1) is the energy of the 10th lowest energy
                                        spin-orbital.
                                        Arr(:,2)
                                        ordered by spin-orbital index.  Arr(10,1) is the energy of the 10th
                                        spin-orbital (given the index scheme in use).

Brr( NSpinOrbitals )        INTEGER     Lists the orbital indexes in energy order (rather than symmetry then energy order)
                                        I.e. Brr(1) is the lowest energy orbital

G1 (NSpinOrbitals )     Type(BasisFN)   Contains the information about the spin-orbitals given by the BasisFN type (mainly symmetry).

These are all set for molecular systems in GetFCIBasis.

nSymLabels      INTEGER      -  Number of symmetry elements - for abelian symmetry, this equals the number of symmetry classes, and for molecular systems, this
                                can only be a maximum of 8.

SymClasses ( NSpinOrbs )    INTEGER     This lists the symmetry class labels of each *STATE* in the first (NSpinOrbs+1)/2 elements as an integer. 

SymLabels ( nSymLabels )    Type(Symmetry)  This takes the symmetry class label from SymClasses and returns the bit string integer which gives the true symmetry.
                                            For molecular systems, this is actually just the label-1 ? and calculated in GenMolpSymTable

SymReps ( 2 , NSpinOrbs )   INTEGER     SYMREPS is used to group together degenerate sets of orbitals of the same
                                        sym (e.g. the six orbitals which might make up a T2g set), and is used
                                        for working out the symmetry of a determinant in GETSYM It uses that fact
                                        that even for non-abelian groups a completely filled degenerate symmetry
                                        set is totally symmetric.  Thus each member of a set of states which when
                                        completely filled gives a totally symmetric det should be labelled with
                                        the same symrep
                                        SYMREPS(2,:) has two sets of data:
                                            SYMREPS(1,IBASISFN) contains the numnber of the representation
                                                                of which IBASISFN is a part.
                                            SYMREPS(2,N) contains the degeneracy of the Nth Degenerate block of spin-orbitals
                                        For molecular systems, SymReps(2,N) will always be at least 2 and even. This is calculated in GenMolpSymReps.

SymLabelList ( NStates )    INTEGER     This is the index of the states, ordered in terms of the SymClasses Symmetry labels.

SymLabelCounts ( 2 , nSymLabels)    INTEGER     SymLabelCounts(1, SymIrrep) is an index to the element of the array in SymLabelList where the symmetry irrep
                                                SymIrrep starts.
                                                SymLabelCounts(2, SymIrrep) is the number of states in SymLabelList which are in the block of states with symmetry SymIrrep.
These two are calculated in GenSymStatePairs in sym.F

    Orbital Pair Information
    ------------------------

The following section is initially concerned with abelian symmetries, and as such, we don't bother calculating a list of all pairs of states, since we 
can calculate their number (just the multiplication of the number of states with each symmetry in the product - from SymLabelCounts), and they're easy to generate. 
Instead, SymPairProds contains information about lists of symmetry class pairs, rather than state pairs.
However, crucially, there is information in the derived type to tell us how many state pairs with the same spin, or opposite spin, have the given symmetry product.
This is all calculated in GenSymStatePairs. Firstly, the number of unique symmetry products is found and saved in nSymPairsProds. If there is at least one state with every symmetry
in the group, then nSymPairProds will be equal to nSymLabels. Also, in the %nPairs of the SymPairProd type is stored the number of distinct
symmetry pairs which give rise to spin-orbital pairs with this symmetry product.

SymPairProds ( nSymLabels^2 )   Type(SymPairProd)   In Abelian symmetry, as discussed above, this contains a list of all pairs of symmetry classes. 
                                                    Only nSymPairProds elements will actually be used
                                                    Contained will be the symmetry of the symmetry pairs (Sym), 
                                                    the number of allowed symmetry pairs which will give rise to the given symmetry (nPairs), 
                                                    the index in SymStatePairs where this symmetry product block starts - basically nPairs calculated cumulativly starting from 0 (nIndex),
                                                    the number of pairs of spin-orbitals with the same spin which have symmetry product given by Sym (nPairsStateSS)
                                                    the number of pairs of spin-orbitals with opposite spin which have symmetry product given by Sym (generally greater than same-spin) (nPairsStateOS)
                                                    
SymStatePairs ( 2 , 0:nSymPairs )       INTEGER     Normally, this will give a list of states which have a given symmetry product. However, for abelian
                                                    symmetries, this is a list of allowed *symmetry* pairs, which combine to give the nSymPairProds different symmetry products.
                                                    The symmetry labels are listed in (:,N). The index of different pair product blocks is given in SymPairProds%nIndex.


EXCITATION GENERATOR SETUP
==========================

The first call of GenSymExcitIt2 finds the amount of different storage requirements for various lists needed in the excitation generator. This is returned in STORE(6) and the length of the excitation generator.

Also, various chunks of memory are allocated and pointers to them are stored in Store2(6), an integer*8 array of pointers. Store1(1) points to DSTORE.


STORE array pointers:
    STORE(1):
    STORE(2):
    STORE(3):
    STORE(4):
    STORE(5):
    STORE(6):

DSTORE is allocated with enough memory to store the symmetry classes of all the electrons and the symmetries of all occupied orbital pairs.
It is split up and passed to SymSetupExcits3. The argument list for this routine is:
    
    SYMSETUPEXCITS3(NI,NEL,G1,NBASIS,NBASISMAX,STORE,TCOUNT,ICOUNT,CLASSES,ILUT,SYMPRODS,ILEVEL,iMinElec1,iMaxElec1)

STORE is the empty 6 INT*8 array. In the first time through symsetupexcits3, where the excitations are counted (TCount=.true.), it will just return the size of the various lists to allocate in the excitation generator. On entry, STORE(1) points to DSTORE.
ICOUNT is total excitations from this determinant, singles and doubles
CLASSES is the first NEL*SymClassSize elements of DSTORE, and will hold the symmetry information of the orbitals in Di, given by the derived type 'SymClass'
ILUT is the next NBASIS/32 elements of DSTORE and is used as a bit representation of the determinant.
SYMPRODS is the final NEL^2 * SymmetrySize elements of DSTORE and will hold information on the symmetry products of the occupied orbital pairs.
ILEVEL is 1 for single, 2 for just doubles and 3 for both.
IMinElec1 and IMaxElec1 are simply 1 and NEL respectivly if not using the parallel excitation generators.

CLASSES ( NEL )     Type(SymClass)      Info about the symmetry class of each occupied spin-orbital.
                                        If not every electron is in a distinct class, then it will only be useful up to nCl, since the electrons will
                                            then be grouped into the same symclass.
                                        SymRem: Type(Symmetry)  The resultant symmetry of Di when we remove an orbital with this symmetry.
                                        SymLab: INTEGER         The symmetry of the orbital being removed (i.e. its value in SymClasses)

Algorithm: First list all the different symmetry classes in NI.
For each pair of symmetry classes, determine its symmetry product.
Classify and store each possible pair of orbitals under its symmetry product, [].
With each of the symmetry products [], calculate []' such that []x[]'
contains the totally symmetric rep.
We do this by checking whether any of the []' in the 
global symprods table multiply by [] to give the symmetric rep.

    SSE_CreateClassList(Classes, *ClassCount)
    -----------------------------------------

This routine is used to create the list of classes in the occupied orbitals. This should be O(N) operation.
The number of classes, NCL = O(NSYM).
Two arrays are filled:                  CLASSES(NEL) gives the symmetry details of the occupied orbitals in Di

CLASSCOUNT( 2 , NEL )   INTEGER     -   Number of electrons in each class.
                                        This has the format (Spn,iCl), where Spin=1,2 corresponding to alpha and beta and
                                        iCl is the index of the Class. Classes(iCL)%SymLab will then give the symmetry of class iCL.
                                        If not every electron is in a distinct class, then it will only be useful up to nCl.

NCL is returned with the number of symmetry classes in Di.

Algorithm: Loop through electrons, find symmetry of each electron (from SymClasses array) and add it to the Classes array if its a new symmetry.
           If the symmetry of the electron is already in the SymClasses array, then increment the ClassCount array to indicate the number of electrons in it.

The second part of the routine deals with the symmetry remainder when that orbital is removed from Di. This is stored in the SymRem component of the 
Classes array. This is an O(NCL) operation and used for calcuating the number of symmetry allowed single excitations. With abelian symmetry, this is
simply done and can be removed, since i and a for single excitations have to come from the same class.

For the parallel excitation generators, we also create THISCLASSCOUNT and PREVCLASSCOUNT, as well as CLASSCOUNT. If this is not being done in parallel, then
PREVCLASSCOUNT(:,:)=0
THISCLASSCOUNT(:,:)=CLASSCOUNT(:,:)

SSE_CreateClassSymProds(nPr,nPairs,nCl,SymProds,SymProdCount,*ClassCount,Classes)
---------------------------------------------------------------------------------

This routine will calculate the possible symmetry products from pairs of orbitals in Di. This is put into SymProds, which is passed into SSE3 as part of DSTORE.
SymProds(iPr) gives a value of type(Symmetry) corresponding to the symmetry product of pair iPr. 
Also passed in is an integer array, SYMPRODCOUNT(3,0:NEL^2). SYMPRODCOUNT(3,iPr) gives the number of occupied spin-orbital pairs of a given spin combinations,
which have symmetry product SymProds(iPr). The Spin combination is put in the first index and 1 corresponds to beta beta, 2 to alpha/beta and beta/alpha, and 3 to alpha,alpha

nCL is passed in as the number of symmetry classes in Di.
Returned arrays are: 

SYMPRODCOUNT (3 , 0:nPR )   INTEGER         Number of occupied spin-orbital pairs of a given spin-combination, which have symmetry product label iPr
SymProds     (0:nPR)        Type(Symmetry)  Symmetry of occupied spin-orbital pair with symmetry product iPr
                                            If every symmetry is represented in Di, for molecular systems, you would expect SymProds(i)%S=i-1

Returned values are:

nPr = Number of distinct symmetry products. For abelian, this is =< nCL
nPairs = Total number of allowed pairs of occupied spin-orbitals

Algorithm:      Loop over all nCL class pairs
                Find symmetry product of the class pair (the individual symmetry irreps are stored in SymLabels(Classes(:)%SymLab)) )
                Find if the symmetry product is already in the SymProds list of distinct symmetry classes. If not, add it.
                Find the number of each spin-combination orbital pairs allowed in the symmetry pair.
                I.e. If there are N_a(I) and N_a(J) spin-orbs in classes I and J, then there are N_a(I)*N_a(J) alpha,alpha spin-orb pairs.
                However, if I.eq.J, then you have to look at distinct spin-orbital pairs, and so there are only N_a(I)*N_a(I)/2 alpha,alpha spin-orb pairs.
                The information about the number of spin orbitals is added to SymProdCount for each nPr.
                The total number of pairs of spin-orbitals of all spin-combinations is summed to give nPairs.
                SymProds and SYMPRODCOUNT is then sorted in terms of the value of the symmetry product for easy searching later.
                Also, SYMPRODCOUNT is then given a cumulative value, (so that it can be used as an index?).

This routine will scale as O(NCL^2). 

-----------------------------

After this, if we are in the first setup phase, we allocate memory to hold an integer variable SymProdInd. If its in the second phase, then we just point to
the start of this variable in the excitation generator memory. SYMPRODIND memory pointer is in STORE(5)

SYMPRODIND ( 2 , 3 , 0:nPr )    INTEGER     This array is used to index the orbital pairs. 
                                            (:,ISPN,:) gives the ISPN different spin-combos (3)
                                            (:,:,j) gives the index of the spin-orbitals with symmetry j in ORBPAIRS (nPr+1)
                                            SYMPRODIND(1,ISPN,I) will point to the index where the Ith symmetry product with spin-combo ISPN starts
                                            SYMPRODIND(2,:,:) is effectivly scratch space to indicate the next free position in the block.

Now, we change SYMPRODCOUNT. This originally was the cumulative number of orbital pairs with a given symmetry product. This is now shifted, so that 
SYMPRODCOUNT(ISPN,I) is the index of the first orbital pair of SYMPROD(I) with spin ISPN in ORBPAIRS. Orbpairs is an array which will be created later to hold
all the allowed ij pairs. This index is copied to SYMPRODIND(1,:,:).

Now allocate if first run, or point to if second run, the memory to hold the ORBPAIRS. This is pointed to by STORE(4).

ORBPAIRS (2 , 0:nPairs)         INTEGER     This array will hold all the allowed occupied pairs according to their symmetry product.
                                            Each pair consists of (ORB1,ORB2) where ORB1<ORB2


SSE_StoreOccPairs(OrbPairs,nPairs,nPr,SymProdInd,SymProds)
----------------------------------------------------------

This routine is to store the list of all occupied orbital pairs, ordered by symmetry product, which is indexed by SYMPRODIND.
With each symmetry product (denoted []), calculate []'' which is the remainder after having removed the orbitals. Is this necessary for Abelian sym?
SYMPRODS(I) specifies a sym prod.  Orbitals for this are stored in ORBPAIRS starting at index SYMPRODIND(1,ISPN,I)+1.
The first free space is at SYMPRODIND(1,ISPN,I)+SYMPRODIND(2,ISPN,I)+1.

Algorithm:  Run over all distinct electron pairs
            Find symmetry product of the pairs
            Find the position in SymProds which gives the required symmetry (Binary search since ordered earlier)
            Find the ISPN of the electron pair
            Find the block in SymProdInd which it is in
            Calculate the next free space in ORBPAIRS from SymProdInd
            Put I and J into ORBPAIRS

This scales as O(N^2), but should be able to be improved for abelian symmetries. Is it even necessary then? We should be able to determine this from
a list of occs sorted by sym. We should store counts however.

---------------------------------------------------------

Next, a clever little mask is created called ILUT. ILUT is technically an INTEGER of length 0:NBASIS/32. It is actually a bitstring containing the information about which
orbitals are occupied in Di. Therefore, if NI was 2,4,8,9, ILUT would be 2+2^3+2^7+2^8, i.e. occupied orbitals represented by ones in the bit string corresponding to all orbitals.
This enables us to check if an orbital is in NI in O(1), not O(N).

Next we allocate memory for array NALLOWPPS if we are counting, or point to memory in the excitation generator if we are going through for the second time by STORE(3).

NALLOWPPS (1:3 , nSymPairProds )    INTEGER     This array will hold the number of *ALLOWED* ab pairs of each symmetry product for a given spin-combo.

For abelian symmetry, only symmetry pairs of orbitals that have the same symmetry as occupied pairs will be allowed. Therefore, we could save memory by allowing NALLOWPPS to be (1:3 , nPr)

SSE_CountVirtProds(nDoub,nExcitTypes,nPr,nSymPairProds,nAllowPPS,iLUT)
----------------------------------------------------------------------

This routine goes back to the precalculated list of all nSymPairProds symmetry orbital pairs. From this list, we have to find the number of orbital pairs which are allowed to be excited into.
This is based on the fact that the ab pairs must not have any orbitals common with Di.
Since we are working with abelian symmetry, SymPairProds(nSymPairProds) is a list of symmetry products and SymStatePairs gives a list of symmetries which multiply to give that symmetry.
Our work is reduced, since we know that SymmetryPair(ij) must equal SymmetryPair(ab) in abelian symmetry. Therefore, we do not need to run through all the pairs, but can 
enumerate them without this need. The number of virtual pairs is simply the difference between the number of occupied pairs of a given sym and the total number of pairs.

Returned values:   

nDoubs                      INTEGER     This is the number of allowed doubles
nExcitTypes                 INTEGER     This is the number of different ways of getting an excitation, i.e. Different spin or symmetry
                                            The same information about singles is added to this.
NAllowPPS (3,nSymPairProds) INTEGER     Allowed virtual pairs for each spin-combo and symmetry      

Algorithm:      Loop over nSymPairProds (Symmetry products of all orbital pairs)
                Find that symmetry pair in the list of occupied orbital symmetry pairs (SymProds)
                If it is not there, then we do not need to worry about those orbitals - they do not have the right symmetry to interact with occ orbs in Di
                If it is there, loop over spin combinations, and find the number of orb pairs of this symmetry and spin combo.
                We need to remove pairs with one or both orbitals in Di
                To calculate the number of pairs of orbitals with one orbital in Di, we take the symmetry product of the occupied symmetry (SymProds(K))
                    with the inverse of each symmetry of occupied orbitals. For molecular systems, the inverse is simply the same as the original symmetry.
                    This product will tell us the symmetry of the virtual orbital which would be needed to make up the ab pair.
                    Since we know how many occ there are in each occ class, and can calculate how many virts there are in its complement, that gives us the number of 
                    'single excitations' masquerading as doubles. (ie pair has one orbital in Di)
                 In practice, this first involves looping over occupied classes - (iClass)
                 Find the symmetry product of the inverse of the occupied class (iClass) and the symmetry product that we are looking at.
                 Find the total number of states with this inverse symmetry from symlabelcounts and their symmetry

This algorithm will scale as NCL^2.
                 
SSE_CountSingles(nSing,nCl,nExcitTypes,*ClassCount,Classes)
-----------------------------------------------------------

This routine will calculate the number of single excitations available to the system. This can definately be improved for abelian symmetries
since then we can only interact between orbitals of the same symmetry. Currently, it uses the symmetry remainder info calculated in SSE_CreateClassList. 

Returned Values:

nSing               INTEGER     Number of allowed single excitations in the system

Current general algorithm:      Loop over symmetry classes (i)
                                Loop over symmetry labels of the system (j)
                                If the symmetry product of these is equal to the symmetry remainder of the class, then it can interact with this symmetry.
                                Loop over alpha and beta spins
                                Calculate number of single excitations possible

The current algorithm scales as NCL^3, but should be able to be reduced to NCL for abelian symmetry.

----------------------------------------------------

If we are in the setup phase, then NAllowPPS, OrbPairs and SymProdInd are deallocated, and STORE returned with the sizes of the arrays needed.

STORE(2)=(NExcitTypes*5)    -   For ExcitTypes (Allocated later)
STORE(3)=3*NSymPairProds    -   For NAllowPPS
STORE(4)=2*NPairs           -   For OrbPairs - is this still needed in Abelian symmetry?
STORE(5)=2*3*(NPR+1)        -   For SymProdInd

However, if we are not in the counting phase we go on to store the single and double excitations.


                                
                                

    

 
----
SSE_StoreSingles(nExcitTypes,nCl,Classes,ThisClassCount,ExcitTupes)

 Store singles classes          O(NCL^3)                  O(NCL^2)
                                  [ NSYM ]                 [ NSYM ]
----
SSE_StoreDoubles(nPr,nSymPairProds,nAllowPPS,ExcitTypes,nExcitTypes,SymProds,SymProdInd)
 Store doubles classes          O(NPR NSYM)               O(NPR^2)
                                  [ NSYM^2 ]               [ NSYM^2 ] 



                                       



