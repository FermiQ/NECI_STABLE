Usage:

neci.x inputfile > outputfile
OR
neci.x < inputfile > outputfile
(I prefer neci.x inputfile | tee outputfile if run interactively)
[or just neci.x inputfile > outputfile]

The input file is keyword driven and requires the minimal amount of information.  Some flags can only be used for certain calculations (or rather, are irrelevant for othert types of runs).  The order of input blocks is not important, nor is the order within a block, unless an option is only valid when a logical statement is true, in which case the relevant keyword for the logical statement must precede its related keywords.  I have imposed a block structure on the input file to aid readability.

General points to note:
* Parameters which follow a keyword ought to be on the same line as the keyword,but this isn't a strict requirement.
* A new line is required for each keyword, unless the keyword is an option of another keyword, in which case it ought to be on the same line.
* Blank lines are ignored.
* Comments are enclosed in brackets.
* Data items are terminated by space or comma.
* The input file is not case sensitive.
* Only the variables relevant to the desired run are required.
* Unknown keywords return an error message and stop the run.
* It is trivial to change the keyword or which block it's in.  Similarly, if it would be better to set some variables to be true by default, then it's easy to add to the routine such that it's possible to turn those options off as desired.
* Sensible defaults need to be set - this will reduce the amount of information currently required from the input file.

Keywords

Syntax:  Keywords are specified by capitals.  Options/data required after a keyword are in <angled brackets>.  Alternative options are separated by commas.

TITLE 
    Takes the rest of the line as the title and passes it to output.

SYSTEM <system type> [required]
    Starts system block.
    System types are:
                    READ,GENERIC
                    STARBINREAD
                    STARSTOREREAD
                    BINREAD
                    DFREAD
                    BOX
                    HUBBARD
                    UEG
                    CPMD
One of these must be specified.  If READ/GENERIC/STARBINREAD/STARSTOREREAD/BINREAD/DFREAD is followed by ORDER, then a quick HF calculation is performed to give an ordering of the orbitals read in (THFORDER = .true.).  If CPMD is followed by ORDER, then the CPMD orbitals are ordered, not according to their CPMD eigenvalues, but instead according to their one-electron energies (i.e. with no exchange or correlation). 
   DFREAD reads in a set of density fitted coefficients and coulomb integrals from files SAV_DFaSOL and SAV_Ta_INT (generated by SITUS).  One-electron integrals are read in from HONEEL, which also contains <ij|ij> and <ij|ji> integrals (generated by readintOCC.x). 
   STARSTOREREAD stores the TMAT elements as spatial orbitals in symmetry pairs, meaning that UHF is no longer available, but does save memory. UMAT size is also massivly reduced, to only store the <ij|ab> integrals, where i and j are occupied, as well as the <ii|jj> and <ij|ij> integrals over all states in the UMAT2D. This reduces the space requirements to N^2M^2/2 rather than M^4/8. This however can only be used for the 2v sum and the 2v star calculations.
    BINREAD means that the FCIDUMP file containing the molecular integrals to be read in, is in unformatted, and so the integrals are read in from this file.
    STARBINREAD means that only the STAR integrals are read in, as in the STARSTOREREAD, and that the file to read in from is also a binary file.
    
ELECTRONS,NEL <NEL> [required]

SPIN-RESTRICT <LMS> [default off.  default LMS=0]
    Turns spin restriction on, limiting the working space to the z-component of spin being LMS*2
    
CSF <STOT> [default off.  default STOT=0]
    If specified, work in CSFs rather than determinants.  CSFs might not function properly for some monte carlo, but should work for vertex sums and diagonalization.   STOT is twice the magnitude of spin to restrict the resultant space

SYM <SYM(I), I=1,3> <SYM(5)> [default off.  default SYM=(0,0,0,,0)]
   If specified, limit the working space to space with the specified symmetry quantum numbers.
   The final quantum number corresponds to the irrep symmetry.  If working in an Abelian group, this symmetry achieved is 2**SYM(5), which 
     corresponds to irrep SYM(5)+1.  SYM(5)=0 corresponds to the totally symmetric rep. This will not function without Abelian (1D) symmetry. 

STORE-AS-EXCITATIONS

    Currently only working for the 2v-STAR-LD calculations, this flag means that determinants are stored as a 4-integer list of orbitals excited from, and orbitals excited to, rather than as an N-integer list of the occupied orbitals in the determinant. This means that the scaling is reduced to N^2M^2 rather than N^3M^2, as we run through the list for each excitation.

USEBRILLOUINTHEOREM

   For the Hartree-Fock determinant exclude single excitations as disconnected.

CELL <NMAXX NMAXY NMAXZ> [required for HUBBARD, UEG, and BOX]
   Maximum basis functions for each dimension.  For HUBBARD and UEG, functions range from -NMAX to NMAX, but for BOX, they range from 1 to NMAX

MESH <NMSH> [default 32]
   Number of mesh points for integrals for BOX

BOXSIZE <BOX [BOA COA]> [BOX required for UEG, and BOX.  BOA, COA optional, default 1]
    Set lattice vector a, b and c, where b and c are defined as a ratio of a.

U <UHUB> [only needed for HUBBARD.  default=0]
B <BHUB> [only needed for HUBBARD.  default=0]
    Sets U (on-site repulsion) and B (hopping or kinetic energy) parameters for the Hubbard model.

ENERGY-CUTOFF EMax
    Reject basis functions with an (unscaled) energy larger than EMax.  Default off

EXCHANGE-CUTOFF [Rc]
   Sets cutoff distance Rc for the exchange electron-electron potential.  If Rc is not explicitly set, it will be set to be equivalent to a sphere of the same volume.  dRc=(dOmega/(4*PI/3))**(1/3.d0)

EXCHANGE-DAMPING [Rc]
   Sets cutoff parameter Rc for attenuated potential V(r)=erfc(r/Rc)/r).  If Rc is not explicitly set, it will be set to be equivalent to a sphere of the same volume.  dRc=(dOmega/(4*PI/3))**(1/3.d0)

COULOMB <FCOUL>
      Multiplies the strength of the coulomb interaction by FCOUL

EXCHANGE (ON|OFF) [default ON]
      Specify whether to include Exchange in the Slater-Condon rules.  If off, we are effectively 
         reduced to a using Hartree multi-electron wavefunctions rather than Slater determinants.
COULOMB-DAMPING ENERGY <FCOULDAMPMU FCOULDAMPBETA>
COULOMB-DAMPING ORBITAL <COULDAMPORB FCOULDAMPBETA>
      Damps the two-electron coulomb integrals, <a b || c d> with factor f(Ea)f(Eb)f(Ec)f(Ed)
      where f(E)=ERFC(BETA*(E-MU)).  Beta of 1 gives a damping range of 2.  Beta of 40 gives a damping range of 0.05
      ENERGY sets the MU manually.  ORBITAL sets MU half way between the energies of ORB and ORB+1
COULOMB-DAMPING is now disabled [26/7/06]


REAL        [HUBBARD ONLY}
APERIODIC   {HUBBARD ONLY]
    Hubbard model is set to be real space and/or not periodic.

TILT <ITILTX ITILTY> [HUBBARD only.  default off]
    System is tilted (Hubbard only?) and the unit vectors are (x,y)=(ITILTX,ITILTY) and (-y,x).  Requirement that x>= y.

ALPHA <ALPHA>
    Sets TALPHA=.true. and defines ALPHA.

BANDGAP
    Calculate for NEL, NEL+1, and NEL-1, and extract the band gap energy.

ENDSYS
    End system block.

PRECALC
    Start Precalculation block.  This chooses which weighting parameters to use in the main calculation block, in order to give minimum MC variance.  This is an optional input block, and is not required if the default parameters want to be used, or for them to be specified explicitly in the CALC input block.  Currently, (28/2/07), only the IMPORTANCE parameter, and the C EXCITWEIGHTING parameter can be optimised and parsed through the the main program. Now, (06/3/07), the a & b optimal parameters are searched for simultaneously.

VERTEX <HDIAG/RHODIAG> <SUM/MC>
    Similar to the methods section in the CALC block, this specifies a vertex level (from a vertex level of two), and the method that is to be used in searching for the best parameters, using the hamiltonian matrix diagonaltisation (HDIAG) or the RHO matrix diagonalisation (RHODIAG). After this is specified, on the same line, whether to calculate the expected variance from the full sum at this vertex level (SUM), or a Monte Carlo sum (MC) should also be specified.  Currently, (11/7/07), only the HDIAG routine works when performing a MC expected variance, though the rho diagonalisation now works with the full sum. Notation is:
        
        VERTEX HDIAG SUM
        XXX
        XXX
        VERTEX HDIAG MC
        XXX

If nothing is specified after this line, the optimum values of all the EXCITWEIGHTING variables will be found, but not parsed through to the main program.

CYCLES <CYCLES>
    This can only be applied to a vertex level which is specified to use the MC algorithm in the VERTEX line.  This give the number of graphs to generate in the MC algorithm, for each expected variance calculation in the parameter minimisation algorithm.

USE <MC_VERTEX_LEVEL_1> <MC_VERTEX_LEVEL_2> ...
    This will signify that the parameters calculated from this precalc vertex level, rather than any other, are to be parsed through and used in the main program when performing a MC at one of the vertex levels specified. Any given vertex level can only be specified once in all the USE statements.  Any vertex level in the main program, which isn't specified in one of the precalc USE statements, will use the parameters which are given in the main program block on the input file.  A USE statement on its own will only calculate the A and B EXCITWEIGHTING parameters, (or any of the other weighting scheme parameters specified) and use them for all MC vertex levels in the main program, unless FINDC or a UEPSILON is specified for the C parameter to also be used.

GRIDVAR <ExcitFromStart> <ExcitFromEnd> <ExcitFromStep> <ExcitToStart> <ExcitToEnd> <ExcitToStep>
    If this is specified for a precalc vertex level, a 3D map of the variance landscape will be produced, but the minimum will not be explicitly calculated. The A parameter start, end, and step must be specified, followed by the same for the B parameter.

LINEVAR <G_VMC_PIStart> <G_VMC_PIEnd> <G_VMC_PIStep>
    Same as GRIDVAR, but for a 1D line for one variable - currently only working for the IMPORTANCE parameter and the U-matrix element parameter, shows change in expected variance over a designated range of values. 

MEMORISE
    This indicates that all the graphs, their excitation generators, weights, energies, and unbiased probabilities should be stored in the memory.  This speeds up the calculation of the variance by ~2x, however, cannot be used for big systems.  ~31000 4v graphs, or 22000 3v graphs was the maximum for NN VQZ. This setting is currently only available for MC precalc. If this is not set, then only the first node excitation generators are stored - there should be enough memory for these.

NONE
    This is to specify that no calculations or optimisations are to be performed on this vertex level.

TOLERANCE <TOLERANCE>
    The fractional precision to which the optimum parameter is obtained, using the minimisation method. Default value is 0.1

UEPSILON <UEPSILON>
    Since the calculation of the U matrix elements can be time-consuming in a real MC simulation, the optimum C EXCITWEIGHTING parameter found from the PRECALC algorithms may not want to be parsed through to the main MC program if the reduction of the expected variance from the case where the C EXCITWEIGHTING coefficient is zero, to the optimum value, is small.  If this option is set, it will find the optimum C EXCITWEIGHTING parameter, but will parse through a value of zero if the reduction in expected variance between the optimum value, and that of C = zero, is less that UEPSILON.  This will then save time in the full MC simulation.  The default value is 0 (i.e. the optimum value will always be used in the main program).

FINDC
    The optimum C EXCITWEIGHTING parameter will only be found if this flag is set, or if a UEPSILON is set, otherwise, the optimisation will only seek to find the values which give the minimum expected variance by varying the A and B EXCITWEIGHTING parameters, (or the parameters in another weighting scheme specified).

FINDD
    The optimum D EXCITWEIGHTING parameter will be found for this vertex level (g_VMC_ExcitToWeight2).

USED
    The optimum D EXCITWEIGHTING parameter found at this vertex level will be passed through to the main program.

FINDIMPORT
    This flag will run the optimisation algorithm for the IMPORTANCE parameter.  The optimised value will be found and output to stdout, but will not be parsed through to the main calculation block.  This flag can only be set for a vertex level of three or higher for obvious reasons.

USEIMPORT
    This flag will not only find the optimal IMPORTANCE parameter, but will also parse it through to the main program, to be used there. Again, for obvious reasons, this flag can only be set for vertex levels of three or higher.

TRUECYCLES <No.of cycles>
    If this is specified, then this indicates the total number of cycles that we want to use in the main program.  The precalc will then automatically split these cycles between the levels in the main program, according to how the use statements indicate the parameters are to be split.  This will split the cycles in the way to best minimise the overall variance of the run, under the assumption that the variance of the whole run is simply the sum of the variances of the individual vertex results.

TOTALERROR <Desired Error from main program>
    This calculates the required number of cycles, so that the final error from the simulation is equal to the error given.  This will only work if the precalc levels go as high as the full program MC levels, i.e. the highest MC vertex level is independantly optimised for. The precalc also calculates the optimum vertex splitting. 

PREGRAPHEPSILON <PREWEIGHTEPS>
    This gives a threshold above which the weight of a graph must come if they are to be included in the full precalc variance calculation. If the graph weight comes below this, then the probability of obtaining the graph does not need to be calculated, and so the optimisation routine is faster. Default is 1E-8.

ENDPRECALC
    This ends the PRECALC input block.
    
CALC
    Start calculation block.  This chooses what calculation to do.

HAMILTONIAN [STAR]
    Store the Hamiltonian.  This is defaulted to ON if ENERGY is set, but can be used without ENERGY.
      STAR indicates only the connections between the fermi det and its excitations should be included in the Hamiltonian, not off-diagonal elements between excited dets.

EXCITE <ICILEVEL> [default=0]
   Excitiation level at which to truncate determinant list.  If ICILEVEL=0 then all determinants are enumerated.

ENERGY
    Calculate the energy by diagonalising.  Requires that one of COMPLETE, LANCZOS, or READ be set.

COMPLETE
    Do a full diagonalisation working out all eigenvectors and eigenvalues.  if HAMILTONIAN is OFF, this throws away the eigenvectors and eigenvalues after having used them for calculation.  Relevant parameters are HAMILTONIAN and BLOCK

BLOCK <ON,OFF>
    Determines whether the Hamiltonian is calculated for each block or not.  This only works for COMPLETE 

READ
    Read in eigenvectors and eigenvalues from a previous calculation.

LANCZOS
    Do a Lanczos block diagonalisation.  The relevant parameters are BLOCKS, KRYLOV, ACCURACY, STEPS, EIGENVALUES

EIGENVALUES <NEVAL>
    Required number of eigenvalues.

BLOCKS <NBLK>
    Set number of blocks in Lanczos routine.

KRYLOV <NKRY>
    Set number of Krylov vectors.

ACCURACY <B2L>
    Desired level of accuracy for Lanczos routine.

STEPS <NCYCLE>
   Sets the number of steps in the Lanzcos routine.

POSITION <IOBS JOBS KOBS>
   Sets the position of the reference particle.

WORKOUT <NDETWORK>
   Sets the number of determinants which are worked out exactly.

TROTTER
   Perform a Trotter decomposition.

BETA <BETA>
   Set BETA.

BETAOVERP <BETAP> default= 1.d-4
   Set BETA/P.

TIMESTEPS <I_P>
   Set p, the timesteps into which exp(- Beta H) is split.  Automatically sets BETA/P=0 (as required) but returns an error message if BETA/P is also set.

DELTABETA <DBETA>
   Set delta_beta.  If a negative value, calculates exactly.

RHOEPSILON <RHOEPSILON>
   Set the minimum significant value of RHO (as a fraction of RHOIIMAX).

GRAPHEPSILON <GRAPHEPSILON>
   Set the minimum significant value of the weight of a graph. Default 0.D0
   If the magnitude of the weight is smaller than this, both the weight, and E~ contribution are set to zero.

PGENEPSILON <PGENEPSILON>
   Set the minimum significant value of the generation probability of a graph. Default 0.D0
      Because for larger graphs, the calculation of the generation probability is subject to numerical
   truncation errors, pgens which are lower than a certain value are unreliable, and can cause the MC to 
   get stuck (if e.g. pgen were very small, it would be difficult for an MC run to leave that graph).
   If the magnitude of the pgen is smaller than PGENEPSILON, the a new graph is generated.
      Setting this too high could cause the code to get stuck in the graph generation phase,
   so the program will exit if it generates 10000 successive graphs with pgen too low.

EXCITATIONS OLD,NEW
   For generation of up to double excitations use the old (completely reliable), or new
   (faster, but does not work for more than 2-vertex level SUMS) routine

METHODS
   Begin a METHODS BLOCK.  This allows a different method for each vertex level.
   Each vertex level can contain EXCITATIONS, VERTICES, CYCLES and CALCVAR keywords
   The block terminates with ENDMETHODS
   e.g.

      METHODS
         METHOD VERTEX SUM NEW
         EXCITATIONS DOUBLES
         METHOD VERTEX STAR POLY
         EXCITATIONS SINGLES
         VERTICES 2
      ENDMETHODS

   Sets the first method, at a two-vertex level, to be a complete 2-vertex sum of only doubles,
     and the second method, overriden to be also at  the two-vertex level, to be a vertex star 
      of singles.

VERTICES
   Only usable in a methods block.  By default, each method takes a number of vertices corresponding to its
     index within the methods block, the first methods corresponding to the 2-vertex level, the second to the 
     3-vertex level etc. .  VERTICES overrides this, and allows you to specify the vertex level of each method, 
     allowing, for example, to split the 2-vertex level into doubles and singles which are handled separately.

CALCVAR
   This calculates a theoretical approximation to the expected variance if a non-stochastic MC run were to be performed, with the parameters given, at the chosen vertex level.  Currently the expected variance is output to stdout, and now as a full variance for the total energy ratio.  This option means the calculation takes longer since the Pgens of the graphs must all be calculated.  This option can only be used when calculating a full sum at the vertex level, using the HDIAG subroutine. This option will also output a value for the sum of the Pgens of the graphs, for each vertex level.  This should equal 1, since we are woking with normalised probabilities.

ENDMETHODS
   Terminate a methods block

EXCITATIONS SINGLES,DOUBLES
   Limits excitations in METHOD VERTEX SUM NEW to only singles or doubles.
EXCITATIONS FORCEROOT
   Force all excitations in a VERTEX SUM NEW to come from the root.
EXCITATIONS FORCETREE   
   Disallow any excitations in a VERTEX SUM NEW which are connected to another in the graph, forcing a tree to be produced.  Not all trees hare produced however.

METHOD <METHOD>
    Specify the method for vertex summation routine.  Options currently are:
    VERTEX SUM OLD,NEW,HDIAG [SUB2VSTAR] [LOGWEIGHT]
        Use the old, new, or H-diagonalizing vertex sum subroutine.
         SUB2VSTAR also removes paths which were present in the 2-vertex star for each graph.  If this is specified for ANY vertex level, it applies to all SUM and MC vertex levels.
         LOGWEIGHT forms Q as a multiplication of factors from graphs.  This results in the quantity log w being used instead of w, which also translates to the energy expression only involving E~ not weights.  Hopefully this is size-consistent.
    VERTEX MC|MCMETROPOLIS|MCDIRECT|MCMP [HDIAG]
        Monte Carlo procedure.
        MCDIRECT
            Perform direct stochastic sampling for the PI method, dividing each freshly generated graph by its normalized generation probability.
            If MULTIMCWEIGHT is specified then the sampling generates graphs from all weighted levels using the weighting - a single MC calculation is performed.
            If MULTIMCWEIGHT is not specified (default), a separate MC calculation is performed at each vertex level.  Combined statistics are printed.
        MCMP
            Perform direct stochastic sampling as above, but for the MP method.
        MC or MCMETROPOLIS
            Perform Metropolis Monte Carlo.  
        This may be performed in a number of ways (The way is chosen by the location of the VERTEX MC command).  STOCHASTICTIME may also be specified to perform stochastic time simulations with a given BIAS
           SINGLE
            MC is performed at a single vertex level using a composite 1-vertex graph containing a full sum previously performed.  
            BIAS is used to choose whether a step selects a composite (all lower levels) or a normal (this level) graph.  Stochastic time MC is performed. This can only be specified in the METHODS section, and only at the last vertex level.  Uses EXCITWEIGHTING for excitation generation weighting and IMPORTANCE for graph generation weighting
           MULTI
            MC is performed at a multiple vertex levels, but still using a composite 1-vertex graph containing a full sum previously performed. MULTI should be specified in all the (contiguous) vertex levels to be included (not composited) in the MC.  
            BIAS is used to choose whether a step selects a composite (all lower levels) or a normal (the MULTI levels) graph.  MULTIMCWEIGHT is specified for each MULTI level, and gives a relative weighting of selecting the vertex level graphs once a non-composite graph is chosen.  Stochastic time MC is performed.  This can only be specified in the METHODS section.  Once MULTI has been specified, it must be specified on all subsequent vertex levels in a METHODS section.  Uses EXCITWEIGHTING for excitation generation weighting and IMPORTANCE for graph generation weighting
           FULL
            Does  MC at all levels using BIAS to bias the levels, EXCITWEIGHTING for excitation generation, and IMPORTANCE to for graph generation weighting.  This is only available WITHOUT a METHODS section

         If HDIAG is specified, the H-diagonalizing routine is used, otherwise, the rho-diagonalizer is used.  HDIAG is automatically specified for MCMP.

    VERTEX SUM READ
        Read in from pre-existing MCPATHS file for that vertex level [Only really useful in a METHODS section]
    VERTEX STAR [ADDSINGLES/COUNTEXCITS/STARPROD] DIAG,POLY,POLYMAX  <OLD, NEW [H0]>
        Constructs a star from all determinants connected to the root (ignoring connections between those dets).
        DIAG does a complete diagonalization on the resultant matrix.  This can be very slow.
        POLY uses the special properties of the matrix to find the roots of the polynomial and uses them to calculate the relevant values.  This is order Ngraph**2
        POLYMAX is POLY but only finds the highest root of the polynomial, so is order Ngraph.  It can be used when P is very large (i.e. BETA is very large (say 40))
        POLYCONVERGE is poly but adds i out of N roots lambda_i such that (N-i) lamba_i**P < 10**-3, i.e. we evaluate enough roots such that a very conservative error estimate of the contribution of the remaining roots is negligible.
        POLYCONVERGE2 is POLYCONVERGE but requires   w(1..i) (N-i) lamba_i**P < 10**-3, where w(1..i) is the cumulative sum of lambda_i**P, which should be a better estimate of the convergence
        OLD specifies to use a pre-generated list of determinants using the excitation routine version 
               specified in EXCITATIONS OLD,NEW.
        NEW specifies to generate determinants on the fly without storing them, using the NEW excitation routine.
        NEW H0 uses the zeroth order N-particle Hamiltonian (shifted such that H0_ii = H_ii) rather than the fully interacting Hamiltonian to generate the roots of the polynomial.
        ADDSINGLES specifies to add the singles which are en-route to each double to that double as spokes, and prediagonalize them.  i.e. if the double is (ij->ab), then singles (i->a),(i->b),(j->a) and (j->b) are created in a star with (ij->ab), the result diagonalized, and the eigenvalues and vectors used to create new spokes.  Only works with NEW
        COUNTEXCITS runs through all the symmetry allowed excitations first, and counts the connected determinants on the star. This means that memory requirements are reduced so that only connected determinants are stored. However, the time taken is increased, as it is necessary to run through all determinants in the star twice. Especially useful for large systems with memory restraints, when density fitting has necessarily turned off symmetry. Also useful if a largeish rhoepsilon has been set as these will be counted as disconnected.
        STARPROD includes approximations to all products of excitations in the star graph - an experimental test of size consistency. This only works with DIAG option, and scales badly.

CYCLES <NWHTAY(1,1)>
    Specifies the number of cycles of the MC routine.

MAXVERTICES <I_VMAX>
    Set the vertex level.

VVDISALLOW
   Disallow V-vertex to V'-vertex transitions in stochastic time MC.
MCDIRECTSUM
   Monte Carlo on graphs summing in energies weighted with weight/pgen.
MPTHEORY
   Instead of a normal path-integral expansion MC, do a Moller Plesset MP.  Requires HDIAG, and BIAS=0.D0.  Can be used without a METHODS section.  If a METHODS section is needed to specify different numbers of cycles at each level, then MCDIRECTSUM must also be set.
EPSTEIN-NESBET
   Will do Epstein-Nesbet perturbation theory, rather than Moller-Plesset.  Only works for VERTEX SUM NEW HDIAG and only at 2v level.

LADDER
   Will do ladder diagram perturbation theory, rather than Moller-Plesset.  Energy denominator is E_0-E_I+|H_0I|^2  Only works for VERTEX SUM NEW HDIAG and only at 2v level.

MPMODTHEORY
   A hybrid of Epstein-Nesbet and MP theory, which includes only the <ij||ij>+<ab||ab> terms in the denominator.  Works only for VERTEX SUM NEW HDIAG and only at 2v level.

IMPORTANCE <G_VMC_PI> 
    Set the generation probability for the MC routine.  This is the probability that new determinants are excitations of the pivot, i
     The default 0.95.
STARCONVERGE <STARCONV>
    Set the convergence criteria for whether a roots to the star graph is significant. Default is 1.d-3
SEED <G_VMC_SEED>
    Random seed required for the MC routine.  This should be negative.  The default is -7

BIAS <G_VMC_FAC>
    Level bias for the FULL MC routine. Positive biases toward larger graphs.  Negative towards smaller
        The default is 16.
    For a SINGLE and MULTI level MC (using a composite 1-vertex graph containing a full sum previously performed), this is the probability of generating
     a graph which is not the composite graph.  The default is invalid, and this must be set manaully.  Stochastic time MC is used
      If BIAS<0, |BIAS| is used, but stochastic-time MC is not performed

UFORM-POWER
    New power form for the U-matrix element weighting using the appropriate EXCITWEIGHT element, which is believed to be better. This uses the form W=U**EXCITWEIGHT, rather than the exponential form.

EXCITWEIGHTING <g_VMC_ExcitFromWeight g_VMC_ExcitToWeight G_VMC_EXCITWEIGHT> [g_VMC_ExcitToWeight2]
   A weighting factor for the generation of random excitations in the Vertex MC.  Default for all is 0.D0 (meaning unweighted, where the weighting factors for that process are set to 1.).
      The probability of choosing pair ij is proportional to exp((e_i+e_j)*g_VMC_ExcitFromWeight)
      The probability of choosing pair kl is proportional to exp(-(e_k+e_l)*g_VMC_ExcitToWeight) exp(|<ij|U|kl>|*G_VMC_EXCITWEIGHT) *abs(e_i+e_j-e_k-e_l)**g_VMC_ExcitToWeight2

POLYEXCITWEIGHT <g_VMC_ExcitFromWeight g_VMC_PolyExcitToWeight1 g_VMC_PolyExcitToWeight2 G_VMC_EXCITWEIGHT>
    A new weighting system for the choice of virtual orbitals in the excitations.  Default for all is 0.D0 (meaning unweighted, where the weighting factors for that process are set to 1.).
    The probability of choosing pair kl in this scheme, is constant up to the point where (e_k+e_l) is less than g_VMC_PolyExcitToWeight1, and then as the energy of the virtual orbitals increases further, the weighting goes as a decaying polynomial as 1/((e_k+e_l)-g_VMC_PolyExcitToWeight1+1)^g_VMC_PolyExcitToWeight2. g_VMC_PolyExcitToWeight1 is constrained to be not more than the energy of the highest virtual orbital.

POLYEXCITBOTH <g_VMC_PolyExcitFromWeight1 g_VMC_PolyExcitFromWeight2 g_VMC_PolyExcitToWeight1 g_VMC_PolyExcitToWeight2 G_VMC_EXCITWEIGHT>

    This weighting system is the same as the previous weighting system, apart from the fact that now the polynomial weighting function applies also to the occupied orbitals.  This means that there is another variable, since now the 'ExcitFrom' calculation also needs a value for sigma, and for the exponent.  The sigma variables are now both under similar constraints as specified above, which means that they cannot be larger or smaller than the highest and lowest energy orbital respectivly.  This prevents the PRECALC block from getting stuck, or from finding local variance minima.

CHEMPOTWEIGHTING <g_VMC_PolyExcitFromWeight2 g_VMC_PolyExcitToWeight2 G_VMC_EXCITWEIGHT>
    A new weighting system, with the same form as POLYEXCITBOTH, apart from the fact that sigma is now constrained to be at the chemical potential of the molecule.  This means that there are now only two parameters with which to minimise the expected variance.

CHEMPOT-TWOFROM <g_VMC_ExcitWeights(1) g_VMC_ExcitWeights(2) g_VMC_ExcitWeights(3) G_VMC_EXCITWEIGHT>
    When choosing the electron to excit, this weighting system has a growing polynomial up to the chemical potential, but now also a decaying one after this, to encourage mixing of the configurations around the HF state. However, this does mean that there are now three adjustable parameters, and testing needs to be done to see if this is beneficial. This is expected to make more of a difference as the vertex level increases.

MULTIMCWEIGHT <g_

PATHS (<NPATHS> | ALL | ACTIVE [ORBITALS nDown nUP | SETS nDown nUp])
    Choose the first NPATHS determinants and calculate RHOPII etc.
      ALL chooses all determinants (same as ALLPATHS).
      ACTIVE chooses only the active space of determinants: The degenerate set containing the highest energy electron.
      ACTIVE ORBITALS nDown nUp   Set the active space to be nDown and nUp orbitals respectively from the Fermi level
      ACTIVE SETS nDown nUp   Set the active space to be nDown and nUp degenerate sets respectively from the Fermi level

ALLPATHS
    Choose all determinants (i.e. set NPATHS = -1).

ENERGY
    Also calculate the energies for NPATHS determinants.  This option required delta_beta to be positive.

CIMC
    Perform a CI space Monte Carlo.

STEPS <IMCSTEPS>
    Set the number of steps for the CI space Monte Carlo routine.

EQSTEPS <IEQSTEPS>
    Set the number of equilibriation sets for the CI space Monte Carlo routine.

BETAEQ <BETAEQ>
    Set the value of beta for equilibriation steps.  The default value is zero, in which case the value of BETA, above, is used.

DETSYM <MDK(I), I=1,4>
    Specify the symmetry of the CIMC determinant.

**If any if the CIMC options are set without CIMC being specified, the code will return an error and exit.**

DETINV <DETINV>
    Specify the determinant for which the complete vertex series is worked out.  If DETINV is negative, the NPATHS calculations are started at this determinant.

ENDCALC
   Ends the calculation block.

INTEGRAL
   Starts the integral block.
HF
    Use a HF basis.

CALCULATE      
    Calculate the HF basis rather than reading it in.

MAXITERATIONS <NHFIT>
    Set the maximum number of HF iterations.

MIX <HFMIX>
    Set the mixing parameter for each HF iteration.

THRESHOLD < ENERGY<HFEDELTA> ORBITAL<HFCDELTA> >
    Set the convergence threshold for the energy and/or the orbitals.

RHF
    Use restricted Hartree-Fock theory.

UHF
    Use unrestricted Hartree-Fock theory.
      
HFMETHOD <HFMETTHOD>
    Specify the method for the Hartree-Fock routine.  Options are:
    STANDARD
        Use normal HF process.
    DESCENT <SINGLES,OTHER>
        Use singles or other gradient descent.
    MODIFIED
        Modify virtuals - under test

READ <MATRIX BASIS>
    Read in U matrix and/or HF basis.
     
FREEZE <NFROZEN NTFROZEN>
    Set the number of frozen core states and frozen excited states respectively.  Both must be a multiple of two - an error is returned if this is not the case.

INSPECT <SPECDET(I), I=1,NEL-NFROZEN>
    Investigate the specified determinant.

ORDER <ORBORDER(I), I=1,8)>
    Set the prelimanary ordering of basis functions for an initial guess at the HF determinant.
    There are two ways of specifying open orbitals.
      1)  If orborder2(I,1) is integral, then if it's odd, we have a single.
      2)  Non-integral.  The integral part is the number of closed oribtals,
         and the fractional*1000 is the number of open orbitals.
            e.g. 6.002 would mean 6 closed and 2 open
            which would have orborder(I,1)=6, orborder(I,2)=4
            but say 5.002 would be meaningless as the integral part must be a
            multiple of 2

UMATCACHE nSlotsInit (default 1024)
UMATCACHE SLOTS nSlotsInit
   For CPMD-generated 2-electron integrals, set the number of slots per state-pair of cache to reserve.  The total amount of cache will be in the order of NSLOTS*NSTATES*(NSTATES-1)/2  words.  If 0 then disable on-the-fly cacheing, but retain precomputation of 2-index 2-electron integrals.  If -1, calculate all integrals on the fly.
UMATCACHE MB nMemInit
   Number of megabytes to allocate to the UMAT cache.
UMATCACHE [READ|DUMP|FORCE]
   READ: Read in UMatCache from CacheDump (if it exists).
   DUMP: Print out UMatCache to CacheDump, unless have read in CacheDump from a larger calculation.
   FORCE: Force the over-write of CacheDump, even if read in CacheDump from a larger calculation.

NOUMATCACHE
   Disable all UMAT caching (same as UMATCACHE -1).  To use UMAT2D and *not* UMATCACHE, set UMATCACHE 0.
   
FOCK-PARTITION
   For calculation of Rhos with Trotter, Partition the Hamiltonian according to the N-electron Fock operator and coulomb perturbation
FOCK-PARTITION-LOWDIAG
   For calculation of Rhos with Trotter, Partition the Hamiltonian according to the N-electron Fock operator and coulomb perturbation.  Only take the first order approximation to the diagonal terms (i.e. no BETA/P term)
FOCK-PARTITION-DCCORRECT-LOWDIAG
   For calculation of Rhos with Trotter, Partition the Hamiltonian according to the N-electron Fock operator and coulomb perturbation.  Remove the coulomb double counting in the Fock Operator. Only take the first order approximation to the diagonal terms (i.e. no BETA/P term).
DIAG-PARTITION
   (default) For calculation of Rhos with Trotter, Partition the Hamiltonian as the diagonal and non-diagonal matrix elements between the determinants
RHO-1STORDER
   Calculate rho elements to only 1st order taylor (without trotter etc.)

DFMETHOD meth
control the Density fitting method.  Possible values of meth are
!Some possible DFMethods sums over P, Q implied.  All precontracted to run in order(X) except DFOVERLAP2NDORD
 
! DFOVERLAP        1 - (ij|u|ab)= (ij|u|P)(P|ab)
! DFOVERLAP2NDORD  2 - (ij|u|ab)= (ij|u|P)(P|ab)+(ij|P)(P|u|ab)-(ij|P)(P|u|Q)(Q|ab)
! DFOVERLAP2       3 - (ij|u|ab)= (ij|P)(P|u|Q)(Q|ab)
! DFCOULOMB        4 - (ij|u|ab)= (ij|u|P)[(P|u|Q)^-1](Q|u|ab)

RFCONV <RFCONV>
    Set the convergence criteria for the Regular falsi algorithm in findroot. This is to only be used with a star calculation which involves calculating the roots of a polynomial to find the eigenvalues. Default is 1.D-08. A Newton-Raphson convergence takes place after.

NRCONV <NRCONV>
    This sets the convergence criteria for the Newton-Raphson algorithm in findroot. This takes place after initial bounds for the root are calculated using regular falsi (see above). Default is 1.D-13, and values smaller than 1.D-15 tend to create a fault since the NR cannot converge given the number of iterations allowed.

NRSTEPSMAX <NRSTEPSMAX>
    This sets the maximum number of Newton Raphson steps allowed to try and converge upon a root to the accuracy given in NRCONV. This is only applicable for the star graph, when trying to find the roots of the polynomial using POLY NEW/OLD or POLYCONVERGE. Default value is 50.

INCLUDEQUADRHO
    This changes the rho matrix for stars so that it includes the square of the eigenvalues - rho -> rho + rho^2/2. This is in an attempt to improve size consistency for the star graph. No change for large beta, and only very small changes for smaller betas.

EXPRHO
    The rho matrix is exponentiated, 1 is subtracted, and this is used as the matrix to be diagonalised. This is the full expansion for which INCLUDEQUADRHO is a truncation. Again, this is used to achieve size consistency with the star, although seems to have little effect, and no effect at high beta.

CALCREALPROD
    Another experimental high-scaling size-consistency experiment, which works in conjunction with STARPROD on the METHOD line, to calculate all the products of the star excitation. The product excitation of the star will consist of all quadruple excitations which are products of two double excitations, where the moving electrons are distinct in the two constituent excitations. The off-diagonal elements will then be approximated for the product excitation, by the 'other' constituent excitations rhoij element, unless CALCRHOPROD is specified, whereby the off-diagonal rho matrix elements will be calculated exactly.

CALCRHOPROD
    This calculates the rho matrix elements for the product excitation exactly.

QUADEXCITSTAR
    This creates the product excitations, but directly couples them to the root determinant, with a transition element given by the product of the transition elements which create the product. Hamiltonian elements to these products are zero however.

SUMPRODII
    More experimental code to test size-consistency, whereby rhoelements for the products are resummed back into the root, and the transition elements to the excited determinants.

ENDINT
    End of integral block.

LOGGING
    Start of logging block.
     
MCPATHS     
    Log in MCPATHS to MCPATHS for full vertex sum and MCSUMMARY when using a METHODS section.  Also log to RHOPII

PREVAR
    Log the Vertex level, Iteration number, parameter, and expected variance, for each parameter which was looked for in the PRECALC block, showing the convergence on the optimum value.  This is output to a file called PRECALC.

BLOCKING
    Perform a blocking analysis on the MC run.  This will only make a difference if a MC run is being performed, rather than a full sum. An MCBLOCKS file will be produced, which lists log(2)[blocksize], the average of the blocks, the error in the blocks(where the blocks are the energy ratio), and the full error, treating the energy estimator as a correlated ratio of two quantities.
    
FMCPR <LABEL,RHO,1000,EXCITATION>
    Log the following to PATHS.
      LABEL
         Logs each graph's v determinants as they are generated in this format:
            [(D0),(D1),...,(Dv),]
          where each determinant is a comma separated list of orbital indices e.g. (D0) = (    1,    2,    9,   10,) .
          If CSFs are being used, then the CSF is printed (see end note).  There is no newline after this.
          For MULTI or SINGLE MC, only the non-composite graphs are printed.

      EXCITATION
         Log in excitation format instead of full format above.  Format is
            [A(    i,    j)->(    a,    b),B(    k,    l)->(    c,    d),...,C(    m,    n)->(    e,    f)]
            where A, B, ... C are determinants in the graph from which the excitation is made. 
                  i, j, ... are the orbitals within that determinant which are excited from (i<j, k<l, ...)and
                  a, b, ... are the orbitals they are excited to (a<b, c<d, ...).
            This format does not in general provide a unique way of specifying multiply connected graphs, but the
             first possible determinant to which the next det in the graph is connected is chosen, so what is output should be unique.
               Single excitations are written as e.g. A(    i,    0)->(    a,    0),
      RHOS
         Log the rho matrix for the graph in this form: (r11, r12, ..., r1v,| r21, r22, ..., r2v,| ... | rv1, rv2, ..., rvv,|) 
         A newline is appended.
      XIJ
         Log the xij matrix, with the generation probabilities of one determinant in the graph from all the others.  For MC this is already generated, but for full sums this must be generated, so will be slower.  Generation probabilities are set with the EXCITWEIGHTING option.
         Format is
         { x11, x12, ..., x1v,| ... | xv1, xv2, ..., xvv,| }
         In general xij != xji.  the xkk element lists the number of possible excitations from det k.
         The matrix is followed by a newline.
      
      After all these possible options, the following are printed:
            Weight [pGen] ETilde*Weight Class [Accepted]
         pGen is only printed for: Monte Carlo, or if doing a full sum and the XIJ logging option is set.
         Accepted is only printed for the MC
         A newline is placed at the end.
      For MC, the values printed depend on the options.
         If LABEL is set, then the GENERATED graph and its values are printed.
         Otherwise, the ACCEPTED graph's values only are printed.

XIJ
   The same as FMCPR XIJ

CALCPATH <LABEL,RHO>
    Log in CALCPATH_R to PATHS.  Either just label logging or also log RHOIJ.


HAMILTONIAN      
    Log HAMIL and PSI and PSI_LONG.

PSI
    Log PSI_COMP.

VERTEX <n EVERY>
    Log vertex MC with E~ every n (real) cycles and/or log vertex MC contribution every cycle.  Delta=ETilde-ETildeReference (usually the 1-vertex graph)
      EVERY:
       write a VMC file with the following info, with a new line each time the current graph changes
         tot # virt steps, # steps in this graph, #verts, Class, Weight, Delta, <sign(W)>, <Delta sign(W)>, ~standard deviation <Delta sign>/<sign>,pgen 
      n:
       write a VERTEXMC file with the following info:
         0, #graphs, <sign(W)>, stdev(sign(W)), <Delta>, <sign Delta>/<sign>, <Delta^2>, acc ratio, trees ratio, nontree+ ratio, non-tree- ratio, <Delta sign(W)>, E~ reference, #sequences,w reference

HFBASIS
    Log HFBASIS.

TIMING <iGlobalTimerLevel> (default 40)
   Timing information is only recorded for routines with level <=iGlobalTimerLevel.  <10 means general high level subroutines. >=50 means very low level.  Routines without a level are always timed (most of them).

ENDLOG
    End of logging block.

END
    End of input file (not necessarily required, unless there is text after the input (e.g. comments or notes) which are not parenthesised.


End Notes

CSFs

CSF code is mostly functional, but only operates with spin csfs (not symmetry ones), and  only with the OLD excitation generator.
CSFs are generated using a branching diagram, and decomposed into determinants when hamiltonian elements are required.
CSFs are printed thus: (CLOSED, OPEN).  CLOSED is a list of orbitals in closed shells
            OPEN is a list of open shell orbitals, along with an encoded Ms values and an S generation string (see csf.F)
               e.g. (    1,    2,   13,   14,  7+B,  9+B, 19-A, 23-A,) has (1,2) and (13,14) spin-orbital pairs doubly occupied
                 and (7,8) and (19,20) each singly occupied.  BBAA corresponds to an Ms=0 state (two beta, two alpha) (these labels are always B...BA...A).
                 ++-- corresponds to 2S=+1+1-1-1=0 and with the ++-- generation combination (see branching diagrams).  The other possible
                 combination would be +-+- (the partial sums can never go below 0, so e.g. +--+ is not allowed)
