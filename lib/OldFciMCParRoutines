!This routine will move walkers between the processors, in order to balance the number of walkers on each node.
!This could be made slightly faster by using an MPI_Reduce, rather than searching for the min and max by hand...
!For rotoannihilation, this will balance the *Determinants* over the processors, not the particles themselves.
    SUBROUTINE BalanceWalkersonProcs()
        INTEGER :: i,ProcWalkers(0:nProcessors-1),error
        INTEGER :: MinWalkers(2),MaxWalkers(2)      !First index gives the number, second the rank of the processor
        REAL*8 :: MeanWalkers,MidWalkers
        INTEGER :: WalktoTransfer(4)                !This gives information about how many walkers to transfer from and to
        INTEGER :: Transfers        !This is the number of transfers of walkers necessary
        INTEGER :: IndexFrom,IndexTo,j,Stat(MPI_STATUS_SIZE),Tag,l

        Tag=123         !Set tag for sends
!        CALL MPI_Barrier(MPI_COMM_WORLD,error)

        IF(iProcIndex.eq.root) THEN
            WRITE(6,*) "Moving particles/determinants between nodes in order to balance the load..."
        ENDIF
        
!First, it is necessary to find the number of walkers on each processor and gather the info to the root.
        CALL MPI_Gather(TotWalkers,1,MPI_INTEGER,ProcWalkers,1,MPI_INTEGER,root,MPI_COMM_WORLD,error)
        Transfers=0
        WalktoTransfer(4)=100           !Set to large number to get ball rolling...

        do while(WalktoTransfer(4).gt.1)    !This is the range of walkers accross the processors. Continue reducing it until it is 1.
                
!            do j=1,TotWalkers+3
!                WRITE(6,"(8I4)") CurrentDets(:,j)
!                CALL FLUSH(6)
!            enddo

            IF(iProcIndex.eq.root) THEN
!Let the root processor go through and decide which walkers to move from where...
!Initialise variables with the root processors own values
!                WRITE(6,*) "PROCWALKERS: ",ProcWalkers
!                CALL FLUSH(6)
                MaxWalkers(1)=ProcWalkers(0)   !This should be the same as the totwalkers on the root node.
                MaxWalkers(2)=0                !This indicates that currently the maximum number of walkers resides on the root node
                MinWalkers(1)=ProcWalkers(0)
                MinWalkers(2)=0
                MeanWalkers=REAL(ProcWalkers(0),dp)
                do i=1,nProcessors-1
!Find the minimum, maximum and mean of the walkers accross the nodes, and their node
                    IF(ProcWalkers(i).gt.MaxWalkers(1)) THEN
                        MaxWalkers(1)=ProcWalkers(i)
                        MaxWalkers(2)=i
                    ELSEIF(ProcWalkers(i).lt.MinWalkers(1)) THEN
                        MinWalkers(1)=ProcWalkers(i)
                        MinWalkers(2)=i
                    ENDIF
                    MeanWalkers=MeanWalkers+REAL(ProcWalkers(i),dp)
                enddo
                WalktoTransfer(4)=MaxWalkers(1)-MinWalkers(1)
                IF(Transfers.eq.0) THEN
                    WRITE(6,*) "Initial range of walkers/dets is: ",WalktoTransfer(4)
                ELSE
!                    WRITE(6,*) "After ",Transfers," walker transfers, range of walkers is: ",WalktoTransfer(4)
                    IF(Transfers.gt.(10*(nProcessors**2))) THEN
                        CALL Stop_All("BalanceWalkersonProcs","Too many transfers required to balance nodes - Problem here...")
                    ENDIF
!                    CALL FLUSH(6)
                ENDIF
!                WRITE(6,*) "TOTAL WALKERS = ",MeanWalkers
!                CALL FLUSH(6)
                MeanWalkers=MeanWalkers/REAL(nProcessors,dp)
!                WRITE(6,*) "MEAN WALKERS = ", MeanWalkers
                MidWalkers=REAL((MaxWalkers(1)+MinWalkers(1)),dp)/2.D0  !THis is the mean of the two processors to exchange walkers

! Now it is necessary to decide what walkers go where...want to transfer from maxwalkers to minwalkers
! i.e. want to transfer walkers from MaxWalkers(2) to MinWalkers(2). The number to transfer is given by 
! min[ abs(maxwalkers(1)-MidWalkers), abs(minwalkers(1)-MidWalkers) ]
! Then we want to update ProcWalkers on the root and recalculate Max,Min,Mean and range.
! Broadcast range, since this is the termination criterion
! Repeat this until the range .le. 1
! WalktoTransfer(1) is the number of walkers to transfer
! WalktoTransfer(2) is the rank of the processor to transfer them from
! WalktoTransfer(3) is the rank of the processor to transfer them to
! WalktoTransfer(4) is the range of the different walkers on the processors - this will determine when to stop

                IF(WalktoTransfer(4).le.1) THEN
!This is the termination criteria, and will not transfer any walkers in this iteration.
                    WalktoTransfer(1)=0
                    WalktoTransfer(2)=-1
                    WalktoTransfer(3)=-1
                ELSE
!                    WalktoTransfer(1)=MIN(NINT(ABS(REAL(MaxWalkers(1),dp)-MeanWalkers)),NINT(ABS(REAL(MinWalkers(1),dp)-MeanWalkers)))
                    WalktoTransfer(1)=MIN(NINT(ABS(REAL(MaxWalkers(1),dp)-MidWalkers)),NINT(ABS(REAL(MinWalkers(1),dp)-MidWalkers)))
!                    WRITE(6,*) MaxWalkers(:),MinWalkers(:),MidWalkers
!                    CALL FLUSH(6)
                    WalktoTransfer(2)=MaxWalkers(2)
                    WalktoTransfer(3)=MinWalkers(2)
                ENDIF

            ENDIF

!The information about what to transfer now needs to be broadcast to all processors
!            CALL MPI_Barrier(MPI_COMM_WORLD,error)
            CALL MPI_BCast(WalktoTransfer,4,MPI_INTEGER,root,MPI_COMM_WORLD,error)

!            WRITE(6,*) "WALKTOTRANSFER: ",WalktoTransfer(:)
!            CALL FLUSH(6)

            IF(WalkToTransfer(2).eq.iProcIndex) THEN
!This processor wants to transfer walkers to WalkToTransfer(3).
                IndexFrom=TotWalkers-(WalktoTransfer(1)-1)          !We want to transfer the last WalktoTransfer(1) walkers
!                WRITE(6,*) "TRANSFER: ",Transfers,WalkToTransfer(:),IndexFrom,TotWalkers
!                CALL FLUSH(6)
                
                CALL MPI_Send(CurrentDets(:,IndexFrom:TotWalkers),WalktoTransfer(1)*(NIfTot+1),MPI_INTEGER,WalktoTransfer(3),Tag,MPI_COMM_WORLD,error)
                CALL MPI_Send(CurrentSign(IndexFrom:TotWalkers),WalktoTransfer(1),MPI_INTEGER,WalktoTransfer(3),Tag,MPI_COMM_WORLD,error)
!                CALL MPI_Send(CurrentIC(IndexFrom:TotWalkers),WalktoTransfer(1),MPI_INTEGER,WalktoTransfer(3),Tag,MPI_COMM_WORLD,error)
                IF(.not.tRegenDiagHEls) THEN
                    CALL MPI_Send(CurrentH(IndexFrom:TotWalkers),WalktoTransfer(1),MPI_DOUBLE_PRECISION,WalktoTransfer(3),Tag,MPI_COMM_WORLD,error)
                ENDIF
!It seems like too much like hard work to send the excitation generators accross, just let them be regenerated on the other side...
!However, we do need to indicate that these the excitgens are no longer being pointed at.
                IF(.not.TRegenExcitgens) THEN
                    do l=IndexFrom,TotWalkers
!Run through the list of walkers, and make sure that their excitgen is removed.
                        CALL DissociateExitgen(CurrentExcits(l))
                    enddo
                ENDIF

                IF((.not.TNoAnnihil).and.(.not.tRotoAnnihil)) CALL MPI_Send(HashArray(IndexFrom:TotWalkers),WalktoTransfer(1),MPI_DOUBLE_PRECISION,WalktoTransfer(3),Tag,MPI_COMM_WORLD,error)
!                IF((.not.TNoAnnihil).and.(.not.TAnnihilonproc)) CALL MPI_Send(HashArray(IndexFrom:TotWalkers),WalktoTransfer(1),MPI_DOUBLE_PRECISION,WalktoTransfer(3),Tag,MPI_COMM_WORLD,error)
!                IF((.not.TNoAnnihil).and.(.not.TAnnihilonproc)) CALL MPI_Send(HashArray(IndexFrom:TotWalkers),WalktoTransfer(1),mpilongintegertype,WalktoTransfer(3),Tag,MPI_COMM_WORLD,error)
                
                TotWalkers=TotWalkers-WalktoTransfer(1)         !Update TotWalkers on this node to reflect that we have lost some
            
            ELSEIF(WalkToTransfer(3).eq.iProcIndex) THEN
!This processor wants to receive walkers from WalktoTransfer(2)
                IndexFrom=TotWalkers+1
                IndexTo=TotWalkers+WalktoTransfer(1)
!                WRITE(6,*) "RECEIVING: ",Transfers,WalkToTransfer(:),IndexFrom,IndexTo
!                CALL FLUSH(6)

                CALL MPI_Recv(CurrentDets(:,IndexFrom:IndexTo),WalktoTransfer(1)*(NIfTot+1),MPI_INTEGER,WalktoTransfer(2),Tag,MPI_COMM_WORLD,Stat,error)
                CALL MPI_Recv(CurrentSign(IndexFrom:IndexTo),WalktoTransfer(1),MPI_INTEGER,WalktoTransfer(2),Tag,MPI_COMM_WORLD,Stat,error)
!                CALL MPI_Recv(CurrentIC(IndexFrom:IndexTo),WalktoTransfer(1),MPI_INTEGER,WalktoTransfer(2),Tag,MPI_COMM_WORLD,Stat,error)
                IF(.not.tRegenDiagHEls) THEN
                    CALL MPI_Recv(CurrentH(IndexFrom:IndexTo),WalktoTransfer(1),MPI_DOUBLE_PRECISION,WalktoTransfer(2),Tag,MPI_COMM_WORLD,Stat,error)
                ENDIF
                IF((.not.TNoAnnihil).and.(.not.tRotoAnnihil)) CALL MPI_Recv(HashArray(IndexFrom:IndexTo),WalktoTransfer(1),MPI_DOUBLE_PRECISION,WalktoTransfer(2),Tag,MPI_COMM_WORLD,Stat,error)
!                IF((.not.TNoAnnihil).and.(.not.TAnnihilonproc)) CALL MPI_Recv(HashArray(IndexFrom:IndexTo),WalktoTransfer(1),MPI_DOUBLE_PRECISION,WalktoTransfer(2),Tag,MPI_COMM_WORLD,Stat,error)
!Also need to indicate that the excitation generators are no longer useful...
                IF(.not.TRegenExcitgens) THEN
                    do j=IndexFrom,IndexTo
                        CurrentExcits(j)%PointToExcit=>null()
                    enddo
                ENDIF

                TotWalkers=TotWalkers+WalktoTransfer(1)         !Update to show the new number of walkers

            ENDIF
            
            IF(WalktoTransfer(1).gt.0) THEN
                IF(iProcIndex.eq.root) THEN
!Update the number of transfers and the new ProcWalkers array...
                    Transfers=Transfers+1
                    ProcWalkers(WalktoTransfer(2))=ProcWalkers(WalktoTransfer(2))-WalktoTransfer(1)
                    ProcWalkers(WalktoTransfer(3))=ProcWalkers(WalktoTransfer(3))+WalktoTransfer(1)
                ENDIF
            ENDIF

        enddo       !loop over transfers

        IF(tRotoAnnihil) THEN
!If we are using rotoannihilation, then we need to maintain sorted lists. There is a much better way to do it than sorting them all again though!...
!We are also storing the list as determinants, rather than particles. Therefore after sorting, we need to compress the list to remove multiple specifications of the same det.
            IF(.not.tRegenDiagHEls) THEN
                CALL SortCompressListswH(TotWalkers,CurrentDets(0:NIfTot,1:TotWalkers),CurrentSign(1:TotWalkers),CurrentH(1:TotWalkers))
            ELSE
                CALL SortCompressLists(TotWalkers,CurrentDets(0:NIfTot,1:TotWalkers),CurrentSign(1:TotWalkers))
            ENDIF
        ELSE
            TotParts=TotWalkers
        ENDIF

        IF(iProcIndex.eq.root) THEN
            WRITE(6,*) "Transfer of walkers/dets finished. Number of transfers needed: ",Transfers
        ENDIF

        TBalanceNodes=.false.

        RETURN

    END SUBROUTINE BalanceWalkersonProcs


!This is the heart of FCIMC, where the MC Cycles are performed. However, this includes the 'inward spawning' attempt.
    SUBROUTINE MultipleConnFCIMCycPar()
!        use CalcData , only : iDetGroup
!        use HPHFRandExcitMod , only : TestGenRandHPHFExcit 
        INTEGER :: nStore(6),VecSlot,i,j,k,l,ValidSpawned,CopySign,ParticleWeight,Loop,iPartBloom
        INTEGER :: nJ(NEl),ierr,IC,Child,iCount,DetCurr(NEl),iLutnJ(0:NIfTot)
        REAL*8 :: Prob,rat,HDiag,HDiagCurr,r,HSum
        INTEGER :: iDie,WalkExcitLevel,iMaxExcit,ExcitLength,PartInd,iExcit
        INTEGER :: ExcitLevel,TotWalkersNew,iGetExcitLevel_2,error,length,temp,Ex(2,2),WSign,p,Scratch1(ScratchSize),Scratch2(ScratchSize)
        LOGICAL :: tParity,tMainArr,tFilled,tSuccess,tMinorDetList
        TYPE(HElement) :: HDiagTemp,HElemTemp
        INTEGER , ALLOCATABLE :: ExcitGenTemp(:)

        IF(TDebug) THEN
            WRITE(11,*) Iter,TotWalkers,NoatHF,NoatDoubs,MaxIndex,TotParts
!            CALL FLUSH(11)
        ENDIF
        
        CALL set_timer(Walker_Time,30)
        
!VecSlot indicates the next free position in NewDets
        VecSlot=1
!Reset number at HF and doubles
        NoatHF=0
        NoatDoubs=0
        iPartBloom=0
        ValidSpawned=1  !This is for rotoannihilation - this is the number of spawned particles (well, one more than this.)
!        Combs=1
!        do j=1,iDetGroup-1
!!Combs is the total number of pair combinations
!            Combs=Combs*(TotWalkers-j)
!        enddo

        do j=1,TotWalkers
!Spawning loop done separately to the death loop
!First, decode the bit-string representation of the determinant the walker is on, into a string of naturally-ordered integers
            CALL DecodeBitDet(DetCurr,CurrentDets(:,j))

!Also, we want to find out the excitation level - we only need to find out if its connected or not (so excitation level of 3 or more is ignored.
!This can be changed easily by increasing the final argument.
            IF(tTruncSpace) THEN
!We need to know the exact excitation level for truncated calculations.
                WalkExcitLevel = FindBitExcitLevel(iLutHF, CurrentDets(:,j),&
                                                   nel)
            ELSE
                WalkExcitLevel = FindBitExcitLevel(iLutHF, CurrentDets(:,j),2)
            ENDIF

            tFilled=.false.     !This is for regenerating excitations from the same determinant multiple times. There will be a time saving if we can store the excitation generators temporarily.
            IF(tSpawnAsDet) THEN
!Here, we spawn all particles on the determinant in one go, by multiplying the probability of spawning by the number of particles on the determinant.
                Loop=1
                ParticleWeight=abs(CurrentSign(j))
            ELSE
!Here, we spawn each particle on the determinant in a seperate attempt.
                Loop=abs(CurrentSign(j))
                ParticleWeight=1
            ENDIF

            do p=1,Loop
!If rotoannihilating, we are simply looping over all the particles on the determinant

                IF(.not.tImportanceSample) THEN
                    IF(tNonUniRandExcits) THEN
!This will only be a help if most determinants are multiply occupied.
                        IF(tHPHF) THEN
!                            CALL GenRandHPHFExcit(DetCurr,CurrentDets(:,j),nJ,iLutnJ,pDoubles,exFlag,Prob)
                            CALL GenRandHPHFExcit2Scratch(DetCurr,CurrentDets(:,j),nJ,iLutnJ,pDoubles,exFlag,Prob,Scratch1,Scratch2,tFilled,tGenMatHEl)
                        ELSE
                            CALL GenRandSymExcitScratchNU(DetCurr,CurrentDets(:,j),nJ,pDoubles,IC,Ex,tParity,exFlag,Prob,Scratch1,Scratch2,tFilled)
                        ENDIF
                    ELSE
                        CALL GetPartRandExcitPar(DetCurr,CurrentDets(:,j),nJ,IC,0,Prob,iCount,WalkExcitLevel,Ex,tParity)
                    ENDIF
                ENDIF
                
                ExcitLevel=iGetExcitLevel_2(HFDet,nJ,NEl,2)
!                WRITE(6,*) ExcitLevel

                IF((ExcitLevel.eq.2).or.(ExcitLevel.eq.1)) THEN
!Do not allow spawning at doubles
                    Child=0
                ELSE

!Calculate number of children to spawn
                    IF(TTruncSpace) THEN
!We have truncated the excitation space at a given excitation level. See if the spawn should be allowed.
                        IF(tImportanceSample) CALL Stop_All("PerformFCIMCyc","Truncated calculations not yet working with importance sampling")

                        IF(ExcitLevel.gt.ICILevel) THEN
!Attempted excitation is above the excitation level cutoff - do not allow the creation of children
                            Child=0
                        ELSE
                            Child=AttemptCreatePar(DetCurr,CurrentDets(:,j),CurrentSign(j),nJ,iLutnJ,Prob,IC,Ex,tParity,ParticleWeight,tMinorDetList)
                        ENDIF
                    ELSE
!SD Space is not truncated - allow attempted spawn as usual
                        Child=AttemptCreatePar(DetCurr,CurrentDets(:,j),CurrentSign(j),nJ,iLutnJ,Prob,IC,Ex,tParity,ParticleWeight,tMinorDetList)
                    ENDIF
                ENDIF
                
                IF(Child.ne.0) THEN
!We want to spawn a child - find its information to store

                    NoBorn=NoBorn+abs(Child)     !Update counter about particle birth
                    IF(IC.eq.1) THEN
                        SpawnFromSing=SpawnFromSing+abs(Child)
                    ENDIF

                    IF(abs(Child).gt.25) THEN
!If more than 25 particles are created in one go, then log this fact and print out later that this has happened.
                        IF(abs(Child).gt.abs(iPartBloom)) THEN
                            IF(IC.eq.1) THEN
                                iPartBloom=-abs(Child)
                            ELSE
                                iPartBloom=abs(Child)
                            ENDIF
                        ENDIF
                    ENDIF

!We need to calculate the bit-representation of this new child. This can be done easily since the ExcitMat is known.
                    IF(.not.tHPHF) CALL FindExcitBitDet(CurrentDets(:,j),iLutnJ,IC,Ex)

                    IF(tRotoAnnihil) THEN
!In the RotoAnnihilation implimentation, we spawn particles into a seperate array - SpawnedParts and SpawnedSign. 
!The excitation level and diagonal matrix element are also found out after the annihilation.
!Cannot use old excitation generators with rotoannihilation.

!In rotoannihilation, we can specify multiple particles on the same entry. 
                        SpawnedParts(:,ValidSpawned)=iLutnJ(:)
                        SpawnedSign(ValidSpawned)=Child
                        ValidSpawned=ValidSpawned+1     !Increase index of spawned particles

                    ELSE
!Calculate diagonal ham element
                        CALL Stop_All("MultipleConnFcimCycPar","Needs Rotoannihilation")
                    
                    ENDIF   !Endif rotoannihil

                    Acceptances=Acceptances+ABS(Child)      !Sum the number of created children to use in acceptance ratio
                
                ENDIF   !End if child created

            enddo   !End of cycling over mulitple particles on same determinant.

        enddo

        do j=1,NoDoubs

            DetCurr(:)=DoublesDets(:,j)
!Setup excit generators for this double excitation 
            iMaxExcit=0
            nStore(1:6)=0
            CALL GenSymExcitIt2(DetCurr,NEl,G1,nBasis,nBasisMax,.TRUE.,ExcitLength,nJ,iMaxExcit,0,nStore,3)
            ALLOCATE(ExcitGenTemp(ExcitLength),stat=ierr)
            IF(ierr.ne.0) CALL Stop_All("MultipleConnFcimCycPar","Problem allocating excitation generator")
            ExcitGenTemp(1)=0
            CALL GenSymExcitIt2(DetCurr,NEl,G1,nBasis,nBasisMax,.TRUE.,ExcitGenTemp,nJ,iMaxExcit,0,nStore,3)

            HSum=0.D0

            do while(.true.)
!Generate double excitations
                CALL GenSymExcitIt2(Detcurr,NEl,G1,nBasis,nBasisMax,.false.,ExcitGenTemp,nJ,iExcit,0,nStore,3)
                IF(IsNullDet(nJ)) EXIT

!Find matrix element
                HElemTemp = get_helement (DetCurr, nJ, iExcit)
                IF((abs(REAL(HElemTemp%v,dp))).gt.1.D-8) THEN

!Encode this determinant
                    CALL EncodeBitDet(nJ,iLutnJ)

!If matrix element above a certain size, then find whether the determinant is in the main list.
                    CALL BinSearchParts(iLutnJ,1,TotWalkers,PartInd,tSuccess)

                    IF(tSuccess) THEN
!If found, find Ni x Hij and attempt to spawn at j
                        HSum=HSum+REAL(HElemTemp%v,dp)*CurrentSign(PartInd)
!                        WRITE(6,*) REAL(HElemTemp%v,dp),CurrentSign(PartInd)
                    ENDIF
                ENDIF

            enddo

            DEALLOCATE(ExcitGenTemp)

!The sum of Hij*cj is now in HSum.
            rat=Tau*abs(HSum)
            Child=INT(rat)
            rat=rat-REAL(Child)
            r = genrand_real2_dSFMT()
            IF(rat.gt.r) THEN
!Create child at DetCurr 
                Child=Child+1
            ENDIF
            IF(HSum.gt.0.D0) THEN
!Create negative child
                Child=-Child
            ENDIF

            IF(Child.ne.0) THEN
!                WRITE(6,"(A,F15.5,I5,G20.10,I8,G25.15)") "Inwards ", rat,Child,HSum
!We want to spawn a child - find its information to store
                CALL EncodeBitDet(DetCurr,iLutnJ)

                NoBorn=NoBorn+abs(Child)     !Update counter about particle birth

                IF(abs(Child).gt.25) THEN
!If more than 25 particles are created in one go, then log this fact and print out later that this has happened.
                    WRITE(6,"(I9,A)") Child," particles created in one go during inwards spawning step"
                ENDIF

                IF(tRotoAnnihil) THEN
!In the RotoAnnihilation implimentation, we spawn particles into a seperate array - SpawnedParts and SpawnedSign. 
!The excitation level and diagonal matrix element are also found out after the annihilation.
!Cannot use old excitation generators with rotoannihilation.

!In rotoannihilation, we can specify multiple particles on the same entry. 
                    SpawnedParts(:,ValidSpawned)=iLutnJ(:)
                    SpawnedSign(ValidSpawned)=Child
                    ValidSpawned=ValidSpawned+1     !Increase index of spawned particles

                ELSE
                    CALL Stop_All("LIUB","Die horribly")
                ENDIF   !Endif rotoannihil

                Acceptances=Acceptances+ABS(Child)      !Sum the number of created children to use in acceptance ratio
            
            ENDIF   !End if child created

        enddo


        do j=1,TotWalkers
!Death loop done separately to the spawning loop
!We also have to calculate the energy properties here.
!First, decode the bit-string representation of the determinant the walker is on, into a string of naturally-ordered integers
            CALL DecodeBitDet(DetCurr,CurrentDets(:,j))

!Also, we want to find out the excitation level - we only need to find out if its connected or not (so excitation level of 3 or more is ignored.
            WalkExcitLevel = FindBitExcitLevel(iLutHF, CurrentDets(:,j), 2)
            HDiagCurr=CurrentH(j)

!Sum in any energy contribution from the determinant, including other parameters, such as excitlevel info
            CALL SumEContrib(DetCurr,WalkExcitLevel,CurrentSign(j),CurrentDets(:,j),HDiagCurr,1.D0)

!We now have to decide whether the parent particle (j) wants to self-destruct or not...
!For rotoannihilation, we can have multiple particles on the same determinant - these can be stochastically killed at the same time.

            iDie=AttemptDiePar(DetCurr,HDiagCurr,WalkExcitLevel,CurrentSign(j))
            NoDied=NoDied+iDie          !Update death counter

!iDie can be positive to indicate the number of deaths, or negative to indicate the number of births
            IF(tRotoAnnihil) THEN
!We slot the particles back into the same array and position VecSlot if the particle survives. If it dies, then j increases, moving onto the next
!entry, but VecSlot remains where it is, meaning that j should never be less that VecSlot

                IF(CurrentSign(j).le.0) THEN
                    CopySign=CurrentSign(j)+iDie    !Copy sign is the total number of particles x sign that we want to copy accross.
                    IF(CopySign.le.0) THEN
!If we are copying to the main array, we have to ensure that we maintain sign-coherence in the array. Therefore, if we are spawning anti-particles,
!it wants to go in the spawning array, rather than the main array, so it has a chance to annihilate.
                        tMainArr=.true.
                    ELSE
                        tMainArr=.false.
                    ENDIF
                ELSE
                    CopySign=CurrentSign(j)-iDie
                    IF(CopySign.ge.0) THEN
                        tMainArr=.true.
                    ELSE
                        tMainArr=.false.
                    ENDIF
                ENDIF

                IF(tMainArr.and.(VecSlot.gt.j)) THEN
!We only have a single array, therefore surviving particles are simply transferred back into the original array.
!However, this can not happen if we want to overwrite particles that we haven't even got to yet.
!However, this should not happen under normal circumstances...
                    tMainArr=.false.
                    CALL Stop_All("PerformFCIMCyc","About to overwrite particles which haven't been reached yet. This should not happen in normal situations.")
                ENDIF

                IF(CopySign.ne.0) THEN

                    IF(tMainArr) THEN
!                        NewDets(:,VecSlot)=CurrentDets(:,j)
!                        NewSign(VecSlot)=CopySign
                        CurrentDets(:,VecSlot)=CurrentDets(:,j)
                        CurrentSign(VecSlot)=CopySign
                        IF(.not.tRegenDiagHEls) CurrentH(VecSlot)=HDiagCurr
                        VecSlot=VecSlot+1
                    ELSE
!                        CALL Stop_All("PerformFCIMCyc","Creating anti-particles")
!Here, we are creating anti-particles, and so to keep the sign-coherence of the main array assured, we transfer them to the spawning array.
!This should generally not happen under normal circumstances.
                        do p=1,abs(CopySign)
!In rotoannihilation, we still want to specify the determinants singly - this may change in the future...
                            SpawnedParts(:,ValidSpawned)=CurrentDets(:,j)
                            IF(CopySign.lt.0) THEN
                                SpawnedSign(ValidSpawned)=-1
                            ELSE
                                SpawnedSign(ValidSpawned)=1
                            ENDIF
                            ValidSpawned=ValidSpawned+1     !Increase index of spawned particles
                        enddo
                    ENDIF

                ENDIF

            ENDIF   !To kill if

!Finish cycling over walkers
        enddo

!SumWalkersCyc calculates the total number of walkers over an update cycle on each process
        SumWalkersCyc=SumWalkersCyc+(INT(TotParts,i2))
!        WRITE(6,*) "Born, Die: ",NoBorn, NoDied

!Since VecSlot holds the next vacant slot in the array, TotWalkers will be one less than this.
        TotWalkersNew=VecSlot-1

!Output if there has been a particle bloom this iteration. A negative number indicates that particles were created from a single excitation.
        IF(iPartBloom.ne.0) THEN
            WRITE(6,"(A,I10,A)") "LARGE PARTICLE BLOOMS in iteration ",Iter
            IF(iPartBloom.gt.0) THEN
                WRITE(6,"(A,I10,A)") "A max of ",abs(iPartBloom)," particles created in one attempt from double excit."
            ELSE
                WRITE(6,"(A,I10,A)") "A max of ",abs(iPartBloom)," particles created in one attempt from single excit."
            ENDIF
        ENDIF


        rat=(TotWalkersNew+0.D0)/(MaxWalkersPart+0.D0)
        IF(rat.gt.0.95) THEN
            WRITE(6,*) "*WARNING* - Number of particles/determinants has increased to over 95% of MaxWalkersPart"
            CALL FLUSH(6)
        ENDIF

        IF(tRotoAnnihil) THEN
            ValidSpawned=ValidSpawned-1     !For rotoannihilation, this is the number of spawned particles.

            rat=(ValidSpawned+0.D0)/(MaxSpawned+0.D0)
            IF(rat.gt.0.9) THEN
                WRITE(6,*) "*WARNING* - Number of spawned particles has reached over 90% of MaxSpawned"
                CALL FLUSH(6)
            ENDIF
        ENDIF
        
        CALL halt_timer(Walker_Time)
        CALL set_timer(Annihil_Time,30)

        IF(tRotoAnnihil) THEN
!This is the rotoannihilation algorithm. The newly spawned walkers should be in a seperate array (SpawnedParts) and the other list should be ordered.

            CALL RotoAnnihilation(ValidSpawned,TotWalkersNew)

        ELSEIF(TNoAnnihil) THEN
!However, we now need to swap around the pointers of CurrentDets and NewDets, since this was done previously explicitly in the annihilation routine
            IF(associated(CurrentDets,target=WalkVecDets)) THEN
                CurrentDets=>WalkVec2Dets
                CurrentSign=>WalkVec2Sign
                CurrentH=>WalkVec2H
                CurrentExcits=>WalkVec2Excits
                NewDets=>WalkVecDets
                NewSign=>WalkVecSign
                NewH=>WalkVecH
                NewExcits=>WalkVecExcits
            ELSE
                CurrentDets=>WalkVecDets
                CurrentSign=>WalkVecSign
                CurrentH=>WalkVecH
                CurrentExcits=>WalkVecExcits
                NewDets=>WalkVec2Dets
                NewSign=>WalkVec2Sign
                NewH=>WalkVec2H
                NewExcits=>WalkVec2Excits
            ENDIF

            TotWalkers=TotWalkersNew
            TotParts=TotWalkers

        ELSEIF(TAnnihilonProc) THEN
!In this routine, the particles are just annihilated on their own processors. This means that all simulations are independent and not influenced by each other.
!This means that there is no communication between processors and so should be much faster as the system size increases.

            CALL Stop_All("PerformFCIMCyc","AnnihilonProc has been disabled")
!            CALL AnnihilateonProc(TotWalkersNew)
!            Annihilated=Annihilated+(TotWalkersNew-TotWalkers)
!            TotParts=TotWalkers

        ELSE
!This routine now cancels down the particles with opposing sign on each determinant

            CALL AnnihilatePartPar(TotWalkersNew)
            Annihilated=Annihilated+(TotWalkersNew-TotWalkers)
            TotParts=TotWalkers

        ENDIF

        CALL halt_timer(Annihil_Time)
        
!Find the total number of particles at HF (x sign) across all nodes. If this is negative, flip the sign of all particles.
        AllNoatHF=0

!Find sum of noathf, and then use an AllReduce to broadcast it to all nodes
        CALL MPI_Barrier(MPI_COMM_WORLD,error)
        CALL MPI_AllReduce(NoatHF,AllNoatHF,1,MPI_INTEGER,MPI_SUM,MPI_COMM_WORLD,ierr)

        IF(AllNoatHF.lt.0) THEN
!Flip the sign if we're beginning to get a negative population on the HF
            WRITE(6,*) "No. at HF < 0 - flipping sign of entire ensemble of particles..."
            CALL FlipSign()
        ENDIF

        IF(TSinglePartPhase) THEN
!Do not allow culling if we are still in the single particle phase.
            IF(iProcIndex.eq.root) THEN     !Only exit phase if particle number is sufficient on head node.
                IF(TotParts.gt.InitWalkers) THEN
                    WRITE(6,*) "Exiting the single particle growth phase - shift can now change"
                    TSinglePartPhase=.false.
                    VaryShiftIter=Iter
                ENDIF
            ENDIF
!Broadcast the fact that TSinglePartPhase may have changed to all processors - unfortunatly, have to do this broadcast every iteration
            CALL MPI_Bcast(TSinglePartPhase,1,MPI_LOGICAL,root,MPI_COMM_WORLD,ierr)
        ELSE

            IF(TotWalkers.gt.(InitWalkers*GrowMaxFactor)) THEN
!Particle number is too large - kill them randomly
                IF(.not.tRotoAnnihil) THEN

!Log the fact that we have made a cull
                    NoCulls=NoCulls+1
                    IF(NoCulls.gt.10) THEN
                        WRITE(6,*) "Too Many Culls"
                        CALL FLUSH(6)
                        call Stop_All("PerformFCIMCyc","Too Many Culls")
                    ENDIF
!CullInfo(:,1) is walkers before cull
                    CullInfo(NoCulls,1)=TotParts
!CullInfo(:,3) is MC Steps into shift cycle before cull
                    CullInfo(NoCulls,3)=mod(Iter,StepsSft)

                    WRITE(6,"(A,F8.2,A)") "Total number of particles has grown to ",GrowMaxFactor," times initial number on this node..."
                    WRITE(6,"(A,I12,A)") "Killing randomly selected particles in cycle ", Iter," in order to reduce total number on this node..."
                    WRITE(6,"(A,F8.2)") "Population on this node will reduce by a factor of ",CullFactor
                    CALL FLUSH(6)
                    CALL ThermostatParticlesPar(.true.)

                ENDIF

            ELSEIF(TotParts.lt.(InitWalkers/2)) THEN
!Particle number is too small - double every particle in its current position
                IF(.not.tRotoAnnihil) THEN
!Log the fact that we have made a cull
                    NoCulls=NoCulls+1
                    IF(NoCulls.gt.10) CALL Stop_All("PerformFCIMCyc","Too Many Culls")
!CullInfo(:,1) is walkers before cull
                    CullInfo(NoCulls,1)=TotParts
!CullInfo(:,3) is MC Steps into shift cycle before cull
                    CullInfo(NoCulls,3)=mod(Iter,StepsSft)
                    
                    WRITE(6,*) "Doubling particle population on this node to increase total number..."
                    CALL ThermostatParticlesPar(.false.)
                ELSE
!                    WRITE(6,*) "Particle number on this node is less than half InitWalkers value"
                ENDIF
            ENDIF
        
        ENDIF

    END SUBROUTINE MultipleConnFCIMCycPar

!This routine will write out to a popsfile. It transfers all walkers to the head node sequentially, so does not want to be called too often
!When arriving at this routine, CurrentXXX are arrays with the data, and NewXXX will be used by the root processor to temporarily store the information
    SUBROUTINE WriteToPopsfilePar()
        use util_mod, only: get_unique_filename
        use CalcData, only: iPopsFileNoWrite
        use Logging, only: tIncrementPops
        REAL*8 :: TempSumNoatHF
        INTEGER :: error,WalkersonNodes(0:nProcessors-1)
        INTEGER :: Stat(MPI_STATUS_SIZE),Tag,Total,i,j,k
        character(255) :: popsfile

        CALL MPI_Barrier(MPI_COMM_WORLD,error)  !sync

!First, make sure we have up-to-date information - again collect AllTotWalkers,AllSumNoatHF and AllSumENum...
!        CALL MPI_Reduce(TotWalkers,AllTotWalkers,1,MPI_INTEGER,MPI_Sum,root,MPI_COMM_WORLD,error)    
!Calculate the energy by summing all on HF and doubles - convert number at HF to a real since no int*8 MPI data type
        TempSumNoatHF=real(SumNoatHF,dp)
        CALL MPIDSumRoot(TempSumNoatHF,1,AllSumNoatHF,Root)
        CALL MPIDSumRoot(SumENum,1,AllSumENum,Root)

!We also need to tell the root processor how many particles to expect from each node - these are gathered into WalkersonNodes
        CALL MPI_AllGather(TotWalkers,1,MPI_INTEGER,WalkersonNodes,1,MPI_INTEGER,MPI_COMM_WORLD,error)

        Tag=125

        IF(iProcIndex.eq.root) THEN
!First, check that we are going to receive the correct number of particles...
            Total=0
            do i=0,nProcessors-1
                Total=Total+INT(WalkersonNodes(i)/iPopsPartEvery)
            enddo
            AllTotWalkers=REAL(Total,dp)
!            IF(Total.ne.AllTotWalkers) THEN
!                CALL Stop_All("WriteToPopsfilePar","Not all walkers accounted for...")
!            ENDIF

!Write header information
            IF(iPopsPartEvery.ne.1) THEN
                IF(tBinPops) THEN
                    WRITE(6,"(A,I12,A)") "Writing a binary reduced POPSFILEBIN, printing a total of ",INT(AllTotWalkers,i2), " particles."
                ELSE
                    WRITE(6,"(A,I12,A)") "Writing a reduced POPSFILE, printing a total of ",INT(AllTotWalkers,i2), " particles."
                ENDIF
            ELSE
                IF(tBinPops) THEN
                    WRITE(6,*) "Writing to binary POPSFILEBIN..."
                ELSE
                    WRITE(6,*) "Writing to POPSFILE..."
                ENDIF
            ENDIF
            IF(tBinPops) THEN
                call get_unique_filename('POPSFILEHEAD',tIncrementPops,.true.,iPopsFileNoWrite,popsfile)
            ELSE
                call get_unique_filename('POPSFILE',tIncrementPops,.true.,iPopsFileNoWrite,popsfile)
            ENDIF
            OPEN(17,FILE=popsfile,Status='replace')
            WRITE(17,*) AllTotWalkers,"   TOTWALKERS (all nodes)"
            WRITE(17,*) DiagSft,"   DIAG SHIFT"
            WRITE(17,*) NINT(AllSumNoatHF,i2),"   SUMNOATHF (all nodes)"
            WRITE(17,*) AllSumENum,"   SUMENUM ( \sum<D0|H|Psi> - all nodes)"
            WRITE(17,*) Iter+PreviousCycles,"   PREVIOUS CYCLES"
            IF(tBinPops) THEN
                CLOSE(17)
                call get_unique_filename('POPSFILEBIN',tIncrementPops,.true.,iPopsFileNoWrite,popsfile)
                OPEN(17,FILE=popsfile,Status='replace',form='unformatted')
            ENDIF

            IF(tBinPops) THEN
                do j=1,TotWalkers
!First write out walkers on head node
                    IF(mod(j,iPopsPartEvery).eq.0) THEN
                        WRITE(17) CurrentDets(0:NIfTot,j),CurrentSign(j)
                    ENDIF
                enddo
            ELSE
                do j=1,TotWalkers
!First write out walkers on head node
                    IF(mod(j,iPopsPartEvery).eq.0) THEN
                        do k=0,NIfTot
                            WRITE(17,"(I20)",advance='no') CurrentDets(k,j)
                        enddo
                        WRITE(17,*) CurrentSign(j)
                    ENDIF
                enddo
            ENDIF
!            WRITE(6,*) "Written out own walkers..."
!            CALL FLUSH(6)

!Now we need to receive the data from each other processor sequentially
            do i=1,nProcessors-1
!Run through all other processors...receive the data...
                CALL MPI_Recv(NewDets(0:NIfTot,1:WalkersonNodes(i)),WalkersonNodes(i)*(NIfTot+1),MPI_INTEGER,i,Tag,MPI_COMM_WORLD,Stat,error)
                CALL MPI_Recv(NewSign(1:WalkersonNodes(i)),WalkersonNodes(i),MPI_INTEGER,i,Tag,MPI_COMM_WORLD,Stat,error)
!                WRITE(6,*) "Recieved walkers for processor ",i
!                CALL FLUSH(6)
                
!Then write it out...
                IF(tBinPops) THEN
                    do j=1,WalkersonNodes(i)
                        IF(mod(j,iPopsPartEvery).eq.0) THEN
                            WRITE(17) NewDets(0:NIfTot,j),NewSign(j)
                        ENDIF
                    enddo
                ELSE
                    do j=1,WalkersonNodes(i)
                        IF(mod(j,iPopsPartEvery).eq.0) THEN
                            do k=0,NIfTot
                                WRITE(17,"(I20)",advance='no') NewDets(k,j)
                            enddo
                            WRITE(17,*) NewSign(j)
                        ENDIF
                    enddo
                ENDIF
!                WRITE(6,*) "Writted out walkers for processor ",i
!                CALL FLUSH(6)

            enddo

            CLOSE(17)

        ELSE
!All other processors need to send their data to root...
            CALL MPI_Send(CurrentDets(0:NIfTot,1:TotWalkers),TotWalkers*(NIfTot+1),MPI_INTEGER,root,Tag,MPI_COMM_WORLD,error)
            CALL MPI_Send(CurrentSign(1:TotWalkers),TotWalkers,MPI_INTEGER,root,Tag,MPI_COMM_WORLD,error)
!            WRITE(6,*) "Have sent info to head node..."
!            CALL FLUSH(6)
        ENDIF

!Reset the values of the global variables
        AllSumNoatHF=0.D0
        AllSumENum=0.D0
        AllTotWalkers=0.D0

        RETURN

    END SUBROUTINE WriteToPopsfilePar


    SUBROUTINE InitGuidingFunction()
!This routine reads in the guiding function from the GUIDINGFUNC file printed in a previous calculation.
!It then scales the number of walkers on each determinant up so that the HF population is that specified in the input for iInitGuideParts. 
!The result is an array of determinats and a corresponding array of populations (with sign) for the guiding function.
        INTEGER :: i,j,ierr,CurrentGuideParts,NewGuideParts,error,ExcitLevel, HFPop,PartInd
        CHARACTER(len=*), PARAMETER :: this_routine='InitGuidingFunction'
        TYPE(HElement) :: HDoubTemp
        REAL*8 :: Hdoub
        LOGICAL :: DetsEq,tSuccess

        if (tCSF) then
            call stop_all (this_routine, "CSFs not supported")
        endif

        iGuideDets=0
        AlliInitGuideParts=0
        DetsEq=.false.
        IF(iProcIndex.eq.Root) THEN
            OPEN(36,FILE='GUIDINGFUNC',Status='old')
            READ(36,*) iGuideDets 
        ENDIF
 
        CALL MPI_Bcast(iGuideDets,1,MPI_INTEGER,Root,MPI_COMM_WORLD,error)

        ALLOCATE(GuideFuncDets(0:NIfTot,1:iGuideDets),stat=ierr)
        CALL LogMemAlloc('GuideFuncDets',(NIfTot+1)*iGuideDets,4,this_routine,GuideFuncDetsTag,ierr)
        ALLOCATE(GuideFuncSign(0:iGuideDets),stat=ierr)
        CALL LogMemAlloc('GuideFuncSign',iGuideDets+1,4,this_routine,GuideFuncSignTag,ierr)

        ALLOCATE(DetstoRotate(0:NIfTot,1:iGuideDets),stat=ierr)
        CALL LogMemAlloc('DetstoRotate',(NIfTot+1)*iGuideDets,4,this_routine,DetstoRotateTag,ierr)
        ALLOCATE(SigntoRotate(0:iGuideDets),stat=ierr)
        CALL LogMemAlloc('SigntoRotate',iGuideDets+1,4,this_routine,SigntoRotateTag,ierr)
        ALLOCATE(DetstoRotate2(0:NIfTot,1:iGuideDets),stat=ierr)
        CALL LogMemAlloc('DetstoRotate2',(NIfTot+1)*iGuideDets,4,this_routine,DetstoRotate2Tag,ierr)
        ALLOCATE(SigntoRotate2(0:iGuideDets),stat=ierr)
        CALL LogMemAlloc('SigntoRotate2',iGuideDets+1,4,this_routine,SigntoRotate2Tag,ierr)


        IF(iProcIndex.eq.Root) THEN
            !Set up the determinant and sign arrays by reading in from the GUIDINGFUNC file.
            j=1
            do while (j.le.iGuideDets)
                READ(36,*) GuideFuncDets(0:NIfTot,j),GuideFuncSign(j)
                j=j+1
            enddo
            CLOSE(36)

            !Calculate the total number of particles in the GUIDINGFUNC file.
            !CurrentGuideParts=0
            !do j=1,iGuideDets
                !CurrentGuideParts=CurrentGuideParts+ABS(GuideFuncSign(j))
            !enddo

            !Scale up the populations (sign), by the ratio of the original total to the iInitGuideParts value from the NECI input,
            !and calculate the new sum (should be approximately iInitGuideParts, but maybe not exactly because need to take nearest integer.
            !NewGuideParts=0
            !do j=1,iGuideDets
                !GuideFuncSign(j)=NINT(REAL(GuideFuncSign(j))*(REAL(iInitGuideParts)/REAL(CurrentGuideParts)))
                !NewGuideParts=NewGuideParts+ABS(GuideFuncSign(j))
            !enddo
            !iInitGuideParts=NewGuideParts
            !The total number of particles in the guiding function is now iInitGuideParts
            !WRITE(6,*) 'iInitGuideParts, ',iInitGuideParts

            !Find the HF determinant and the population in the guiding function.  Take the number from the input and find the factor by which
            !the current pop needs to be scaled by to reach the input value.  Scale all the other populations by the same value.
            !First binary search the Guiding function determinants for the HFDet.

            CALL BinSearchGuideParts(iLutHF,1,iGuideDets,PartInd,tSuccess)
            IF(tSuccess) THEN
                GuideFuncSign(0)=PartInd
                HFPop=ABS(GuideFuncSign(PartInd))
            ELSE
                CALL Stop_All(this_routine, 'HF determinant not found in the guiding function.')
            ENDIF
            NewGuideParts=0
            do j=1,iGuideDets
                GuideFuncSign(j)=NINT(REAL(GuideFuncSign(j))*(REAL(iInitGuideParts)/REAL(HFPop)))
                NewGuideParts=NewGuideParts+ABS(GuideFuncSign(j))
            enddo
            iInitGuideParts=NewGuideParts
            

            
            !Maybe put in a test here that checks the determinants are in the right order.  But they should be cos we're printing them out right.

            AlliInitGuideParts=iInitGuideParts*nProcessors

            !Want to know what is happening to the guiding function throughout the spawning, so just print it out at the beginning to compare to the
            !final one.
            !Store the initguidefuncsigns 
            ALLOCATE(InitGuideFuncSign(iGuideDets),stat=ierr)
            CALL LogMemAlloc('InitGuideFuncSign',iGuideDets,4,this_routine,InitGuideFuncSignTag,ierr)
            InitGuideFuncSign(:)=0

!            OPEN(37,file='GUIDINGFUNCinit',status='unknown')
!            WRITE(37,*) iGuideDets,' determinants included in the guiding function.'    
            do j=1,iGuideDets
                InitGuideFuncSign(j)=nProcessors*GuideFuncSign(j)
!                WRITE(37,*) GuideFuncDets(0:NIfTot,j),nProcessors*GuideFuncSign(j)
            enddo
!            CLOSE(37)
            
        ENDIF

        !Broadcast the guiding function determinants (and signs) to all processors.
        !The total number of walkers in the guiding function is therefore nProcessors*iInitGuideParts.
        CALL MPI_Bcast(GuideFuncDets(0:NIfTot,1:iGuideDets),iGuideDets*(NIfTot+1),MPI_INTEGER,Root,MPI_COMM_WORLD,error)
        CALL MPI_Bcast(GuideFuncSign(0:iGuideDets),iGuideDets+1,MPI_INTEGER,Root,MPI_COMM_WORLD,error)

        !Run through the guiding function determinants and find the index that contains the HF.
        !Want this known on all processors, so that we can just look up the sign at this position to get the guiding function HF population.
!        do i=1,iGuideDets
!            DetsEq=DetBitEQ(iLutHF,GuideFuncDets(0:NIfTot,i))
!            IF(DetsEq) THEN
!                GuideFuncHFIndex=i
!                EXIT
!            ENDIF
!        enddo
!        IF(GuideFuncHFIndex.ne.GuideFuncSign(0)) CALL Stop_All(this_routine,'Wrong HF Index')
        GuideFuncHFIndex=GuideFuncSign(0)

        IF(iProcIndex.eq.Root) THEN
            GuideFuncDoub=0.D0
            !Run through all other determinants in the guiding function.  Find out if they are doubly excited.  Find H elements, and multiply by number on that double.
            do i=1,iGuideDets
                ExcitLevel = FindBitExcitLevel(GuideFuncDets(:,i), iLutHF, 2)
                if (ExcitLevel == 2) then
                    ! nb. get_helement_normal does not use nI, nJ for ic == 2.
                    !     Therefore no need to generate guide det. This is not
                    !     true for CSFs --> no support
                    HdoubTemp = get_helement (HFDet, HFDet, ExcitLevel, &
                                              iLutHF, GuideFuncDets(:,i))
                    HDoub=REAL(HDoubTemp%v,dp)
                    GuideFuncDoub=GuideFuncDoub+(GuideFuncSign(i)*Hdoub)
                endif
            enddo
            WRITE(6,*) 'The energy of the guiding function alone is ,',GuideFuncDoub/(REAL(GuideFuncSign(GuideFuncHFIndex),dp))
            GuideFuncDoub=0.D0
        ENDIF
            

    ENDSUBROUTINE InitGuidingFunction




    SUBROUTINE WriteGuidingFunc()
!This routine writes out the iGuideDets determinants with the largest no of walkers at the end of a calculation.    
!Really it finds the number of walkers on the final determinant in iGuideDets, and writes out any determinants
!with this number or more walkers on them (accounts for degeneracies in the number of walkers on the determinants).
        INTEGER :: i,j,k,MinGuideDetPop,ierr,error,TestSum,OrigiGuideDets
        INTEGER :: AlliGuideDets,CompiGuideDets
        CHARACTER(len=*), PARAMETER :: this_routine='WriteGuidingFunc'
        INTEGER , ALLOCATABLE :: AllCurrentDets(:,:),AllCurrentSign(:)
        INTEGER :: AllCurrentDetsTag,AllCurrentSignTag
        INTEGER :: RecvCounts(nProcessors),Offsets(nProcessors),RecvCounts02(nProcessors),OffSets02(nProcessors)

        CALL FLUSH(6)
        IF(iGuideDets.gt.TotWalkers) CALL Stop_All(this_routine,'iGuideDets is greater than the number of populated determinants')

!        WRITE(6,*) 'the determinants and sign, on each processor, before I touched them'
!        do j=1,TotWalkers
!            WRITE(6,*) CurrentDets(0:NIfTot,j),CurrentSign(j)
!        enddo
        
! Firstly order CurrentSign in descending absolute value, taking the corresponding CurrentDets with it.
        CALL SortBitSign(TotWalkers,CurrentSign(1:TotWalkers), &
                         CurrentDets(:,1:TotWalkers))

! Then run through CurrentSign, finding out how many walkers are on the iGuideDets most populated, and counting how
! many have this many walkers or more.
    
        OrigiGuideDets=iGuideDets
        MinGuideDetPop=0
        MinGuideDetPop=ABS(CurrentSign(iGuideDets))
        ! This is the minimum number of walkers on the included determinants.
        ! Also want to include determinants with the same number of walkers.
        j=iGuideDets+1
        do while (ABS(CurrentSign(j)).eq.MinGuideDetPop)
            j=j+1
            iGuideDets=iGuideDets+1
        enddo
 
!        WRITE(6,*) 'The most populated determinants on each processor, ordered in terms of sign'
!        WRITE(6,*) iGuideDets,' determinants included in the guiding function.'    
!        do j=1,iGuideDets
!            WRITE(6,*) CurrentDets(0:NIfTot,j),CurrentSign(j)
!        enddo
!        CALL FLUSH(6)
        
! Now take the iGuideDets determinants and reorder them back in terms of determinants (taking the sign with them).
        
        CALL SortBitDets(iGuideDets,CurrentDets(:,1:iGuideDets), &
                         CurrentSign(1:iGuideDets))

!        WRITE(6,*) 'The most populated determinants on each processor, ordered by determinant'
!        WRITE(6,*) iGuideDets,' determinants included in the guiding function.'    
!        do j=1,iGuideDets
!            WRITE(6,*) CurrentDets(0:NIfTot,j),CurrentSign(j)
!        enddo
        
! Calculate RecvCounts(1:nProcessors), and OffSets for the Gatherv calculation
! Need to gather the iGuideDets values from each processor for this.
        CALL MPI_Gather(iGuideDets,1,MPI_INTEGER,RecvCounts,1,MPI_INTEGER,Root,MPI_COMM_WORLD,error)
        Offsets(:)=0
        do j=1,nProcessors-1
            OffSets(j+1)=RecvCounts(j)+OffSets(j)
        enddo
        do j=1,nProcessors
            RecvCounts02(j)=RecvCounts(j)*(NIfTot+1)
        enddo
        OffSets02(:)=0
        do j=1,nProcessors-1
            OffSets02(j+1)=RecvCounts02(j)+OffSets02(j)
        enddo

!        do j=1,nProcessors
!            WRITE(6,*) RecvCounts(j),OffSets(j),RecvCounts02(j),OffSets02(j)
!        enddo


! Find out the total number of iGuideDets on all processors (roughly the input, but not exactly because of 
! of the degeneracies in the populations). 
! This should be the same as the sum of RecvCounts.
        AlliGuideDets=0
        CALL MPI_Reduce(iGuideDets,AlliGuideDets,1,MPI_INTEGER,MPI_SUM,Root,MPI_COMM_WORLD,error)
        IF(iProcIndex.eq.Root) THEN
            TestSum=0
            do i=1,nProcessors
                TestSum=TestSum+RecvCounts(i)
            enddo
            IF(AlliGuideDets.ne.TestSum) CALL Stop_All("WriteGuidingFunc","Error in parallel sum")
        ENDIF
        
!        IF(iProcIndex.eq.Root) WRITE(6,*) 'AlliGuideDets ',AlliGuideDets
!        CALL FLUSH(6)


! Make arrays containing the most populated determinants from all processors.        

        IF(iProcIndex.eq.Root) THEN
            ALLOCATE(AllCurrentDets(0:NIfTot,1:AlliGuideDets),stat=ierr)
            CALL LogMemAlloc('AllCurrentDets',(NIfTot+1)*AlliGuideDets,4,this_routine,AllCurrentDetsTag,ierr)
            ALLOCATE(AllCurrentSign(1:AlliGuideDets),stat=ierr)
            CALL LogMemAlloc('AllCurrentSign',AlliGuideDets,4,this_routine,AllCurrentSignTag,ierr)
        ENDIF

        CALL MPI_Barrier(MPI_COMM_WORLD,error)

        CALL MPI_Gatherv(CurrentSign(1:iGuideDets),iGuideDets,MPI_INTEGER,AllCurrentSign(1:AlliGuideDets),&
        &RecvCounts,Offsets,MPI_INTEGER,Root,MPI_COMM_WORLD,error)
        CALL MPI_Gatherv(CurrentDets(0:NIfTot,1:iGuideDets),((NIfTot+1)*iGuideDets),MPI_INTEGER,&
        &AllCurrentDets(0:NIfTot,1:AlliGuideDets),RecvCounts02,Offsets02,MPI_INTEGER,Root,MPI_COMM_WORLD,error)
        CALL FLUSH(6)


        IF(iProcIndex.eq.Root) THEN

!            OPEN(31,file='GUIDINGFUNCall-01',status='unknown')
!            WRITE(31,*) 'The determinants from each processor combined'
!            WRITE(31,*) AlliGuideDets,' determinants included in the guiding function.'    
!            do j=1,AlliGuideDets
!                WRITE(31,*) AllCurrentDets(0:NIfTot,j),AllCurrentSign(j)
!            enddo
!            CLOSE(31)

! Having taken the largest occupied determinants from each processor, select the iGuideDets most populated from
! this total list.
! I.e. reorder in terms of population, compressing so that each determinant only appears once.  Then select out the top iGuideDets 
! and reorder by determinant once again.

! From the list of determinants from all processors, order in terms of determinant so that this may be compressed to make sure each
! determinant only appears once.
            CALL SortBitDets(AlliGuideDets,AllCurrentDets(:,1:AlliGuideDets),&
                             AllCurrentSign(1:AlliGuideDets))

!            OPEN(32,file='GUIDINGFUNCall-02',status='unknown')
!            WRITE(32,*) 'The determinants from each processor combined'
!            WRITE(32,*) AlliGuideDets,' determinants included in the guiding function.'    
!            do j=1,AlliGuideDets
!                WRITE(32,*) AllCurrentDets(0:NIfTot,j),AllCurrentSign(j)
!            enddo
!            CLOSE(32)
            

! Find out if two determinants next to each are the same, if so add their signs and move the ones below them up.
! DetBitEq returns true if two determinants are identical, or false otherwise.
            CompiGuideDets=AlliGuideDets
            do i=1,AlliGuideDets-1

                IF(i.gt.CompiGuideDets) EXIT 
                ! This means we have got to the end of the compressed list, don't want to keep going, as all determinants after this are 0. 

                do while (DetBitEQ(AllCurrentDets(0:NIfTot,i),AllCurrentDets(0:NIfTot,i+1),NIfDBO))
                    ! Take a determinant, if the one above it is identical, add its sign to the original and move the others up to overwrite
                    ! the second.
                    ! Repeat this until the i+1 determinant is no longer equal to the i determinant.

                    IF((AllCurrentSign(i)*AllCurrentSign(i+1)).lt.0) THEN
                        WRITE(6,*) 'Determinant populated with opposite signs',AllCurrentDets(0:NIfTot,i)
                        WRITE(6,*) 'Identical determinant next to it',AllCurrentDets(0:NIfTot,i+1)
                        CALL FLUSH(6)
                        CALL Stop_All("WriteGuidingFunc","Identical determinants populated with opposite sign")
                    ENDIF

                    AllCurrentSign(i)=AllCurrentSign(i)+AllCurrentSign(i+1)

                    CompiGuideDets=CompiGuideDets-1

                    do j=i+2,AlliGuideDets
                        AllCurrentDets(0:NIfTot,j-1)=AllCurrentDets(0:NIfTot,j)
                        AllCurrentSign(j-1)=AllCurrentSign(j)
                    enddo
                    ! Zero the last determinant
                    AllCurrentSign(AlliGuideDets)=0
                    AllCurrentDets(0:NIfTot,AlliGuideDets)=0
                enddo
            enddo
            AlliGuideDets=CompiGuideDets
     
!            OPEN(33,file='GUIDINGFUNCall-03',status='unknown')
!            WRITE(33,*) 'The determinants from each processor combined and compressed, ordered by determinant'
!            WRITE(33,*) AlliGuideDets,' determinants included in the guiding function.'    
!            do j=1,AlliGuideDets
!                WRITE(33,*) AllCurrentDets(0:NIfTot,j),AllCurrentSign(j)
!            enddo
!            CLOSE(33)

          
! Reorder the compressed list of determinants by population (i.e. descending according to absolute value of AllCurrentSign, taking determinant with it).        
            CALL SortBitSign(AlliGuideDets,AllCurrentSign(1:AlliGuideDets), &
                             AllCurrentDets(:,1:AlliGuideDets))

! From this total list of most populated determinants, pick out the iGuideDets most populated, along with any with the same number of walkers as the last.        
            iGuideDets=OrigiGuideDets
            MinGuideDetPop=0
            MinGuideDetPop=ABS(AllCurrentSign(iGuideDets))
            ! This is the minimum number of walkers on the included determinants.
            ! Also want to include determinants with the same number of walkers.
            j=iGuideDets+1
            do while (ABS(AllCurrentSign(j)).eq.MinGuideDetPop)
                j=j+1
                iGuideDets=iGuideDets+1
            enddo
      
!            OPEN(34,file='GUIDINGFUNCall-04',status='unknown')
!            WRITE(34,*) 'The determinants from each processor combined and compressed, ordered by sign'
!            WRITE(34,*) iGuideDets,' determinants included in the guiding function.'    
!            do j=1,iGuideDets
!                WRITE(34,*) AllCurrentDets(0:NIfTot,j),AllCurrentSign(j)
!            enddo
!            CLOSE(34)


! Now take the iGuideDets determinants and reorder them back in terms of determinants (taking the sign with them).
            CALL SortBitDets(iGuideDets,AllCurrentDets(:,1:iGuideDets), &
                             AllCurrentSign(1:iGuideDets))


! Write the iGuideDets most populated determinants (in order of their bit strings) to a file.
            OPEN(35,file='GUIDINGFUNC',status='unknown')
            WRITE(35,*) iGuideDets,' determinants included in the guiding function.'    
            do j=1,iGuideDets
                WRITE(35,*) AllCurrentDets(0:NIfTot,j),AllCurrentSign(j)
            enddo
            CLOSE(35)

            DEALLOCATE(AllCurrentDets)
            CALL LogMemDealloc(this_routine,AllCurrentDetsTag)
            DEALLOCATE(AllCurrentSign)
            CALL LogMemDealloc(this_routine,AllCurrentSignTag)
        
        ENDIF


    END SUBROUTINE WriteGuidingFunc




    SUBROUTINE WriteFinalGuidingFunc()
        INTEGER :: j,AllGuideFuncSignTag,ierr,error
        INTEGER , ALLOCATABLE :: AllGuideFuncSign(:)

        IF(iProcIndex.eq.Root) THEN
            ALLOCATE(AllGuideFuncSign(iGuideDets),stat=ierr)
            CALL LogMemAlloc('AllGuideFuncSign',iGuideDets,4,'WriteFinalGuidingFunc',AllGuideFuncSignTag,ierr)
        ENDIF 

        CALL MPI_Reduce(GuideFuncSign(1:iGuideDets),AllGuideFuncSign,iGuideDets,MPI_INTEGER,MPI_SUM,Root,MPI_COMM_WORLD,error)
 
        IF(iProcIndex.eq.Root) THEN
            OPEN(38,file='GUIDINGFUNCfinal',status='unknown')
            WRITE(38,*) iGuideDets,' determinants included in the guiding function.'    
            WRITE(38,'(A11,A28,A11,A15)') "Determinant","InitialPop","FinalPop","TotalChange"
            do j=1,iGuideDets
                WRITE(38,*) GuideFuncDets(0:NIfTot,j),InitGuideFuncSign(j),AllGuideFuncSign(j),(ABS(AllGuideFuncSign(j))-ABS(InitGuideFuncSign(j)))
            enddo
            CLOSE(38)

            DEALLOCATE(AllGuideFuncSign)
            CALL LogMemDealloc('WriteFinalGuidingFunc',AllGuideFuncSignTag)
            DEALLOCATE(InitGuideFuncSign)
            CALL LogMemDealloc('WriteFinalGuidingFunc',InitGuideFuncSignTag)
 
        ENDIF


    ENDSUBROUTINE WriteFinalGuidingFunc



    SUBROUTINE InitSpawnDominant()
!It then scales the number of walkers on each determinant up so that the total is that specified in the input for iInitGuideParts. 
!The result is an array of determinats and a corresponding array of populations (with sign) for the guiding function.
        INTEGER :: i,j,ierr,error,iNoExcLevels,Temp,iMinDomLevPop,SumExcLevPop,ExcitLevel
        CHARACTER(len=*), PARAMETER :: this_routine='InitSpawnDominant'

        IF(iProcIndex.eq.Root) THEN
            OPEN(41,FILE='DOMINANTDETS',Status='old')
            READ(41,*) iNoDomDets
            READ(41,*) iNoExcLevels 
            READ(41,*) iMinDomLev,SumExcLevPop
            iMaxDomLev=iMinDomLev+iNoExcLevels-1
!            IF(iMinDomLev.le.2) CALL Stop_All('InitSpawnDominant','Code is not set up to deal with removing doubles or lower.')
        ENDIF
        
        CALL MPI_Bcast(iMinDomLev,1,MPI_INTEGER,Root,MPI_COMM_WORLD,error)
        CALL MPI_Bcast(iMaxDomLev,1,MPI_INTEGER,Root,MPI_COMM_WORLD,error)
        CALL MPI_Bcast(iNoDomDets,1,MPI_INTEGER,Root,MPI_COMM_WORLD,error)
        CALL MPI_Bcast(iNoExcLevels,1,MPI_INTEGER,Root,MPI_COMM_WORLD,error)

        ALLOCATE(DomExcIndex(iMinDomLev:(iMinDomLev+iNoExcLevels)),stat=ierr)
        CALL LogMemAlloc('DomExcIndex',iNoExcLevels+1,4,this_routine,DomExcIndexTag,ierr)
        DomExcIndex(:)=0
        
        IF(iProcIndex.eq.Root) THEN
            DomExcIndex(iMinDomLev)=1
            i=iMinDomLev+1
            do while(i.le.iMaxDomLev)
                DomExcIndex(i)=SumExcLevPop+DomExcIndex(i-1)
                READ(41,*) ExcitLevel,Temp
                SumExcLevPop=Temp
                i=i+1
            enddo
            DomExcIndex(iMaxDomLev+1)=SumExcLevPop+DomExcIndex(i-1)
            IF(DomExcIndex(iMaxDomLev+1).ne.(iNoDomDets+1)) CALL Stop_All(this_routine,'ERROR in filling the indexing excitation indexing array.')
        ENDIF


        CALL MPI_Bcast(DomExcIndex(iMinDomLev:(iMaxDomLev+1)),iMaxDomLev-iMinDomLev+2,MPI_INTEGER,Root,MPI_COMM_WORLD,error)


        ALLOCATE(DomDets(0:NIfTot,1:iNoDomDets),stat=ierr)
        CALL LogMemAlloc('DomDets',(NIfTot+1)*iNoDomDets,4,this_routine,DomDetsTag,ierr)
        IF(ierr.ne.0) CALL Stop_All(this_routine,'Problem allocating memory for dominant determinants')

        IF(iProcIndex.eq.Root) THEN
            !Set up the determinant and sign arrays by reading in from the GUIDINGFUNC file.
            j=1
            do while (j.le.iNoDomDets)
                READ(41,*) DomDets(0:NIfTot,j)
                j=j+1
            enddo
            CLOSE(41)
        ENDIF

        ! Broadcast this list of DomDets to all processors
        CALL MPI_Bcast(DomDets(0:NIfTot,1:iNoDomDets),(NIfTot+1)*iNoDomDets,MPI_INTEGER,Root,MPI_COMM_WORLD,ierr)


        IF(tMinorDetsStar) THEN
            IF(.not.tRotoAnnihil) THEN
                CALL Stop_All(this_routine,'STARMINORDETERMINANTS can only be used with rotoannihilation.') 
            ELSEIF(tFixShiftShell) THEN
                CALL Stop_All(this_routine,'STARMINORDETERMINANTS cannot be used with the fixed shift shell approximation.') 
            ELSEIF(iMinDomLev.le.2) THEN
                CALL Stop_All(this_routine,'STARMINORDETERMINANTS is not set up to deal with removing doubles or lower.')
            ELSE
                CALL InitMinorDetsStar()
            ENDIF
        ENDIF


    ENDSUBROUTINE InitSpawnDominant 




    SUBROUTINE PrintDominantDets()
! This routine takes the list of determinants with particles on them, and picks out those with excitation levels between the max and min
! specified in the input file.  It then orders these in terms of population, takes the iNoDominantDets most populated and prints them 
! in order of excitation level and then determinant to a file named DOMINANTDETS.
        INTEGER :: i,j,k,ierr,error,TestSum,ExcitLevel,NoExcDets,AllNoExcDets,ExcDetsTag,ExcSignTag,AllExcDetsTag,AllExcSignTag,ipos
        INTEGER :: ExcDetsIndex,MinDomDetPop,AllExcLevelTag,ExcLevelTag,CurrExcitLevel,NoExcitLevel,OrigiDominantDets,HFPop,CurriNoDominantDets
        CHARACTER(len=*), PARAMETER :: this_routine='PrintDominantDets'
        REAL*8 :: MinRelDomPop,SpinTot,NormDef
        INTEGER , ALLOCATABLE :: ExcDets(:,:),ExcSign(:),AllExcDets(:,:),AllExcSign(:)
        INTEGER :: RecvCounts(nProcessors),Offsets(nProcessors),RecvCounts02(nProcessors),OffSets02(nProcessors),DetCurr(NEl),NormDefTrunc,NormDefTot
        INTEGER :: SpinCoupDetBit(0:NIfTot),SpinCoupDet(NEl),OpenShell(2,NEl),UpSpin(NEl),NoOpenShell,NoUpSpin,iRead,PartInd,ID1,ID2,iComb,TempSign
        LOGICAL :: tDoubOcc,tSuccess

        CALL FLUSH(6)
        IF(.not.tRotoAnnihil) CALL Stop_All(this_routine,'PRINTDOMINANTDETS can only be used with rotoannihilation.')

        WRITE(6,'(A13,I10,A53,I3,A5,I3)') 'Printing the ',iNoDominantDets,' dominant determinants with excitation level between ',MinExcDom,' and ',MaxExcDom


!        WRITE(6,*) 'the determinants and sign, on each processor, before I touched them'
!        do j=1,TotWalkers
!            WRITE(6,*) CurrentDets(0:NIfTot,j),CurrentSign(j)
!        enddo


! Firstly, copy the determinants with excitation level between the min and max into a separate array (and do the same with sign).  
! Need to first count the number that are going to go in this array.
        NoExcDets=0
        AllNoExcDets=0
        do i=1,TotWalkers
            ExcitLevel = FindBitExcitLevel(CurrentDets(:,i), iLutHF, &
                                           MaxExcDom)
            IF((ExcitLevel.ge.MinExcDom).and.(ExcitLevel.le.MaxExcDom)) THEN
                NoExcDets=NoExcDets+1
            ELSEIF(ExcitLevel.eq.0) THEN
                HFPop=ABS(CurrentSign(i))
            ENDIF
        enddo

        CALL MPI_Reduce(NoExcDets,AllNoExcDets,1,MPI_INTEGER,MPI_SUM,Root,MPI_COMM_WORLD,error)


! Allocate arrays of this size - these are the ones that will be reordered to find the iNoDominantDets most populated etc.        
        ALLOCATE(ExcDets(0:NIfTot,1:NoExcDets),stat=ierr)
        CALL LogMemAlloc('ExcDets',(NIfTot+1)*NoExcDets,4,this_routine,ExcDetsTag,ierr)
        ALLOCATE(ExcSign(1:NoExcDets),stat=ierr)
        CALL LogMemAlloc('ExcSign',NoExcDets,4,this_routine,ExcSignTag,ierr)
 
        IF(iProcIndex.eq.Root) THEN
            ALLOCATE(AllExcDets(0:NIfTot,1:(10*AllNoExcDets)),stat=ierr)
            CALL LogMemAlloc('AllExcDets',(NIfTot+1)*10*AllNoExcDets,4,this_routine,AllExcDetsTag,ierr)
            IF(ierr.ne.0) CALL Stop_All(this_routine,'ERROR allocating memory to AllExcDets.')
            ALLOCATE(AllExcSign(1:(10*AllNoExcDets)),stat=ierr)
            CALL LogMemAlloc('AllExcSign',10*AllNoExcDets,4,this_routine,AllExcSignTag,ierr)
            IF(ierr.ne.0) CALL Stop_All(this_routine,'ERROR allocating memory to AllExcSign.')
        ENDIF


! Now run through the occupied determinants.  If the determinant has the correct excitation level, add it to the ExcDets array, and
! add its sign to the ExcSign array.
        ExcDetsIndex=0
        do i=1,TotWalkers
            ExcitLevel = FindBitExcitLevel(CurrentDets(:,i), iLutHF(:), &
                                           MaxExcDom)
            IF((ExcitLevel.ge.MinExcDom).and.(ExcitLevel.le.MaxExcDom)) THEN
                ExcDetsIndex=ExcDetsIndex+1
                ExcDets(0:NIfTot,ExcDetsIndex)=CurrentDets(0:NIfTot,i)
                ExcSign(ExcDetsIndex)=CurrentSign(i)
            ENDIF
        enddo


! Now need to collect this array on the root processor and find the most populated determinants.
! First set up the RecvCounts and OffSet arrays.

! Need to gather the NoExcDets values from each processor for this.
        CALL MPI_Gather(NoExcDets,1,MPI_INTEGER,RecvCounts,1,MPI_INTEGER,Root,MPI_COMM_WORLD,error)
        
        Offsets(:)=0
        do j=1,nProcessors-1
            OffSets(j+1)=RecvCounts(j)+OffSets(j)
        enddo
        do j=1,nProcessors
            RecvCounts02(j)=RecvCounts(j)*(NIfTot+1)
        enddo
        OffSets02(:)=0
        do j=1,nProcessors-1
            OffSets02(j+1)=RecvCounts02(j)+OffSets02(j)
        enddo

!        do j=1,nProcessors
!            WRITE(6,*) RecvCounts(j),OffSets(j),RecvCounts02(j),OffSets02(j)
!        enddo

        CALL MPI_Barrier(MPI_COMM_WORLD,error)

        CALL MPI_Gatherv(ExcSign(1:NoExcDets),NoExcDets,MPI_INTEGER,AllExcSign(1:AllNoExcDets),&
        &RecvCounts,Offsets,MPI_INTEGER,Root,MPI_COMM_WORLD,error)
        CALL MPI_Gatherv(ExcDets(0:NIfTot,1:NoExcDets),((NIfTot+1)*NoExcDets),MPI_INTEGER,&
        &AllExcDets(0:NIfTot,1:AllNoExcDets),RecvCounts02,Offsets02,MPI_INTEGER,Root,MPI_COMM_WORLD,error)
        CALL FLUSH(6)
       
! Now that we have arrays on the root processor with the determinants and sign of correct excitation level, need to order these 
! in descending absolute value, taking the corresponding sign with it.
        IF(iProcIndex.eq.Root) THEN
 
            IF(iNoDominantDets.gt.AllNoExcDets) THEN
                WRITE(6,*) 'iNoDominantDets: ',iNoDominantDets
                WRITE(6,*) 'AllNoExcDets: ',AllNoExcDets
                CALL Stop_All(this_routine,'Not enough determinants are occupied to pick out the number of dominant requested.')
            ENDIF


            CALL SortBitSign(AllNoExcDets,AllExcSign(1:AllNoExcDets), &
                             AllExcDets(:,1:AllNoExcDets))

! Then run through AllExcSign, finding out how many walkers are on the iNoDominantDets most populated, and counting how
! many have this many walkers or more.
        
            OrigiDominantDets=iNoDominantDets
            MinDomDetPop=0
            MinDomDetPop=ABS(AllExcSign(iNoDominantDets))
            ! This is the minimum number of walkers on the included determinants.
            ! Also want to include determinants with the same number of walkers.
            j=iNoDominantDets+1
            do while (ABS(AllExcSign(j)).eq.MinDomDetPop)
                j=j+1
                iNoDominantDets=iNoDominantDets+1
            enddo
 
            OPEN(39,file='DOMINANTDETSdescpop',status='unknown')
            WRITE(39,*) AllNoExcDets,' determinants with the right excitation level.'    
            WRITE(39,*) iNoDominantDets,' with population ',MinDomDetPop, ' and above.'
            do j=1,AllNoExcDets
                WRITE(39,*) AllExcDets(0:NIfTot,j),AllExcSign(j)
            enddo
            CLOSE(39)
          
            WRITE(6,*) 'This amounts to determinants with population ',MinDomDetPop,' and larger.'
!            WRITE(6,*) 'HFPop',HFPop
!            WRITE(6,*) 'MinDomDetPop',MinDomDetPop
            MinRelDomPop=REAL(MinDomDetPop)/REAL(HFPop)
            WRITE(6,*) 'These determinants have amplitude ; ',MinRelDomPop,' relative to the most populated determinant.' 

! In order to do binary searches for the spin determinants, need to sort the determinants back into order.
! Do this in two separate lots, 1:iNoDominantDets and iNoDominantDets+1:AllNoExcDets

            CALL SortBitDets(iNoDominantDets,AllExcDets(:,1:iNoDominantDets),&
                             AllExcSign(1:iNoDominantDets))
            CALL SortBitDets((AllNoExcDets-iNoDominantDets), &
                             AllExcDets(:,(iNoDominantDets+1):AllNoExcDets), &
                             AllExcSign((iNoDominantDets+1):AllNoExcDets))
 
            OPEN(47,file='DOMINANTDETSsorted',status='unknown')
            WRITE(47,*) AllNoExcDets,' determinants with the right excitation level.'    
            WRITE(47,*) iNoDominantDets,' with population ',MinDomDetPop, ' and above.'
            do j=1,AllNoExcDets
                WRITE(47,*) AllExcDets(0:NIfTot,j),AllExcSign(j)
            enddo
            CLOSE(47)
 

! Run through all the determinants, finding sum_k=1->AllNoExcDets c_k^2 = NormDefTot.  Want to do this before doing the spin
! coupled stuff when some determinants have overwritten others.
            NormDefTot=0
            do i=1,AllNoExcDets
                NormDefTot=NormDefTot+(AllExcSign(i)**2)
            enddo



! Put a bit in here to run through the determinants, construct all the different spin eigenstates from each and make sure 
! they are all included.  - need to add them to the list maintaining order.
! At the moment, these are ordered by determinant, and only the first iNoDominantDets are going to be taken.
! Determinants that are added to the list should be added in order.
            IF(.not.tNoDomSpinCoup) THEN 
                WRITE(6,*) 'Also including determinants that are spin coupled to those in the list of dominant dets.'
                CurriNoDominantDets=iNoDominantDets
                ! The number of DominantDets before including spin coupled ones.
                do j=1,CurriNoDominantDets
                    ! Add the sign from this determinant to the Norm Deficiency calc - this will be in trunc.
                    ! Decode the current determinant
                    CALL DecodeBitDet(DetCurr,AllExcDets(0:NIfTot,j))
!                    WRITE(6,*) 'DetCurrBit',AllExcDets(:,j)
!                    WRITE(6,*) 'DetCurr',DetCurr(:)

                    ! Need to find overall spin of DetCurr
                    SpinTot=0.D0
                    do i=1,NEl
                        SpinTot=SpinTot+G1(DetCurr(i))%Ms
                    enddo
                    IF(SpinTot.ne.(LMS/2)) THEN
                        WRITE(6,*) 'SpinTot',SpinTot
                        WRITE(6,*) 'LMS',LMS
                        CALL FLUSH(6)
                        CALL Stop_All(this_routine,'Error, the summed Ms values of each electon does not equal LMS/2.')
                    ENDIF

                    ! Run through orbitals - creating a list of open shell electrons
                    OpenShell(:,:)=0
                    NoOpenShell=0
                    UpSpin(:)=0
                    NoUpSpin=0
                    SpinCoupDet(:)=0
                    do i=1,NEl
                        ! For an electron of the current det, find the spatial orbital.
!                        ID1 = GTID(DetCurr(i))
                        ID1=CEILING(REAL(DetCurr(i))/2.0)
                        ! Now run through all other orbitals finding out if the same spat orb is occupied.
                        do k=1,NEl
                            IF(k.eq.i) CYCLE 
                            tDoubOcc=.false.
!                            ID2 = GTID(DetCurr(k))
                            ID2=CEILING(REAL(DetCurr(k))/2.0)
                            IF(ID2.eq.ID1) THEN
                                ! doubly occupied orbital, these will be the same in the spin coupled det.
                                SpinCoupDet(i)=DetCurr(i)
                                SpinCoupDet(k)=DetCurr(k)
                                tDoubOcc=.true.
                                EXIT
                            ENDIF
                        enddo
                        IF(.not.tDoubOcc) THEN
                            ! Singly occupied orbitals, put these in the openshell array.
                            ! OpenShell(1,:) - the spatial orbital 
                            ! OpenShell(2,:) - the electron number
                            NoOpenShell=NoOpenShell+1
                            OpenShell(1,NoOpenShell)=ID1
                            OpenShell(2,NoOpenShell)=i
                            IF(mod(DetCurr(i),2).eq.0) NoUpSpin=NoUpSpin+1
!                            IF(G1(DetCurr(i))%Ms.gt.0) NoUpSpin=NoUpSpin+1
                        ENDIF
                    enddo
!                    WRITE(6,*) 'SpinCoup with just doub occ',SpinCoupDet(:)
!                    WRITE(6,*) 'OpenShell(1,:) - spat orbs',OpenShell(1,:)
!                    WRITE(6,*) 'OpenShell(2,:) - electron no.',OpenShell(2,:)

                    CALL gennct(NoOpenShell,NoUpSpin,iComb)
                    ! in the future, change this so that it doesn't print then read, but takes array straight away.

                    OPEN(91,FILE='COMBINATIONS',Status='old')

                    iRead=1
                    do while(iRead.le.iComb) 
                        READ(91,*) UpSpin(1:NoUpSpin)
!                        WRITE(6,*) 'NoUpSpin',NoUpSpin
!                        WRITE(6,*) 'UpSpin',UpSpin(1:NoUpSpin)

                        do i=1,NoOpenShell
                            ! Make all the open shell electrons beta, then overwrite the alpha spin.
                            SpinCoupDet(OpenShell(2,i))=(OpenShell(1,i)*2)-1                    
                        enddo

                        do i=1,NoUpSpin
                            SpinCoupDet(OpenShell(2,(UpSpin(i)+1)))=(OpenShell(1,(UpSpin(i)+1)))*2
                        enddo

                        ! Then have to turn SpinCoupDet into the bit string for binary searching...
!                        WRITE(6,*) 'SpinCoup with beta and alpha',SpinCoupDet(:)

                        CALL EncodeBitDet(SpinCoupDet(1:NEl),SpinCoupDetBit(0:NIfTot))
!                        WRITE(6,*) 'SpinCoupDetBit',SpinCoupDetBit(:)

                        ! First search through the list of dominant determinants.
                        tSuccess=.false.
                        CALL BinSearchDomParts(AllExcDets(0:NIfTot,1:CurriNoDominantDets),SpinCoupDetBit(0:NIfTot),1,CurriNoDominantDets,PartInd,tSuccess)
                        IF(tSuccess) THEN
                            ! Determinant found in the dominant list.
                            iRead=iRead+1
                        ELSE
                            ! If not found in the original dominant determinant list then need to search through the determinants that have been added.
                            IF((iNoDominantDets-CurriNoDominantDets).gt.0) THEN
                                CALL BinSearchDomParts(AllExcDets(0:NIfTot,(CurriNoDominantDets+1):iNoDominantDets),SpinCoupDetBit(0:NIfTot),(CurriNoDominantDets+1),&
                                                    &iNoDominantDets,PartInd,tSuccess)
                                IF((PartInd.le.CurriNoDominantDets).or.(PartInd.gt.iNoDominantDets)) CALL Stop_All(this_routine, '')                                                    
                            ENDIF

                            IF(tSuccess) THEN
                                iRead=iRead+1
                                ! If the determinant has already been added, don't need to do anything.
                            ELSE

                                ! If there are still determinants left in the rest of the list, search through these to check if the determinant is there (to get the sign).
                                IF((AllNoExcDets-iNoDominantDets).gt.0) THEN
                                    CALL BinSearchDomParts(AllExcDets(0:NIfTot,(iNoDominantDets+1):AllNoExcDets),SpinCoupDetBit(0:NIfTot),(iNoDominantDets+1),&
                                                    &AllNoExcDets,PartInd,tSuccess)
                                ENDIF
                                IF(tSuccess) THEN
                                    ! Determinant found in the rest of the list, put it in dom dets along with its sign.
                                    ! Need to insert the determinant in the correct position, so that these added determinants stay ordered.
                                    ! SearchGen will give back ipos so that the determinant we are inserting is < ipos-1 and ge ipos.
                                    ! I.e this determinant goes in ipos and everything else is moved up 1.
                                    IF((iNoDominantDets-CurriNoDominantDets).gt.0) THEN
                                        CALL SearchGen((iNoDominantDets-CurriNoDominantDets),AllExcDets(0:NIfTot,(CurriNoDominantDets+1):iNoDominantDets),&
                                                    &SpinCoupDetBit(0:NIfTot),ipos)
                                    ELSE
                                        ipos=0
                                    ENDIF
                                    ipos=ipos+CurriNoDominantDets
!                                    CALL SearchGen(iNoDominantDets,AllExcDets(0:NIfTot,1:iNoDominantDets),SpinCoupDetBit(0:NIfTot),ipos)
                                    ! The position the determinant should go is ipos, if the current determinant in ipos is not equal to the SpinCoupDetBit,
                                    ! then we want to insert this determinant here, move all the others up by one, put the determinant that is getting written
                                    ! over at iNoDominantDets+1 in the position of the spincoupdetbit.
                                    
                                    TempSign=AllExcSign(iNoDominantDets+1) 
                                    AllExcDets(0:NIfTot,PartInd)=AllExcDets(0:NIfTot,iNoDominantDets+1)

                                    do i=iNoDominantDets,ipos,-1                                                    
                                        AllExcDets(0:NIfTot,i+1)=AllExcDets(0:NIfTot,i)                                                    
                                        AllExcSign(i+1)=AllExcSign(i)
                                    enddo
                                    AllExcDets(0:NIfTot,ipos)=SpinCoupDetBit(0:NIfTot)
                                    AllExcSign(ipos)=AllExcSign(PartInd)
                                    iRead=iRead+1
                                    iNoDominantDets=iNoDominantDets+1
                                    AllExcSign(PartInd)=TempSign
                                ELSE
                                    ! Determinant not in the list at all, add to added determinants (maintaining order) with a sign of 0.
                                    CALL SearchGen((iNoDominantDets-CurriNoDominantDets),AllExcDets(0:NIfTot,(CurriNoDominantDets+1):iNoDominantDets),&
                                                    &SpinCoupDetBit(0:NIfTot),ipos)
                                    ipos=ipos+CurriNoDominantDets
                                    
                                    AllExcDets(0:NIfTot,AllNoExcDets+1)=AllExcDets(0:NIfTot,iNoDominantDets+1)
                                    AllExcSign(AllNoExcDets+1)=AllExcSign(iNoDominantDets+1)

                                    do i=iNoDominantDets,ipos,-1                                                    
                                        AllExcDets(0:NIfTot,i+1)=AllExcDets(0:NIfTot,i)                                                    
                                        AllExcSign(i+1)=AllExcSign(i)
                                    enddo

                                    AllExcDets(0:NIfTot,ipos)=SpinCoupDetBit(0:NIfTot)
                                    AllExcSign(ipos)=0
                                    iRead=iRead+1
                                    iNoDominantDets=iNoDominantDets+1
                                    AllNoExcDets=AllNoExcDets+1
                                ENDIF
                            ENDIF
                        ENDIF
                        IF(iNoDominantDets.gt.(10*AllNoExcDets)) THEN
                            do i=1,iNoDominantDets
                                WRITE(6,*) AllExcDets(:,i),AllExcSign(i)
                            enddo
                            CALL FLUSH(6)
                            CALL Stop_All(this_routine,'No spin coupled dets has reached larger than AllExcDets array can handle.')
                        ENDIF
                    enddo
                    CLOSE(91)
                    ! do that little bit for all spin coupled determinants and then for all determinants currently in the list.       
!                    CALL FLUSH(6)
!                    CALL Stop_All(this_routine,'cos I meant to.')
                enddo
            ENDIF
            WRITE(6,*) 'By including spin coupling ',iNoDominantDets-CurriNoDominantDets,' more determinants are included.'

! Run through all the determinants we are including in the truncated list (i.e. all those to go in the dominant dets list).            
! Count up the squares of the populations to calculate the normalisation deficiency.
            NormDefTrunc=0
            do i=1,iNoDominantDets
                NormDefTrunc=NormDefTrunc+(AllExcSign(i)**2)
            enddo
            NormDef=1.D0-(REAL(NormDefTrunc)/REAL(NormDefTot))
            WRITE(6,*) 'The NORMALISATION DEFICIENCY of such a truncation is : ',NormDef

 
! Now take the iNoDominantDets determinants and reorder them in terms of excitation level and then determinants.
! SortExcitBitDets orders the determinants first by excitation level and then by determinant, taking the corresponding sign with them.        
! We have just fed the first iNoDominantDets from the list ordered in terms of population.
! Only this amount will be reordered by excitation level then determinant, and then we print out this many only.

            CALL SortExcitBitDets(iNoDominantDets,AllExcDets(:,1:iNoDominantDets),AllExcSign(1:iNoDominantDets),iLutHF)
 
!            OPEN(40,file='DOMINANTDETSexclevelbit',status='unknown')
!            WRITE(40,*) AllNoExcDets,' determinants with the right excitation level.'    
!            do j=1,AllNoExcDets
!                ExcitLevel = FindBitExcitLevel(AllExcDets(:,j), iLutHF, &
!                                               MaxExcDom)
!                WRITE(40,*) AllExcDets(0:NIfTot,j),AllExcSign(j),ExcitLevel
!            enddo
!            CLOSE(40)


! Write the iGuideDets most populated determinants (in order of their bit strings) to a file.
            OPEN(38,file='DOMINANTDETS',status='unknown')
            WRITE(38,*) iNoDominantDets,' dominant determinants printed here.'    
            WRITE(38,*) (MaxExcDom-MinExcDom+1),' excitation levels included.'
            
! Need to run through these ordered determinants, counting the number in each excitation level.            
            j=1
            do while (j.le.iNoDominantDets)
                NoExcitLevel=0
                i=j 
                IF(ExcitLevel.ne.(CurrExcitLevel+1)) THEN
                    do k=CurrExcitLevel+1,ExcitLevel-1
                        WRITE(38,*) k,0
                    enddo
                ENDIF
                CurrExcitLevel = FindBitExcitLevel(AllExcDets(:,i), iLutHF, &
                                                   MaxExcDom)
                ExcitLevel=CurrExcitLevel
                do while (ExcitLevel.eq.CurrExcitLevel)
                    NoExcitLevel=NoExcitLevel+1
                    j=j+1
                    IF(j.gt.iNoDominantDets) EXIT
                    ExcitLevel = FindBitExcitLevel(AllExcDets(:,j), iLutHF, &
                                                   MaxExcDom)
                enddo
                WRITE(38,*) CurrExcitLevel,NoExcitLevel
            enddo
            IF(CurrExcitLevel.ne.MaxExcDom) THEN
                do i=CurrExcitLevel+1,MaxExcDom
                    WRITE(38,*) i,0
                enddo
            ENDIF

            do j=1,iNoDominantDets
                WRITE(38,*) AllExcDets(0:NIfTot,j),AllExcSign(j)
            enddo
            CLOSE(38)

            DEALLOCATE(AllExcDets)
            CALL LogMemDealloc(this_routine,AllExcDetsTag)
            DEALLOCATE(AllExcSign)
            CALL LogMemDealloc(this_routine,AllExcSignTag)

        ENDIF

        CALL MPI_Barrier(MPI_COMM_WORLD,error)

        DEALLOCATE(ExcDets)
        CALL LogMemDealloc(this_routine,ExcDetsTag)
        DEALLOCATE(ExcSign)
        CALL LogMemDealloc(this_routine,ExcSignTag)

    END SUBROUTINE PrintDominantDets 


    SUBROUTINE FindMagneticDets()
        use SystemData , only : tAssumeSizeExcitgen
        INTEGER :: j,i,ierr,iMaxExcit,nStore(6),MinIndex,ExcitLength,nJ(NEl),iExcit
        TYPE(HElement) :: Hij,Fjj,Kiitemp
        LOGICAL :: TurnBackAssumeExGen
        INTEGER , ALLOCATABLE :: ExcitGenTemp(:)
        REAL*8 , ALLOCATABLE :: TempMax(:)
        REAL*8 :: MP1Energy,Compt,Kii,MinCompt
        CHARACTER(len=*), PARAMETER :: this_routine='FindMagneticDets'

        WRITE(6,"(A,I8,A)") "Finding the sign of the ",NoMagDets," largest weighted MP1 determinants..."
        IF(tSymmetricField) THEN
            WRITE(6,"(A,F14.6)") "Magnetized determinants will raise/lower the energy of anti-parallel/parallel particles by ",BField
        ELSE
            WRITE(6,"(A,F14.6)") "Magnetized determinants will only raise the energy of anti-parallel particles by ",BField
        ENDIF
        IF(NoMagDets.lt.1) THEN
            CALL Stop_All("FindMagneticDets","Number of determinant signs to find < 1 - exiting...")
        ENDIF
        IF(NoMagDets.eq.1) THEN
            WRITE(6,*) "Only fixing the sign of HF determinant"
        ENDIF
        IF(BField.lt.0.D0) THEN
            CALL Stop_All("FindMagneticDets","Magnetic field cannot be negative...")
        ENDIF

!First allocate memory for chosen determinants. HF path is already stored and has a positive sign by definition, so only store NoMagDets-1 of them
        ALLOCATE(MagDets(NEl,NoMagDets-1),stat=ierr)
        CALL LogMemAlloc('MagDets',NEl*(NoMagDets-1),4,this_routine,MagDetsTag,ierr)
        ALLOCATE(MagDetsSign(NoMagDets-1),stat=ierr)
        CALL LogMemAlloc('MagDetsSign',NoMagDets-1,4,this_routine,MagDetsSignTag,ierr)

!Do an MP1 calculation to find determinants to fix the sign of...
!We do not know if tAssumeSizeExcitgen is on - if it is, then we can't enumerate all determinants. Get around this by simply regenerating it anyway.
!First, we need to turn off AssumeSizeExcitgen if it is on.
        IF(tAssumeSizeExcitgen) THEN
            TurnBackAssumeExGen=.true.
            tAssumeSizeExcitgen=.false.
        ELSE
            TurnBackAssumeExGen=.false.
        ENDIF

        ALLOCATE(TempMax(NoMagDets-1),stat=ierr)   !This will temporarily hold the largest components
        IF(ierr.ne.0) THEN
            CALL Stop_All(this_routine,"Problem allocating memory")
        ENDIF
        TempMax(:)=0.D0
        MP1Energy=0.D0

!Setup excit generators for HF Determinant
        iMaxExcit=0
        nStore(1:6)=0
        CALL GenSymExcitIt2(HFDet,NEl,G1,nBasis,nBasisMax,.TRUE.,ExcitLength,nJ,iMaxExcit,0,nStore,2)
        ALLOCATE(ExcitGenTemp(ExcitLength),stat=ierr)
        IF(ierr.ne.0) CALL Stop_All(this_routine,"Problem allocating excitation generator")
        ExcitGenTemp(1)=0
        CALL GenSymExcitIt2(HFDet,NEl,G1,nBasis,nBasisMax,.TRUE.,ExcitGenTemp,nJ,iMaxExcit,0,nStore,2)

        i=0
        do while(.true.)
!Generate double excitations
            CALL GenSymExcitIt2(HFDet,NEl,G1,nBasis,nBasisMax,.false.,ExcitGenTemp,nJ,iExcit,0,nStore,2)
            IF(IsNullDet(nJ)) EXIT
            i=i+1
            Hij = get_helement (HFDet, nJ, iExcit)
            CALL GetH0Element(nJ,NEl,Arr,nBasis,ECore,Fjj)
            Compt=real(Hij%v,dp)/(Fii-(REAL(Fjj%v,dp)))
            MP1Energy=MP1Energy+((real(Hij%v,dp)**2)/(Fii-(REAL(Fjj%v,dp))))
!Find position of minimum MP1 component stored
            MinCompt=abs(TempMax(1))
            MinIndex=1
            do j=2,NoMagDets-1
                IF(MinCompt.gt.abs(TempMax(j))) THEN
                    MinIndex=j
                    MinCompt=abs(TempMax(j))
                ENDIF
            enddo

!Compare the minimum index MP1 component to the one found from this excitation generated.
            IF(abs(Compt).gt.MinCompt) THEN
                TempMax(MinIndex)=Compt
                MagDets(:,MinIndex)=nJ(:)
                IF(Compt.lt.0) THEN
                    MagDetsSign(MinIndex)=-1
                ELSE
                    MagDetsSign(MinIndex)=1
                ENDIF
            ENDIF
            
        enddo
        WRITE(6,*) i," double excitations found from HF"
        IF(i.lt.NoMagDets-1) THEN
            CALL Stop_All(this_routine,"Not enough double excitations to satisfy number of magnetic determinants requested.")
        ENDIF
        DEALLOCATE(ExcitGenTemp)

        WRITE(6,*) "Determinants picked for magnetisation are (Det   MP1Comp   OrigKii   Kij) :"
        call write_det (6, HFDet, .FALSE.)
        WRITE(6,"(2F14.6)") 1.D0,0.D0
        do j=1,NoMagDets-1
            call write_det (6, MagDets(:,j), .false.)
            Kiitemp = get_helement (MagDets(:,j), MagDets(:,j), 0)
            Kii=REAL(Kiitemp%v,dp)-Hii
            Hij = get_helement (MagDets(:,j), HFDet)
            WRITE(6,"(3F14.6)") TempMax(j),Kii,REAL(Hij%v,dp)
        enddo

        WRITE(6,*) "MP1 ENERGY is: ", MP1Energy

        DEALLOCATE(TempMax)
        
        IF(TurnBackAssumeExGen) THEN
!We turned off assumed sized excitation generators for this routine - turn it back on.
            tAssumeSizeExcitgen=.true.
        ENDIF

        RETURN

    END SUBROUTINE FindMagneticDets

! Simulate Magnetization to break sign symmetry. Death probabiliy is now sign-dependent and given by tau*(Kii-S-Bs_i). B on HF is +ve and sign of particle is s_i.
! This routine simply calculates whether the determinant is magnetic, and how the energy is therefore shifted.
    SUBROUTINE FindDiagElwithB(HDiag,ExcitLevel,nJ,WSign)
        REAL*8 :: HDiag
        LOGICAL :: MagDet,CompiPath
        INTEGER :: ExcitLevel,nJ(NEl),i,WSign
        TYPE(HElement) :: HDiagTemp

        IF(ExcitLevel.eq.0) THEN
!The HF determinant is definitely magnetic and we define the sign of the particles on HF to want to be +ve to be parallel with B
            IF(WSign.eq.1) THEN
!Particle is alligned with B - energy is lower by a value B
                IF(tSymmetricField) THEN
                    HDiag=-BField
                ENDIF
            ELSE
!Particle is antiparallel to B - energy is raised by B
                HDiag=BField
            ENDIF
        
        ELSEIF(ExcitLevel.eq.2) THEN
!We can only tell the sign of the doubles or HF with any certainty. This information is calculated in FindMagneticDets.
!First need to find out if the determinant is one which has been selected to be magnetic
            MagDet=.false.
            do i=1,NoMagDets-1 !Is NoMagDets-1 since the HF det is always magnetic
                IF(CompiPath(nJ,MagDets(:,i),NEl)) THEN
!Determinant is magnetic - now need to find if parallel or antiparallel
                    MagDet=.true.
                    EXIT
                ENDIF
            enddo

            IF(MagDet) THEN
!Determinant is magnetic - first find what the unperturbed energy of the determinant is.
                HDiagTemp = get_helement (nJ, nJ, 0)
                HDiag=(REAL(HDiagTemp%v,dp))-Hii
                
!+ and + wants a +ve number to subtract
!- and - wants a +ve number to subtract
!Else wants a -ve number to subtract (particle is antiparallel)
                IF((WSign*MagDetsSign(i)).eq.1) THEN
!                IF(.not.XOR(WSign,MagDetsSign(i))) THEN
!Particle is correctly alligned. If we have tSymmetricField on, then this lowers the energy. Otherwise, it stays the same.
                    IF(tSymmetricField) THEN
                        HDiag=HDiag-BField
                    ENDIF
                ELSE
!Particle is incorrectly alligned.
                    HDiag=HDiag+BField
                ENDIF

            ELSE
!Double excitation is not magnetic, find diagonal element as normal
                HDiagTemp = get_helement (nJ, nJ, 0)
                HDiag=(REAL(HDiagTemp%v,dp))-Hii
            ENDIF

        ELSE
!Give the child the same diagonal K-matrix element it would normally have.
            HDiagTemp = get_helement (nJ, nJ, 0)
            HDiag=(REAL(HDiagTemp%v,dp))-Hii
        ENDIF

        RETURN

    END SUBROUTINE FindDiagElwithB

!    SUBROUTINE ChooseACFDets()
!        use SystemData , only : tAssumeSizeExcitgen
!        INTEGER :: ierr,HFConn,nStore(6),i,nJ(NEl),iExcit,j,MaxIndex,ExcitLevel,iGetExcitLevel_2
!        INTEGER :: iMaxExcit,ExcitLength,MinInd
!        REAL*8 , ALLOCATABLE :: TempMax(:),ACEnergy(:)
!        LOGICAL :: TurnBackAssumeExGen
!        TYPE(HElement) :: Hij,Hjj,Fjj,Fkk
!        REAL*8 :: Compt,MaxWeight,MinValue
!        INTEGER , ALLOCATABLE :: ExcitGenTemp(:),ACExcLevel(:)
!        CHARACTER(len=*), PARAMETER :: this_routine='ChooseACFDets'
!
!!Commented out code is to just perform the ACF for the HF determinant.
!!            NoAutoDets=1    !Initially, we are just after the ACF for one determinant
!!Fill the autocorrdets array with the determinants that you want to work out the autocorrelation for.
!!            AutoCorrDets(:,1)=HFDet(:)
!
!!The code calculates the ACF for the number of doubles here, or all if it is more
!!        NoAutoDets=10
!!        WRITE(6,"(A,I5,A)") "Choosing the ",NoAutoDets," highest MP1 weight determinants to calculate the ACF for."
!        NoAutoDets=1+NoACDets(2)+NoACDets(3)+NoACDets(4)    !Total number of dets to histogram is sum of the determinants for the individual excitation levels.
!        WRITE(6,"(A,I5,A)") "Choosing the ",NoACDets(2)+1," highest MP1 weight determinants to calculate the ACF for."
!        WRITE(6,"(A,I5,A,I5,A)") "Also picking ",NoACDets(3), " high weighted triply excited and ",NoACDets(4), " quadruply excited determinants."
!        WRITE(6,*) "First determinant will be the HF determinant"
!        CALL GetSymExcitCount(HFExcit%ExcitData,HFConn)
!        IF(NoAutoDets.gt.HFConn) NoAutoDets=HFConn
!        ALLOCATE(AutoCorrDets(NEl,NoAutoDets),stat=ierr)
!        CALL LogMemAlloc('AutoCorrDets',NEl*NoAutoDets,4,this_routine,AutoCorrDetsTag,ierr)
!        AutoCorrDets(:,:)=0
!        
!!Set the first determinant to find the ACF of to be the HF determinant
!        AutoCorrDets(:,1)=HFDet(:)
!
!        ALLOCATE(ACExcLevel(NoAutoDets))
!        ACExcLevel(:)=0
!        ALLOCATE(ACEnergy(NoAutoDets))
!        AcEnergy(:)=0
!
!!We do not know if tAssumeSizeExcitgen is on - if it is, then we can't enumerate all determinants. Get around this by simply regenerating it anyway.
!!First, we need to turn off AssumeSizeExcitgen if it is on.
!        IF(tAssumeSizeExcitgen) THEN
!            TurnBackAssumeExGen=.true.
!            tAssumeSizeExcitgen=.false.
!        ELSE
!            TurnBackAssumeExGen=.false.
!        ENDIF
!
!        ALLOCATE(TempMax(2:NoACDets(2)+1),stat=ierr)   !This will temporarily hold the largest components (+1 since we are no longer considering HF in NoACDets(2))
!        IF(ierr.ne.0) THEN
!            CALL Stop_All("ChooseACFDets","Problem allocating memory")
!        ENDIF
!        TempMax(:)=0.D0
!
!!Setup excit generators for HF Determinant
!        iMaxExcit=0
!        nStore(1:6)=0
!        CALL GenSymExcitIt2(HFDet,NEl,G1,nBasis,nBasisMax,.TRUE.,ExcitLength,nJ,iMaxExcit,0,nStore,2)
!        ALLOCATE(ExcitGenTemp(ExcitLength),stat=ierr)
!        IF(ierr.ne.0) CALL Stop_All("ChooseACFDets","Problem allocating excitation generator")
!        ExcitGenTemp(1)=0
!        CALL GenSymExcitIt2(HFDet,NEl,G1,nBasis,nBasisMax,.TRUE.,ExcitGenTemp,nJ,iMaxExcit,0,nStore,2)
!        ACEnergy(1)=0.D0
!
!        do while(.true.)
!!Generate double excitations
!            CALL GenSymExcitIt2(HFDet,NEl,G1,nBasis,nBasisMax,.false.,ExcitGenTemp,nJ,iExcit,0,nStore,2)
!            IF(nJ(1).eq.0) EXIT
!            Hij=GetHElement2(HFDet,nJ,NEl,nBasisMax,G1,nBasis,Brr,NMsh,fck,NMax,ALat,UMat,iExcit,ECore)
!!            CALL GetH0Element(nJ,NEl,Arr,nBasis,ECore,Hjj)
!!            CALL GetH0Element(HFDet,NEl,Arr,nBasis,ECore,Fii)
!            Compt=real(Hij%v,dp)/(Fii-(REAL(Fjj%v,dp)))
!            MinInd=2
!            MinValue=TempMax(2)
!!First need to find the minimum value to swap out
!            do j=3,NoACDets(2)+1    !NoAutoDets
!                IF(MinValue.gt.TempMax(j)) THEN
!                    MinValue=TempMax(j)
!                    MinInd=j
!                ENDIF
!            enddo
!
!!See if the just calculated value of the MP1 component is larger than the one current minimum.
!            IF(abs(Compt).gt.TempMax(MinInd)) THEN
!                Hjj=GetHElement2(nJ,nJ,NEl,nBasisMax,G1,nBasis,Brr,NMsh,fck,NMax,ALat,UMat,0,ECore)
!                TempMax(MinInd)=abs(Compt)
!                AutoCorrDets(:,MinInd)=nJ(:)
!                ACExcLevel(MinInd)=2
!                ACEnergy(MinInd)=real(Hjj%v,dp)-Hii
!            ENDIF
!
!!            do j=2,NoACDets(2)+1!NoAutoDets
!!                IF(abs(Compt).gt.TempMax(j)) THEN
!!                    TempMax(j)=abs(Compt)
!!                    AutoCorrDets(:,j)=nJ(:)
!!                    ACExcLevel(j)=2
!!                    ACEnergy(j)=real(Fjj%v,dp)
!!                    EXIT
!!                ENDIF
!!            enddo
!            
!        enddo
!        DEALLOCATE(ExcitGenTemp)
!!Find largest weight MP1 contribution
!        MaxWeight=0.D0
!        do i=2,NoACDets(2)+1
!            IF(TempMax(i).gt.MaxWeight) THEN
!                MaxIndex=i
!            ENDIF
!        enddo
!        DEALLOCATE(TempMax)
!        
!!        IF(iProcIndex.eq.root) THEN
!!            WRITE(6,*) "*** Histogramming the following determinants:"
!!            do i=1,NoAutoDets
!!                do j=1,NEl
!!                    WRITE(6,"(I4)",advance='no') AutoCorrDets(j,i)
!!                enddo
!!                WRITE(6,*) ""
!!            enddo
!!        ENDIF
!
!!We have now found the largest weight Doubles. To guess at large weighted triples & quads, we simply take the largest weighted double, and find 
!!its large MP1 weighted contributions with it as the reference.
!!        WRITE(6,*) "MaxIndex = ", MaxIndex
!!Setup excit generators for the highest weighted double excitation
!        iMaxExcit=0
!        nStore(1:6)=0
!        CALL GenSymExcitIt2(AutoCorrDets(:,MaxIndex),NEl,G1,nBasis,nBasisMax,.TRUE.,ExcitLength,nJ,iMaxExcit,0,nStore,3)
!        ALLOCATE(ExcitGenTemp(ExcitLength),stat=ierr)
!        IF(ierr.ne.0) CALL Stop_All("ChooseACFDets","Problem allocating excitation generator")
!        ExcitGenTemp(1)=0
!        CALL GenSymExcitIt2(AutoCorrDets(:,MaxIndex),NEl,G1,nBasis,nBasisMax,.TRUE.,ExcitGenTemp,nJ,iMaxExcit,0,nStore,3)
!
!        CALL GetH0Element(AutoCorrDets(:,MaxIndex),NEl,Arr,nBasis,ECore,Fjj)
!        ALLOCATE(TempMax(1:(NoACDets(3)+NoACDets(4))),stat=ierr)
!        TempMax(:)=0.D0
!
!        do while(.true.)
!            CALL GenSymExcitIt2(AutoCorrDets(:,MaxIndex),NEl,G1,nBasis,nBasisMax,.false.,ExcitGenTemp,nJ,iExcit,0,nStore,3)
!            IF(nJ(1).eq.0) EXIT
!            Hij=GetHElement2(AutoCorrDets(:,MaxIndex),nJ,NEl,nBasisMax,G1,nBasis,Brr,NMsh,fck,NMax,ALat,UMat,iExcit,ECore)
!            CALL GetH0Element(nJ,NEl,Arr,nBasis,ECore,Fkk)
!            Compt=real(Hij%v,dp)/(real(Fjj%v,dp)-(real(Fkk%v,dp)))
!            ExcitLevel=iGetExcitLevel_2(HFDet,nJ,NEl,4)
!            IF(ExcitLevel.eq.3) THEN
!!We have generated a triple - try to add it to the list
!                do j=1,NoACDets(3)
!                    IF(abs(Compt).gt.TempMax(j)) THEN
!                        Hjj=GetHElement2(nJ,nJ,NEl,nBasisMax,G1,nBasis,Brr,NMsh,fck,NMax,ALat,UMat,0,ECore)
!                        TempMax(j)=abs(Compt)
!                        AutoCorrDets(:,(j+1+NoACDets(2)))=nJ(:)
!                        ACExcLevel(j+1+NoACDets(2))=3
!                        ACEnergy(j+1+NoACDets(2))=real(Hjj%v,dp)-Hii
!                        EXIT
!                    ENDIF
!                enddo
!            ELSEIF(ExcitLevel.eq.4) THEN
!!We have generated a quad - try to add it to the list
!                do j=NoACDets(3)+1,(NoACDets(3)+NoACDets(4))
!                    IF(abs(Compt).gt.TempMax(j)) THEN
!                        Hjj=GetHElement2(nJ,nJ,NEl,nBasisMax,G1,nBasis,Brr,NMsh,fck,NMax,ALat,UMat,0,ECore)
!                        TempMax(j)=abs(Compt)
!                        AutoCorrDets(:,(j+1+NoACDets(2)))=nJ(:)
!                        ACExcLevel(j+1+NoACDets(2))=4
!                        ACEnergy(j+1+NoACDets(2))=real(Hjj%v,dp)-Hii
!                        EXIT
!                    ENDIF
!                enddo
!            ENDIF
!        enddo
!
!!Deallocate TempExcitgen
!        DEALLOCATE(TempMax)
!!        CALL DissociateExitgen(ExcitGenTemp)
!        DEALLOCATE(ExcitGenTemp)
!        
!!Find if any zeros
!        do i=1,NoAutoDets
!            IF(AutoCorrDets(1,i).eq.0) THEN
!!                NoAutoDets=NoAutoDets-1
!                WRITE(6,*) "Could not find AutoCorrFunc determinant to histogram slot ",i
!!Move these zeros to the end of the list
!                do j=i,NoAutoDets
!                    IF(AutoCorrDets(1,j).ne.0) THEN
!                        AutoCorrDets(:,i)=AutoCorrDets(:,j)
!                        ACExcLevel(i)=ACExcLevel(j)
!                        ACEnergy(i)=ACEnergy(j)
!                        EXIT
!                    ENDIF
!                enddo
!                NoAutoDets=NoAutoDets-1
!            ENDIF
!        enddo
!            
!!The number of occurunces of walkers at the determiants selected needs to be stored for all iterations
!        ALLOCATE(WeightatDets(NoAutoDets),stat=ierr)
!        CALL LogMemAlloc('WeightatDets',NoAutoDets,4,this_routine,WeightatDetsTag,ierr)
!        WeightatDets(:)=0
!!If we want to calculate the ACF, then we now do this in a seperate step. Now we simply write out the determinant populations at each iteration
!!to a file called HFDoublePops
!        
!        IF(iProcIndex.eq.root) THEN
!            WRITE(6,*) "Histogramming the following determinants:"
!            do i=1,NoAutoDets
!                do j=1,NEl
!                    WRITE(6,"(I4)",advance='no') AutoCorrDets(j,i)
!                enddo
!                WRITE(6,*) ""
!            enddo
!
!            OPEN(44,FILE='HFDoublePops',STATUS='UNKNOWN')
!            WRITE(44,*) 'Energy of determinant'
!            WRITE(44,"(A8)",advance='no') "-"
!            do i=1,NoAutoDets
!                WRITE(44,"(F20.10)",advance='no') ACEnergy(i)
!            enddo
!            WRITE(44,*) 'Excitation level'
!            WRITE(44,"(A8)",advance='no') "-"
!            do i=1,NoAutoDets
!                WRITE(44,"(I8)",advance='no') ACExcLevel(i)
!            enddo
!            WRITE(44,"(/,A14,5X,A23)") "Iteration No.","Determinant Populations"
!        ENDIF
!
!        DEALLOCATE(ACExcLevel)
!        DEALLOCATE(ACEnergy)
!
!        IF(TurnBackAssumeExGen) THEN
!!We turned off assumed sized excitation generators for this routine - turn it back on.
!            tAssumeSizeExcitgen=.true.
!        ENDIF
!
!        RETURN
!
!    END SUBROUTINE ChooseACFDets
!
!
!    
!!This is a routine to create a graph from the walker at nI, and ascribe new walkers at each vertex on the graph, according to a number of applications of the rho matrix.
!    SUBROUTINE ResumGraphPar(nI,WSign,VecSlot,VecInd)
!        INTEGER :: nI(NEl),VecSlot,VecInd
!        LOGICAL :: WSign
!        REAL*8 :: Prob
!
!!This routine will create the graph. It will calculate it differently depending on the size of the graph, and whether excitation generators are stored. 
!        CALL CreateGraphPar(nI,VecInd,Prob)
!
!!Apply the rho matrix successive times. This could be improved if large numbers of applications of rho are needed by diagonalising the rho matrix
!        CALL ApplyRhoMatPar()
!        
!        IF(.not.tRegenDiagHEls) THEN
!            CALL CreateNewPartsPar(nI,VecInd,WSign,CurrentH(VecInd),VecSlot,Prob)   !Create particles proportionally to the magnitude of the vector elements in GraphVec
!        ELSE
!            CALL Stop_All("ResumGraphPar","ResumGraphPar does not work with regendiaghels.")
!        ENDIF
!
!        RETURN
!
!    END SUBROUTINE ResumGraphPar
!
!!This routine will create a graph from a given initial determinant
!    SUBROUTINE CreateGraphPar(nI,VecInd,Prob)
!        TYPE(ExcitPointer) :: TempExcitgen
!        INTEGER :: nI(NEl),nJ(NEl),VecInd,i,j,IC,iCount,Attempts
!        REAL*8 :: Prob,ExcitProb
!        LOGICAL :: SameDet,CompiPath
!        TYPE(HElement) :: Hij,Hjj
!
!        IF(tRegenDiagHEls) THEN
!            CALL Stop_All("CreateGraphPar","CreateGraphPar will not work with RegenDiagHEls")
!        ENDIF
!
!        TempExcitgen%PointToExcit=>null()
!
!!First, set up the excitation generators for the root determinant
!        IF(.not.TRegenExcitgens) THEN
!            CALL SetupExitgenPar(nI,CurrentExcits(VecInd))
!        ELSE
!            CALL SetupExitgenPar(nI,TempExcitgen)
!        ENDIF
!
!        IF(NDets.eq.2) THEN
!!We know that determinants are not going to be regenerated if NDets=2, so we can do this in a slightly simpler way
!            
!            IF(TRegenExcitgens) THEN
!                CALL GenRandSymExcitIt3(nI,TempExcitgen%PointToExcit,nJ,0,IC,0,Prob,iCount)
!            ELSE
!                CALL GenRandSymExcitIt3(nI,CurrentExcits(VecInd)%PointToExcit,nJ,0,IC,0,Prob,iCount)
!            ENDIF
!
!            Hij=GetHElement2(nI,nJ,NEl,nBasisMax,G1,nBasis,Brr,NMsh,fck,NMax,ALat,UMat,IC,ECore)
!            Hjj=GetHElement2(nJ,nJ,NEl,nBasisMax,G1,nBasis,Brr,NMsh,fck,NMax,ALat,UMat,0,ECore)
!
!            GraphRhoMat(1,1)=1.D0-Tau*(CurrentH(VecInd)-DiagSft)
!            GraphRhoMat(1,2)=-Tau*real(Hij%v,dp)
!            GraphRhoMat(2,1)=GraphRhoMat(1,2)
!            GraphRhoMat(2,2)=1.D0-Tau*((real(Hjj%v,dp)-Hii)-DiagSft)
!                
!            DetsinGraph(:,2)=nJ(:)
!            GraphKii(2)=REAL(Hjj%v,dp)-Hii              !store det generated and kii element
!
!        ELSE
!!Zero the matrix
!            GraphRhoMat(1:NDets,1:NDets)=0.D0
!            
!            GraphRhoMat(1,1)=1.D0-Tau*(CurrentH(VecInd)-DiagSft)    !This is the first rho-matrix element
!
!            i=2
!            Attempts=0
!            do while(i.lt.NDets)    !Loop until all determinants found
!
!                IF(TRegenExcitgens) THEN
!                    CALL GenRandSymExcitIt3(nI,TempExcitgen%PointToExcit,nJ,0,IC,0,Prob,iCount)
!                ELSE
!                    CALL GenRandSymExcitIt3(nI,CurrentExcits(VecInd)%PointToExcit,nJ,0,IC,0,Prob,iCount)
!                ENDIF
!
!                SameDet=.false.
!                do j=2,(i-1)
!                    IF(CompiPath(nJ,DetsinGraph(:,j),NEl)) THEN
!!Determinants are the same as already created determinant - ignore it
!
!                        SameDet=.true.
!                        Attempts=Attempts+1
!                        IF(Attempts.gt.1000) THEN
!                            WRITE(6,*) "iCOUNT IS: ", iCount
!                            CALL FLUSH(6)
!                            CALL Stop_All("CreateGraphPar","More than 1000 attempts needed to grow graph")
!                        ENDIF
!                        EXIT
!                    ENDIF
!                enddo
!
!                IF(.not.SameDet) THEN
!!Store the unbiased probability of generating excitations from this root - check that it is the same as other excits generated
!                    IF(i.eq.2) THEN
!                        ExcitProb=Prob
!                    ELSE
!                        IF(abs(Prob-ExcitProb).gt.1.D-07) THEN
!                            CALL Stop_All("CreateGraph","Excitation probabilities are not uniform - problem here...")
!                        ENDIF
!                    ENDIF
!
!!Determinant is distinct - add it
!                    DetsinGraph(1:NEl,i)=nJ(1:NEl)
!!First find connection to root
!                    Hij=GetHElement2(nI,nJ,NEl,nBasisMax,G1,nBasis,Brr,NMsh,fck,NMax,ALat,UMat,IC,ECore)
!                    GraphRhoMat(1,i)=-Tau*REAL(Hij%v,dp)
!                    GraphRhoMat(i,1)=GraphRhoMat(1,i)
!
!!Then find connection to other determinants
!                    do j=2,(i-1)
!                        Hij=GetHElement2(nJ,DetsInGraph(:,j),NEl,nBasisMax,G1,nBasis,Brr,NMsh,fck,NMax,ALat,UMat,-1,ECore)
!                        GraphRhoMat(i,j)=-Tau*REAL(Hij%v,dp)
!                        GraphRhoMat(j,i)=GraphRhoMat(i,j)
!                    enddo
!
!!Find diagonal element - and store it for later on...
!                    Hjj= GetHElement2(HighEDet,HighEDet,NEl,nBasisMax,G1,nBasis,Brr,NMsh,fck,NMax,ALat,UMat,0,ECore)
!                    GraphKii(i)=REAL(Hjj%v,dp)-Hii                !Again, the root value is not stored
!                    GraphRhoMat(i,i)=1.D0-Tau*(GraphKii(i)-DiagSft)
!
!                    i=i+1
!
!                ENDIF
!            enddo
!
!        ENDIF   !End if ndets=2
!
!        IF(TRegenExcitgens) THEN
!!Deallocate excitation generator if we are regenerating them
!            CALL DissociateExitgen(TempExcitgen)
!        ENDIF
!
!        RETURN
!
!    END SUBROUTINE CreateGraphPar
!
!    
!!This routine creates new particles from the vector which results from the 
!    SUBROUTINE CreateNewPartsPar(nI,VecInd,WSign,Kii,VecSlot,Prob)
!        IMPLICIT NONE
!        LOGICAL :: WSign,TempSign
!        INTEGER :: nI(NEl),VecInd
!        INTEGER :: i,j,VecSlot,Create,ExcitLevel,iGetExcitLevel_2
!        INTEGER(KIND=i2) :: HashTemp
!        REAL*8 :: rat,Kii,Kjj,Prob,r
!
!!First deal with the excitations...
!        do i=2,NDets
!!Now create the new particles according the the final vector GraphVec
!            
!            GraphVec(i)=GraphVec(i)/((NDets-1)*Prob)    !Augment the component by the chances of picking that determinant
!    
!            Create=INT(abs(GraphVec(i)))
!            rat=abs(GraphVec(i))-REAL(Create,dp)    !rat is now the fractional part, to be assigned stochastically
!            IF(tMerTwist) THEN
!                r = genrand_real2_dSFMT() 
!            ELSE
!                CALL RANLUX(r,1)
!            ENDIF
!            IF(rat.gt.r) Create=Create+1
!            IF(abs(Create).gt.0) THEN
!                IF(.not.WSign) Create=-Create
!                IF(GraphVec(i).lt.0.D0) Create=-Create
!!Find needed information out about the new particles
!!Calculate excitation level, connection to HF. Diagonal ham element info is already stored
!                
!                ExcitLevel=iGetExcitLevel_2(HFDet,DetsinGraph(:,i),NEl,NEl)
!                IF(ExcitLevel.eq.0) THEN
!                    IF(ABS(GraphKii(i)).gt.1.D-07) THEN
!                        CALL Stop_All("ResumGraphPar","Diagonal K-mat element should be zero for HF particles")
!                    ENDIF
!                ENDIF
!                IF(Create.lt.0) THEN
!                    TempSign=.false.
!                ELSE
!                    TempSign=.true.
!                ENDIF
!                
!                IF(.not.TNoAnnihil) THEN
!!                IF((.not.TNoAnnihil).and.(.not.TAnnihilonproc)) THEN
!                    HashTemp=CreateHash(DetsInGraph(:,i))
!                ENDIF
!                
!!Now actually create the particles in NewDets and NewSign
!                do j=1,abs(Create)
!                    NewDets(1:NEl,VecSlot)=DetsInGraph(1:NEl,i)
!                    NewSign(VecSlot)=TempSign
!!                    NewIC(VecSlot)=ExcitLevel
!                    IF(.not.tRegenDiagHEls) NewH(VecSlot)=GraphKii(i)       !Diagonal H El previously stored
!                    IF(.not.TRegenExcitgens) NewExcits(VecSlot)%PointToExcit=>null()
!                    IF(.not.TNoAnnihil) THEN
!!                    IF((.not.TNoAnnihil).and.(.not.TAnnihilonproc)) THEN
!                        Hash2Array(VecSlot)=HashTemp
!                    ENDIF
!                    VecSlot=VecSlot+1
!                enddo
!
!            ENDIF
!
!        enddo
!
!!Now deal with root
!        Create=INT(abs(GraphVec(1)))
!
!        rat=abs(GraphVec(1))-REAL(Create,dp)    !rat is now the fractional part, to be assigned stochastically
!        IF(tMerTwist) THEN
!            r = genrand_real2_dSFMT() 
!        ELSE
!            CALL RANLUX(r,1)
!        ENDIF
!        IF(rat.gt.r) Create=Create+1
!        
!        IF((abs(Create)).gt.0) THEN
!        
!            IF(.not.WSign) Create=-Create
!            IF(GraphVec(1).lt.0.D0) Create=-Create
!
!!Test since the root should not change sign - comment out later
!            IF(WSign.and.(Create.lt.0)) THEN
!                call Stop_All("CreateNewPartsPar","Root determinant should not change sign")
!            ELSEIF((.not.WSign).and.(Create.gt.0)) THEN
!                call Stop_All("CreateNewPartsPar","Root determinant should not change sign")
!            ENDIF
!            
!            IF(Create.lt.0) THEN
!                TempSign=.false.
!            ELSE
!                TempSign=.true.
!            ENDIF
!
!!Now actually create the particles in NewDets and NewSign. It is the same particle as the parent particle.
!            do j=1,abs(Create)
!                NewDets(:,VecSlot)=nI(:)
!                NewSign(VecSlot)=TempSign
!!Copy excitation generator accross
!                IF(j.eq.abs(Create)) THEN
!                    IF(.not.TRegenExcitgens) CALL CopyExitgenPar(CurrentExcits(VecInd),NewExcits(VecSlot),.true.)
!                ELSE
!                    IF(.not.TRegenExcitgens) CALL CopyExitgenPar(CurrentExcits(VecInd),NewExcits(VecSlot),.false.)
!                ENDIF
!!                NewIC(VecSlot)=CurrentIC(VecInd)
!                IF(.not.tRegenDiagHEls) NewH(VecSlot)=CurrentH(VecInd)
!                IF(.not.TNoAnnihil) THEN
!!                IF((.not.TNoAnnihil).and.(.not.TAnnihilonproc)) THEN
!                    Hash2Array(VecSlot)=HashArray(VecInd)
!                ENDIF
!                VecSlot=VecSlot+1
!            enddo
!
!        ENDIF
!
!        RETURN
!
!    END SUBROUTINE CreateNewPartsPar
!
!!This applies the rho matrix successive times to a root determinant. From this, GraphVec is filled with the correct probabilities for the determinants in the graph
!    SUBROUTINE ApplyRhoMatPar()
!        REAL*8 :: TempVec(NDets)
!        INTEGER :: i,j,k
!
!!        IF(NDets.eq.2) THEN
!!
!!            GraphVec(1)=1.D0
!!            GraphVec(2)=0.D0
!!
!!            do i=1,RhoApp
!!            
!!                TempVec(1)=(GraphRhoMat(1,1)*GraphVec(1))+(GraphRhoMat(1,2)*GraphVec(2))
!!                TempVec(2)=(GraphRhoMat(2,1)*GraphVec(1))+(GraphRhoMat(2,2)*GraphVec(2))
!!            
!!                GraphVec(1)=TempVec(1)
!!                GraphVec(2)=TempVec(2)
!!
!!            enddo
!!
!!        ELSE
!            
!            GraphVec(1:NDets)=0.d0
!            GraphVec(1)=1.D0        !Set the initial vector to be 1 at the root (i.e. for one walker initially)
!        
!            do i=1,RhoApp
!
!                CALL DGEMV('n',NDets,NDets,1.D0,GraphRhoMat,NDets,GraphVec,1,0.D0,TempVec,1)
!                GraphVec(1:NDets)=TempVec(1:NDets)
!                TempVec(1:NDets)=0.d0
!            
!!            do j=1,NDets
!!                TempVec(j)=0.D0
!!                do k=1,NDets
!!                    TempVec(j)=TempVec(j)+GraphRhoMat(j,k)*GraphVec(k)
!!                enddo
!!            enddo
!!            GraphVec(:)=TempVec(:)
!
!            enddo
!
!!        ENDIF
!
!        RETURN
!    END SUBROUTINE ApplyRhoMatPar
!
!
!
!    
!!A routine to annihilate particles separatly on each node. This should mean less annihilation occurs, but it is effect running nProcessors separate simulations.
!!If there are enough particles, then this should be sufficient. Less memory is required, since no hashes need to be stored. Also, no communication is needed,
!!so the routine should scale better as the number of walkers grows.
!    SUBROUTINE AnnihilateonProc(TotWalkersNew)
!        TYPE(ExcitPointer) :: TempExcit
!        REAL*8 :: TempH
!!        INTEGER :: TempIC
!        INTEGER :: TotWalkersNew,j,k,l,DetCurr(0:NIfTot),VecSlot,TotWalkersDet
!        INTEGER :: DetLT
!
!        TempExcit%PointToExcit=>null()
!!First, it is necessary to sort the list of determinants
!        CALL SortPartsPar(TotWalkersNew,NewDets(:,1:TotWalkersNew),NIfTot+1)
!
!!Once ordered, each block of walkers on similar determinants can be analysed, and the residual walker concentration moved to CurrentDets
!        j=1
!!j is the counter over all uncancelled walkers - it indicates when we have reached the end of the list of total walkers
!!DetCurr is the current determinant
!        DetCurr(:)=NewDets(:,j)
!!        TempIC=NewIC(j)
!        IF(.not.tRegenDiagHEls) TempH=NewH(j)
!        IF(.not.TRegenExcitgens) CALL CopyExitgenPar(NewExcits(j),TempExcit,.true.) !This will delete what is behind it - is that ok?
!        
!        VecSlot=1
!
!        do while(j.le.TotWalkersNew)
!!Loop over all walkers
!            TotWalkersDet=0
!            do while ((DetLT(NewDets(:,j),DetCurr,(NIfTot+1)).eq.0).and.(j.le.TotWalkersNew))
!!Loop over all walkers on DetCurr and count residual number after cancelling
!                IF(NewSign(j)) THEN
!                    TotWalkersDet=TotWalkersDet+1
!                ELSE
!                    TotWalkersDet=TotWalkersDet-1
!                ENDIF
!                j=j+1
!            enddo
!!Transfer residual population into VecSlot, along with residual sign
!            IF(TotWalkersDet.gt.0) THEN
!!Positive sign particles want to populate this determinant
!                do l=1,abs(TotWalkersDet)
!                    CurrentDets(:,VecSlot)=DetCurr(:)
!                    CurrentSign(VecSlot)=1
!!                    CurrentIC(VecSlot)=TempIC
!                    IF(.not.tRegenDiagHEls) CurrentH(VecSlot)=TempH
!                    IF(.not.TRegenExcitgens) CALL CopyExitgenPar(TempExcit,CurrentExcits(VecSlot),.false.)
!                    VecSlot=VecSlot+1
!                enddo
!            ELSE
!!Negative sign particles want to populate this determinant
!                do l=1,abs(TotWalkersDet)
!                    CurrentDets(:,VecSlot)=DetCurr(:)
!                    CurrentSign(VecSlot)=1
!!                    CurrentIC(VecSlot)=TempIC
!                    IF(.not.tRegenDiagHEls) CurrentH(VecSlot)=TempH
!                    IF(.not.TRegenExcitgens) CALL CopyExitgenPar(TempExcit,CurrentExcits(VecSlot),.false.)
!                    VecSlot=VecSlot+1
!                enddo
!            ENDIF
!!Now update the current determinant
!            DetCurr(:)=NewDets(:,j)
!!            TempIC=NewIC(j)
!            IF(.not.tRegenDiagHEls) TempH=NewH(j)
!            IF(.not.TRegenExcitgens) THEN
!                CALL DissociateExitGen(TempExcit)
!                CALL CopyExitGenPar(NewExcits(j),TempExcit,.true.)
!            ENDIF
!        enddo
!!The new number of residual cancelled walkers is given by one less that VecSlot again.
!        TotWalkers=VecSlot-1
!
!        RETURN
!
!    END SUBROUTINE AnnihilateonProc
!
!!This routine sorts the particles before annihilation. It is identical to the routine in the serial version, but the data which is taken is different.
!! Based on SORTI, SORTPARTS sorts arrays of integers, representing the determinant the walkers are on
!! It then takes all the corresponding info with it
!! Dets is the array (length N) of integers to sort
!! NElecs is the length (in numbers of integers) of each element of Dets
!! Vectors of NewXXX will be sorted correspondingly
!    SUBROUTINE SortPartsPar(N,Dets,NElecs)
!        TYPE(ExcitPointer) :: ExcitTemp
!        REAL*8 :: HTemp
!!        INTEGER :: ICTemp
!        INTEGER :: TempDet(NElecs)     !This stores a single element of the vector temporarily     
!        INTEGER :: WSignTemp
!        INTEGER N,I,L,IR,J,NElecs
!        INTEGER Dets(NElecs,N)
!        INTEGER DETLT
!
!        ExcitTemp%PointToExcit=>null()
!        IF(N.LE.1) RETURN
!        L=N/2+1 
!        IR=N
!10      CONTINUE
!        IF(L.GT.1)THEN
!            L=L-1
!            TempDet(:)=Dets(:,L)
!            IF(.not.tRegenDiagHEls) HTemp=NewH(L)
!!            ICTemp=NewIC(L)
!            WSignTemp=NewSign(L)
!            IF(.not.TRegenExcitgens) CALL CopyExitgenPar(NewExcits(L),ExcitTemp,.true.) !This will delete what is behind it - is this ok?
!        ELSE
!            TempDet(:)=Dets(:,IR)      !Copy IRth elements to temp
!            IF(.not.tRegenDiagHEls) HTemp=NewH(IR)
!!            ICTemp=NewIC(IR)
!            WSignTemp=NewSign(IR)
!            IF(.not.TRegenExcitgens) CALL CopyExitgenPar(NewExcits(IR),ExcitTemp,.true.)
!
!            Dets(:,IR)=Dets(:,1)    !Copy 1st element to IRth element
!            IF(.not.tRegenDiagHEls) NewH(IR)=NewH(1)
!!            NewIC(IR)=NewIC(1)
!            NewSign(IR)=NewSign(1)
!            IF(.not.TRegenExcitgens) CALL CopyExitgenPar(NewExcits(1),NewExcits(IR),.true.)
!            IR=IR-1
!            IF(IR.EQ.1)THEN
!                Dets(:,1)=TempDet(:)    !Copy temp element to 1st element
!                IF(.not.tRegenDiagHEls) NewH(1)=HTemp
!!                NewIC(1)=ICTemp
!                NewSign(1)=WSignTemp
!                IF(.not.TRegenExcitgens) CALL CopyExitgenPar(ExcitTemp,NewExcits(1),.true.)
!                RETURN
!            ENDIF
!        ENDIF
!        I=L
!        J=L+L
!20      IF(J.LE.IR)THEN
!            IF(J.LT.IR)THEN
!                IF((DETLT(Dets(1,J),Dets(1,J+1),NElecs)).eq.-1) J=J+1
!            ENDIF
!            IF((DETLT(TempDet,Dets(1,J),NElecs)).eq.-1)THEN
!                Dets(:,I)=Dets(:,J)     !Copy Jth element to Ith element
!                IF(.not.tRegenDiagHEls) NewH(I)=NewH(J)
!!                NewIC(I)=NewIC(J)
!                NewSign(I)=NewSign(J)
!                IF(.not.TRegenExcitgens) CALL CopyExitgenPar(NewExcits(J),NewExcits(I),.true.)
!                I=J
!                J=J+J
!            ELSE
!                J=IR+1
!            ENDIF
!            GO TO 20
!        ENDIF
!        Dets(:,I)=TempDet(:)
!        IF(.not.tRegenDiagHEls) NewH(I)=HTemp
!!        NewIC(I)=ICTemp
!        NewSign(I)=WSignTemp
!        IF(.not.TRegenExcitgens) CALL CopyExitgenPar(ExcitTemp,NewExcits(I),.true.)
!        GO TO 10
!
!    END SUBROUTINE SortPartsPar

!This routine calculates the autocorrelation function for the determinants listed in AutoCorrDets array, with lags from iLagMin to iLagMax in steps of iLagStep
!and writes it to a file ACF. The calculation is done in serial. It is not trivial to turn it into an efficient parallel algorithm
!The autocorrelation function is now calculated in a seperate standalone program. The occupations at each point are simply printed out.
!    SUBROUTINE CalcAutoCorr()
!        INTEGER :: i,j,k,error
!        REAL*8 :: Means(NoAutoDets),NVar(NoAutoDets),ACF(NoAutoDets)!,AllACF(NoAutoDets)
!        REAL*8 :: Norm(NoAutoDets)
!!        REAL*8 :: TestVar(NoAutoDets)
!        INTEGER :: SumSquares(NoAutoDets),SumWeights(NoAutoDets),ierr
!        INTEGER , ALLOCATABLE :: AllWeightatDets(:,:)
!        INTEGER :: AllWeightatDetsTag=0,NoCounts
!        CHARACTER(len=*), PARAMETER :: this_routine='CalcAutoCorr'
!        
!        CALL set_timer(ACF_Time,30)
!        
!        IF((iLagMax.lt.0).or.(iLagMax.gt.Iter/2)) THEN
!            iLagMax=Iter/2
!        ENDIF
!        IF(iProcIndex.eq.root) THEN
!            OPEN(43,FILE='AutoCorrFunc',STATUS='UNKNOWN')
!        ENDIF
!
!        WRITE(6,"(A,I8,A,I8,A,I8,A)") "Calculating the ACF with lags from ",iLagMin," to ",iLagMax," in steps of ",iLagStep," and writing it to file 'ACF'"
!        WRITE(6,*) "Calculating the ACF for the following determinants:"
!        do i=1,NoAutoDets
!            do j=1,NEl
!                WRITE(6,"(I4)",advance='no') AutoCorrDets(j,i)
!            enddo
!            WRITE(6,*) ""
!        enddo
!        CALL FLUSH(6)
!        CALL MPI_Barrier(MPI_COMM_WORLD,error)
!
!        ALLOCATE(AllWeightatDets(NoAutoDets,Iter),stat=ierr)
!        CALL LogMemAlloc('AllWeightatDets',NoAutoDets*Iter,4,this_routine,AllWeightatDetsTag,ierr)
!        AllWeightatDets(:,:)=0
!!        WRITE(6,*) Iter
!!        do i=1,Iter
!!            do j=1,NoAutoDets
!!                WRITE(6,'(I10)',advance='no') WeightatDets(j,i)
!!            enddo
!!            WRITE(6,*) ""
!!        enddo
!!        WRITE(6,*) "*****************"
!
!        NoCounts=NoAutoDets*Iter
!!Initially, we will calculate this ACF in serial - this will be easier as there are subtle effects in parallel.
!        CALL MPI_Reduce(WeightatDets(1:NoAutoDets,1:Iter),AllWeightatDets(1:NoAutoDets,1:Iter),NoCounts,MPI_INTEGER,MPI_SUM,root,MPI_COMM_WORLD,error)
!!        do i=1,Iter
!!            do j=1,NoAutoDets
!!                WRITE(6,'(I10)',advance='no') AllWeightatDets(j,i)
!!            enddo
!!            WRITE(6,*) ""
!!        enddo
!!        CALL FLUSH(6)
!
!        IF(iProcIndex.eq.root) THEN
!            OPEN(44,FILE='DoublePops',STATUS='UNKNOWN')
!            do i=1,Iter
!                WRITE(44,"(2I8)",advance='no') i,AllWeightatDets(1,i)
!                do k=2,NoAutoDets-1
!                    WRITE(44,"(I8)",advance='no') AllWeightatDets(k,i)
!                enddo
!                WRITE(44,"(I8)") AllWeightatDets(NoAutoDets,i) 
!            enddo
!            CLOSE(44)
!
!!First, we need to calculate the average value for each of the determinants - this could be calculated during the simulation
!!We also want to divide the ACF components by sum_i ((s_i - av(s))^2) , which is N * Var(s) = sum(s^2) - 1/N (sum(x))^2
!            SumWeights(:)=0
!            SumSquares(:)=0
!            NVar(:)=0.D0
!            Means(:)=0.D0
!            Norm(:)=0.D0
!        
!            do i=1,Iter
!                do j=1,NoAutoDets
!                    SumWeights(j)=SumWeights(j)+AllWeightatDets(j,i)
!                    SumSquares(j)=SumSquares(j)+(AllWeightatDets(j,i)**2)
!!                    IF(i.le.(Iter/2)) Norm(j)=Norm(j)+(AllWeightatDets(j,i)**2)
!                    Norm(j)=Norm(j)+(AllWeightatDets(j,i)**2)
!                enddo
!            enddo
!
!!This then needs to be sent to all nodes
!!            CALL MPI_AllReduce(SumWeights,AllSumWeights,NoAutoDets,MPI_INTEGER,MPI_SUM,MPI_COMM_WORLD,error)
!!            CALL MPI_AllReduce(SumSquares,AllSumSquares,NoAutoDets,MPI_INTEGER,MPI_SUM,MPI_COMM_WORLD,error)
!
!            do j=1,NoAutoDets
!                Means(j)=REAL(SumWeights(j),dp)/REAL(Iter,dp)
!                NVar(j)=REAL(SumSquares(j),dp)-((REAL(SumWeights(j),dp)**2)/REAL(Iter,dp))
!                WRITE(6,"(A,I4)",advance='no') "Mean+Var for det: ",AutoCorrDets(1,j)
!                do k=2,NEl
!                    WRITE(6,"(I4)",advance='no') AutoCorrDets(k,j)
!                enddo
!                WRITE(6,"(A,2F20.10)") " is: ", Means(j),NVar(j)/REAL(Iter,dp)
!            enddo
!
!!Alternativly, we can calculate the variance seperatly...
!!            TestVar(:)=0.D0
!!            do i=1,Iter
!!                do j=1,NoAutoDets
!!                    TestVar(j)=TestVar(j)+((REAL(AllWeightatDets(j,i),dp)-Means(j))**2)
!!                enddo
!!            enddo
!!            CALL MPI_AllReduce(TestVar,AllTestVar,NoAutoDets,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,error)
!!            WRITE(6,*) "TESTVAR: ",TestVar/REAL(Iter,dp)
!
!!Now we need to calculate the ACF for the desired values of the lag.
!            do i=iLagMin,iLagMax,iLagStep
!!i is now the value of the lag which we are calculating
!
!                ACF(:)=0.D0
!
!                do j=1,(Iter-i)
!!                do j=1,Iter/2
!!j is the run over the values needed
!
!                    do k=1,NoAutoDets
!!k is the run over the desired determinants which to calculate the ACFs
!!                        ACF(k)=ACF(k)+(REAL(AllWeightatDets(k,j),dp)-Means(k))*(REAL(AllWeightatDets(k,j+i),dp)-Means(k))
!                        ACF(k)=ACF(k)+(AllWeightatDets(k,j)*AllWeightatDets(k,j+i))
!                    enddo
!
!                enddo
!
!!Now we need to collate the information from all processors
!!                CALL MPI_Reduce(ACF,AllACF,NoAutoDets,MPI_DOUBLE_PRECISION,MPI_SUM,root,MPI_COMM_WORLD,error)
!
!                do k=1,NoAutoDets
!!Effectivly 'normalise' the ACF by dividing by the variance
!!                    ACF(k)=(ACF(k)/NVar(k))!*REAL(Iter/(Iter-i+0.D0),dp)
!                    ACF(k)=(ACF(k)/REAL(NORM(k),dp))*REAL(Iter/(Iter-i+0.D0),dp)
!!                    ACF(k)=ACF(k)/REAL(NORM(k),8)
!                enddo
!!Write out the ACF
!                WRITE(43,"(I8,F20.10)",advance='no') i,ACF(1)
!                do k=2,NoAutoDets-1
!                    WRITE(43,"(F20.10)",advance='no') ACF(k)
!                enddo
!                WRITE(43,"(F20.10)") ACF(NoAutoDets)
!
!            enddo
!
!            CLOSE(43)
!
!        ENDIF
!        
!        DEALLOCATE(WeightatDets)
!        CALL LogMemDealloc(this_routine,WeightatDetsTag)
!        DEALLOCATE(AllWeightatDets)
!        CALL LogMemDealloc(this_routine,AllWeightatDetsTag)
!        DEALLOCATE(AutoCorrDets)
!        CALL LogMemDealloc(this_routine,AutoCorrDetsTag)
!
!        CALL halt_timer(ACF_Time)
!        
!        RETURN
!
!    END SUBROUTINE CalcAutoCorr

!This is a function which tells us whether to annihilate a particle on a determinant if it is the only one there.
!Hopefully this will simulate the annihilation rate to some extent and stop the shift from becoming too negative.
!The only variable it relies on is the approximate density of particles for the given excitation level - ExcitDensity
    LOGICAL FUNCTION AttemptLocalAnn(ExcitDensity)
        REAL*8 :: ExcitDensity,r,AnnProb

!The function can initially be a simple Tau*EXP(-Lambda*ExcitDensity)
!        AnnProb=Tau*EXP(-Lambda*ExcitDensity)
!        AnnProb=Lambda/ExcitDensity
        AnnProb=Lambda/ExcitDensity
        IF(tMerTwist) THEN
            r = genrand_real2_dSFMT() 
        ELSE
            CALL RANLUX(r,1)
        ENDIF
        IF(r.lt.AnnProb) THEN
!Particle is annihilated
            AttemptLocalAnn=.true.
        ELSE
!Particle survives
!            WRITE(6,*) "Particle survives with prob = ",AnnProb
            AttemptLocalAnn=.false.
        ENDIF
        RETURN

    END FUNCTION AttemptLocalAnn

    SUBROUTINE RotoAnnihilGuidingFunc(ValidSpawned)
! This routine takes the spawned particles (that have already been annihilated with themselves and with the main wavefunction), and tries to 
! annihilate them with the guiding function.
! The guiding function itself may be annihilated also, but does not spawn or die by itself.
! However, if the guiding function is completely annihilated on one processor, the spawned particles must be rotated around the other processors
! to check for possible annihilations there.
        use SystemData, only: G1, nBasis, Brr, NMsh, NMax, Alat, ECore, &
                              nBasis, nBasisMax
        use IntegralsData, only: UMat, fck
        integer :: i, j, n, ValidSpawned, InitNoDetstoRotate, NoDetstoRotate
        integer :: CombSign, error, ExcitLevel, nItmp(nel)
        type(HElement) :: HDoubTemp
        real*8 :: Hdoub
        logical :: tRotateSpawnedTemp, tRotateSpawned, tDetinSpawnList
        logical :: DetsEq
#ifdef PARALLEL
        integer :: Stat(MPI_STATUS_SIZE)
#endif


        NoDetstoRotate=0
        CombSign=0
        DetstoRotate(:,:)=0
        SigntoRotate(:)=0
        tRotateSpawnedTemp=.false.
        tRotateSpawned=.false.
        DetsEq=.false.


        !First attempt at annihilation, just on the processor the spawned particles are currently on.

        !Run through the determinats that have been spawned on.
        do i=1,ValidSpawned
            IF(SpawnedSign(i).ne.0) THEN
                !Run through the guiding function, checking if this spawned determinant is in there.
                do j=1,iGuideDets
                    DetsEq=.false.
                    !DetsEq is true if the two determinants are equal
                    DetsEq=DetBitEQ(SpawnedParts(0:NIfTot,i),GuideFuncDets(0:NIfTot,j),NIfDBO)
                    IF(DetsEq) THEN
                        CombSign=SpawnedSign(i)*GuideFuncSign(j)
                        !IF this is negative, the guiding function annihilates the spawned particles.
                        IF(CombSign.lt.0) THEN

                            IF(ABS(SpawnedSign(i)).gt.ABS(GuideFuncSign(j))) THEN
                                ! Don't want to change sign of guiding function so if there are more particles in the spawned list, just put the 
                                ! guiding function to 0 and leave the remaining spawned to be rotated to other processors.
                                SpawnedSign(i)=SpawnedSign(i)+GuideFuncSign(j)
                                ! Add because these are opposite signs.
                                GuideFuncSign(j)=0
                                ! Then need to rotate the remaining walkers in Spawned list to see if there are walkers in the guiding function
                                ! to annihilate with on other processors.

                                NoDetstoRotate=NoDetstoRotate+1
                                DetstoRotate(0:NIfTot,NoDetstoRotate)=SpawnedParts(0:NIfTot,i)
                                SigntoRotate(NoDetstoRotate)=SpawnedSign(i)

                            ELSEIF(ABS(SpawnedSign(i)).eq.ABS(GuideFuncSign(j))) THEN
                                SpawnedSign(i)=0
                                GuideFuncSign(j)=0
                            ELSE
                                ! The spawned are all annihilated, and the guiding function is decreased by that number.
                                GuideFuncSign(j)=GuideFuncSign(j)+SpawnedSign(i)
                                SpawnedSign(i)=0
                            ENDIF

                        !IF the combined sign (CombSign) is positive, signs are the same and the spawned particles remain.
                        !Nothing changes, the guiding function is not annihilated, and the spawned remain to be put into the full list later.

                        !If CombSign is 0, there are no walkers on the guiding function (for that processor).
                        !Need to rotate the spawned walker to see if there are any walkers on this determinant to annihilate with.
                        ELSEIF(CombSign.eq.0) THEN
                            NoDetstoRotate=NoDetstoRotate+1
                            DetstoRotate(0:NIfTot,NoDetstoRotate)=SpawnedParts(0:NIfTot,i)
                            SigntoRotate(NoDetstoRotate)=SpawnedSign(i)
                        ENDIF

                        !If we have found a determinant in the guiding function that matches that in the spawned, can stop searching the guiding 
                        !function, there will be no more matches.
                        EXIT

                    ENDIF
                enddo
            ENDIF
        enddo

        IF(NoDetstoRotate.gt.0) tRotateSpawnedTemp=.true.
        !If NoDetstoRotate is 0, don't even have to worry about the rotating stuff.

        !If tRotateSpawnedTemp is true on any processor, this routine makes tRotateSpawned true on all processors.
        CALL MPIAllReduceLORScal(tRotateSpawnedTemp,tRotateSpawned,error)


!The allocated DetstoRotate arrays are as big as iGuideDets (the number of determinants in the guiding function), but will only need to rotate 
!a portion of these (those determinants for which the guiding function has had all its walkers annihilated).

        IF(tRotateSpawned) THEN !If NoDetstoRotate is greater than 0 on any processor, need to rotate all arrays, otherwise will overwrite each other etc.

            InitNoDetstoRotate=NoDetstoRotate
            !For now, rotate this same sized array each time, even if not completely necessary.
            !We are currently just making the determinant (and its sign) 0 if we no longer want to rotate it, but could in the future remove it from the
            !array.  Probably doesn't make all that much difference because will never find a 0 determinant in the guiding function.

            do n=1,nProcessors-1
            !Rotate the DetstoRotate, SigntoRotate and NoDetstoRotate values.

#ifdef PARALLEL

                DetsEq=.false.
                CombSign=0
                SigntoRotate(0)=InitNoDetstoRotate

                !Send the sign of those we want to rotate to the next processor.
                !Element 0 is the InitNoDetstoRotate value for this processor, send this as well.
                CALL MPI_BSend(SigntoRotate(0:InitNoDetstoRotate),InitNoDetstoRotate+1,MPI_INTEGER,MOD(iProcIndex+1,nProcessors),123,MPI_COMM_WORLD,error)
                IF(error.ne.MPI_SUCCESS) THEN
                    CALL Stop_All("RotoAnnihilGuidingFunc","Error in sending signs")
                ENDIF

                !Then send the determinants
                CALL MPI_BSend(DetstoRotate(0:NIfTot,1:InitNoDetstoRotate),(NIfTot+1)*InitNoDetstoRotate,MPI_INTEGER,MOD(iProcIndex+1,nProcessors),456,MPI_COMM_WORLD,error)
                IF(error.ne.MPI_SUCCESS) THEN
                    CALL Stop_All("RotoAnnihilGuidingFunc","Error in sending particles")
                ENDIF

                !Receives signs.
                !Receive max possible, will only overwrite those that are actually being sent.
                CALL MPI_Recv(SigntoRotate2(0:iGuideDets),iGuideDets+1,MPI_INTEGER,MOD(iProcIndex+nProcessors-1,nProcessors),123,MPI_COMM_WORLD,Stat,error)
                IF(error.ne.MPI_SUCCESS) THEN
                    CALL Stop_All("RotoAnnihilGuidingFunc","Error in receiving signs")
                ENDIF

                InitNoDetstoRotate=SigntoRotate2(0)

                !Recieve determinants
                CALL MPI_Recv(DetstoRotate2(0:NIfTot,1:InitNoDetstoRotate),InitNoDetstoRotate*(NIfTot+1),MPI_INTEGER,MOD(iProcIndex+nProcessors-1,nProcessors),456,MPI_COMM_WORLD,Stat,error)
                IF(error.ne.MPI_SUCCESS) THEN
                    CALL Stop_All("RotoAnnihilGuidingFunc","Error in receiving particles")
                ENDIF

                do i=1,InitNoDetstoRotate
                    SigntoRotate(i)=SigntoRotate2(i)
                    DetstoRotate(0:NIfTot,i)=DetstoRotate2(0:NIfTot,i)
                enddo
#endif

                !If a determinant has walkers in the guiding function on the same determinant with the same sign, add the spawned (rotate) walkers
                !to the spawned list of that processor (no longer need to rotate).
                !If the walkers have opposite sign, annihilate and rotate any remaining from the spawned list.
                !If there are no walkers on the guiding function determinant, keep rotating.
            
                !Take a rotated determinant and run through to find it in the guiding function of that processor.
                do i=1,InitNoDetstoRotate
                    !If the number of particles being rotated has become zero, don't need to search through the guiding function for particles to annihilate.
                    IF(Signtorotate(i).ne.0) THEN
                        do j=1,iGuideDets
                            DetsEq=.false.
                            DetsEq=DetBitEQ(DetstoRotate(0:NIfTot,i),GuideFuncDets(0:NIfTot,j),NIfDBO)

                            IF(DetsEq) THEN
                                CombSign=SigntoRotate(i)*GuideFuncSign(j)
                                !IF this is negative, the guiding function annihilates the spawned particles.
                                IF(CombSign.lt.0) THEN

                                    IF(ABS(SigntoRotate(i)).gt.ABS(GuideFuncSign(j))) THEN
                                        !If there are still too many in the spawned (rotated) array to be all annihilated by the guiding function on that
                                        !processor, annihilate what you can, but leave the determinant in the array to keep rotating.
                                        SigntoRotate(i)=SigntoRotate(i)+GuideFuncSign(j)
                                        ! Add because these are opposite signs.
                                        GuideFuncSign(j)=0
                                        
                                    ELSEIF(ABS(SigntoRotate(i)).eq.ABS(GuideFuncSign(j))) THEN
                                        SigntoRotate(i)=0
                                        GuideFuncSign(j)=0

                                    ELSE
                                        ! The spawned are all annihilated, and the guiding function is decreased by that number.
                                        GuideFuncSign(j)=GuideFuncSign(j)+SigntoRotate(i)
                                        SigntoRotate(i)=0
                                    ENDIF

                                    !IF the combined sign (CombSign) is positive, there are walkers in the guiding function of that processor with the same
                                    !sign. Thus no annihilation occurs and these particles just continue to rotate around (they will just end up back on the
                                    !the original processor where they'll be recombined back into SpawnedPart.

                                    !If CombSign is 0, there are no walkers on the guiding function (for that processor).
                                    !Continue rotating spawned walkers to see if there are any on the next processor to annihilate with.

                                    !If we have found a determinant in the guiding function that matches that in the spawned, can stop searching the guiding 
                                    !function, there will be no more matches.

                                ENDIF

                                EXIT
                            ENDIF

                        enddo
                    ENDIF
                enddo
                    
            enddo

            !If back to original processor and still have walkers in rotating arrays, just add them to the spawned list.
            !Do one final rotation, end up on original processor - add remaining particles to spawned list.

            SigntoRotate(0)=InitNoDetstoRotate

#ifdef PARALLEL

            !Send the sign of those we want to rotate to the next processor.
            CALL MPI_BSend(SigntoRotate(0:InitNoDetstoRotate),InitNoDetstoRotate+1,MPI_INTEGER,MOD(iProcIndex+1,nProcessors),123,MPI_COMM_WORLD,error)
            IF(error.ne.MPI_SUCCESS) THEN
                CALL Stop_All("RotoAnnihilGuidingFunc","Error in sending signs")
            ENDIF

            !Then send the determinants
            CALL MPI_BSend(DetstoRotate(0:NIfTot,1:InitNoDetstoRotate),(NIfTot+1)*InitNoDetstoRotate,MPI_INTEGER,MOD(iProcIndex+1,nProcessors),456,MPI_COMM_WORLD,error)
            IF(error.ne.MPI_SUCCESS) THEN
                CALL Stop_All("RotoAnnihilGuidingFunc","Error in sending particles")
            ENDIF

            !Receives signs.
            CALL MPI_Recv(SigntoRotate2(0:iGuideDets),iGuideDets+1,MPI_INTEGER,MOD(iProcIndex+nProcessors-1,nProcessors),123,MPI_COMM_WORLD,Stat,error)
            IF(error.ne.MPI_SUCCESS) THEN
                CALL Stop_All("RotoAnnihilGuidingFunc","Error in receiving signs")
            ENDIF
            
            InitNoDetstoRotate=SigntoRotate2(0)

            !Recieve determinants
            CALL MPI_Recv(DetstoRotate2(0:NIfTot,1:InitNoDetstoRotate),InitNoDetstoRotate*(NIfTot+1),MPI_INTEGER,MOD(iProcIndex+nProcessors-1,nProcessors),456,MPI_COMM_WORLD,Stat,error)
            IF(error.ne.MPI_SUCCESS) THEN
                CALL Stop_All("RotoAnnihilGuidingFunc","Error in receiving particles")
            ENDIF

            do i=1,InitNoDetstoRotate
                SigntoRotate(i)=SigntoRotate2(i)
                DetstoRotate(0:NIfTot,i)=DetstoRotate2(0:NIfTot,i)
            enddo

#endif

            !Now add all the remaining DetstoRotate2 and their signs to the SpawnedPart and SpawnedSign lists.
            !Since I just copied the determinants from SpawnedPart to DetstoRotate, any in DetstoRotate will already been in SpawnedPart.
            !Need to just search for it and overwrite its spin value.
            do j=1,InitNoDetstoRotate
                tDetinSpawnList=.false.
                do i=1,ValidSpawned
                    DetsEq=.false.
                    DetsEq=DetBitEQ(SpawnedParts(0:NIfTot,i),DetstoRotate(0:NIfTot,j),NIfDBO)
                    IF(DetsEq) THEN
                        SpawnedSign(i)=SigntoRotate(j)
                        tDetinSpawnList=.true.
                        EXIT
                    ENDIF
                enddo
                IF(.not.tDetinSpawnList) THEN
                    WRITE(6,*) 'Determinant from rotate list : ',DetstoRotate(0:NIfTot,j)
!                    do i=1,ValidSpawned
!                        WRITE(6,*) SpawnedParts(0:NIfTot,i)
!                    enddo
                    CALL FLUSH(6)
                    CALL Stop_All("RotoAnnihilGuidingFunc","Determinant from rotated list cannot be found in SpawnedParts.")
                ENDIF
            enddo

        ENDIF

        !Calculated the number of walkers in the guiding function after this annihilation.
        iInitGuideParts=0
        AlliInitGuideParts=0
        do i=1,iGuideDets
            iInitGuideParts=iInitGuideParts+ABS(GuideFuncSign(i))
        enddo
!        CALL MPI_Reduce(iInitGuideParts,AlliInitGuideParts,1,MPI_INTEGER,MPI_SUM,Root,MPI_COMM_WORLD,error)

        !Need to calculate the contribution to the HF from the guiding function, and then also the contribution from doubles.
        GuideFuncHF=GuideFuncHF+GuideFuncSign(GuideFuncHFIndex)


        !Run through all other determinants in the guiding function.  Find out if they are doubly excited.  Find H elements, and multiply by number on that double.
        do i=1,iGuideDets
            ExcitLevel = FindBitExcitLevel(GuideFuncDets(:,i), iLutHF, 2)
            if (ExcitLevel == 2) then
                ! nb. get_helement_normal does not use nI, nJ for ic == 2.
                !     Therefore no need to generate guide det. This is not
                !     true for CSFs (--> no rotoannhilation for CSFs).
                HDoubTemp = get_helement (HFDet, HFDet, ExcitLevel, iLutHF, &
                                          GuideFuncDets(:,i))
                HDoub=REAL(HDoubTemp%v,dp)
                GuideFuncDoub=GuideFuncDoub+(GuideFuncSign(i)*Hdoub)
            endif
        enddo


    ENDSUBROUTINE RotoAnnihilGuidingFunc

!Do a binary search of the DominantDets, between the indices of MinInd and MaxInd. If successful, tSuccess will be true.
    SUBROUTINE BinSearchDomParts(AllExcDets,iLut,MinInd,MaxInd,PartInd,tSuccess)
        INTEGER :: iLut(0:NIfTot),MinInd,MaxInd,PartInd
        INTEGER :: i,j,N,Comp,AllExcDets(0:NIfTot,MinInd:MaxInd)
        LOGICAL :: tSuccess

!        WRITE(6,*) "Binary searching between ",MinInd, " and ",MaxInd
!        CALL FLUSH(6)
        i=MinInd
        j=MaxInd
        do while(j-i.gt.0)  !End when the upper and lower bound are the same.
            N=(i+j)/2       !Find the midpoint of the two indices
!            WRITE(6,*) i,j,n

!Comp is 1 if CyrrebtDets(N) is "less" than iLut, and -1 if it is more or 0 if they are the same
            Comp=DetBitLT(AllExcDets(:,N),iLut(:),NIfDBO)

            IF(Comp.eq.0) THEN
!Praise the lord, we've found it!
                tSuccess=.true.
                PartInd=N
                RETURN
            ELSEIF((Comp.eq.1).and.(i.ne.N)) THEN
!The value of the determinant at N is LESS than the determinant we're looking for. Therefore, move the lower bound of the search up to N.
!However, if the lower bound is already equal to N then the two bounds are consecutive and we have failed...
                i=N
            ELSEIF(i.eq.N) THEN


                IF(i.eq.MaxInd-1) THEN
!This deals with the case where we are interested in the final/first entry in the list. Check the final entry of the list and leave
!We need to check the last index.
                    Comp=DetBitLT(AllExcDets(:,i+1),iLut(:),NIfDBO)
                    IF(Comp.eq.0) THEN
                        tSuccess=.true.
                        PartInd=i+1
                        RETURN
                    ELSEIF(Comp.eq.1) THEN
!final entry is less than the one we want.
                        tSuccess=.false.
                        PartInd=i+1
                        RETURN
                    ELSE
                        tSuccess=.false.
                        PartInd=i
                        RETURN
                    ENDIF

                ELSEIF(i.eq.MinInd) THEN
                    tSuccess=.false.
                    PartInd=i
                    RETURN

                ELSE
                    i=j
                ENDIF


            ELSEIF(Comp.eq.-1) THEN
!The value of the determinant at N is MORE than the determinant we're looking for. Move the upper bound of the search down to N.
                j=N
            ELSE
!We have failed - exit loop
                i=j
            ENDIF

        enddo

!If we have failed, then we want to find the index that is one less than where the particle would have been.
        tSuccess=.false.
        PartInd=MAX(MinInd,i-1)

    END SUBROUTINE BinSearchDomParts
    

!Do a binary search the guiding function dets, between the indices of MinInd and MaxInd. If successful, tSuccess will be true and 
!PartInd will be a coincident determinant. If there are multiple values, the chosen one may be any of them...
!If failure, then the index will be one less than the index that the particle would be in if it was present in the list.
!(or close enough!)
    SUBROUTINE BinSearchGuideParts(iLut,MinInd,MaxInd,PartInd,tSuccess)
        INTEGER :: iLut(0:NIfTot),MinInd,MaxInd,PartInd
        INTEGER :: i,j,N,Comp
        LOGICAL :: tSuccess

!        WRITE(6,*) "Binary searching between ",MinInd, " and ",MaxInd
!        CALL FLUSH(6)
        i=MinInd
        j=MaxInd
        do while(j-i.gt.0)  !End when the upper and lower bound are the same.
            N=(i+j)/2       !Find the midpoint of the two indices
!            WRITE(6,*) i,j,n

!Comp is 1 if CyrrebtDets(N) is "less" than iLut, and -1 if it is more or 0 if they are the same
            Comp=DetBitLT(GuideFuncDets(:,N),iLut(:),NIfDBO)

            IF(Comp.eq.0) THEN
!Praise the lord, we've found it!
                tSuccess=.true.
                PartInd=N
                RETURN
            ELSEIF((Comp.eq.1).and.(i.ne.N)) THEN
!The value of the determinant at N is LESS than the determinant we're looking for. Therefore, move the lower bound of the search up to N.
!However, if the lower bound is already equal to N then the two bounds are consecutive and we have failed...
                i=N
            ELSEIF(i.eq.N) THEN


                IF(i.eq.MaxInd-1) THEN
!This deals with the case where we are interested in the final/first entry in the list. Check the final entry of the list and leave
!We need to check the last index.
                    Comp=DetBitLT(GuideFuncDets(:,i+1),iLut(:),NIfDBO)
                    IF(Comp.eq.0) THEN
                        tSuccess=.true.
                        PartInd=i+1
                        RETURN
                    ELSEIF(Comp.eq.1) THEN
!final entry is less than the one we want.
                        tSuccess=.false.
                        PartInd=i+1
                        RETURN
                    ELSE
                        tSuccess=.false.
                        PartInd=i
                        RETURN
                    ENDIF

                ELSEIF(i.eq.MinInd) THEN
                    tSuccess=.false.
                    PartInd=i
                    RETURN

                ELSE
                    i=j
                ENDIF


            ELSEIF(Comp.eq.-1) THEN
!The value of the determinant at N is MORE than the determinant we're looking for. Move the upper bound of the search down to N.
                j=N
            ELSE
!We have failed - exit loop
                i=j
            ENDIF

        enddo

!If we have failed, then we want to find the index that is one less than where the particle would have been.
        tSuccess=.false.
        PartInd=MAX(MinInd,i-1)

    END SUBROUTINE BinSearchGuideParts

    SUBROUTINE InitTriHElStats()
        INTEGER :: i,ierr
        REAL*8 :: BinVal,BinIter
        CHARACTER(len=*), PARAMETER :: this_routine='InitTriHElStats'

        IF(tPrintTriConnections) THEN
            NoSignCohTri=0.D0
            NoSignInCohTri=0.D0
            SignCohTri=0.D0
            SignInCohTri=0.D0
            IF(iProcIndex.eq.root) THEN
                OPEN(77,file='TriConnTotals',status='unknown')
                WRITE(77,"(A12,2A24,8A20)") "1.Iteration","2.No. Sign Coh Loops","3.No. Sign Incoh Loops","4.Sign Coh Tot","5.Sign Incoh Tot","6.Sign Coh/Iter",&
                                                &"7.Sign Incoh/Iter","8.Sign Coh/Loop","9.Sign Incoh/Loop","10.Ratio No.","11.Ratio Val."
            ENDIF

! Set up histogramms.
            ALLOCATE(SignCohTriHist(2,NoTriConBins),stat=ierr)
            CALL LogMemAlloc('SignCohTriHist',2*NoTriConBins,8,this_routine,SignCohTriHistTag,ierr)
            ALLOCATE(SignIncohTriHist(2,NoTriConBins),stat=ierr)
            CALL LogMemAlloc('SignIncohTriHist',2*NoTriConBins,8,this_routine,SignIncohTriHistTag,ierr)
 
            ALLOCATE(SignCohHFTriHist(2,NoTriConBins),stat=ierr)
            CALL LogMemAlloc('SignCohHFTriHist',2*NoTriConBins,8,this_routine,SignCohHFTriHistTag,ierr)
            ALLOCATE(SignIncohHFTriHist(2,NoTriConBins),stat=ierr)
            CALL LogMemAlloc('SignIncohHFTriHist',2*NoTriConBins,8,this_routine,SignIncohHFTriHistTag,ierr)
 
            SignCohTriHist(:,:)=0.D0
            SignIncohTriHist(:,:)=0.D0
            SignCohHFTriHist(:,:)=0.D0
            SignIncohHFTriHist(:,:)=0.D0

            IF(iProcIndex.eq.Root) THEN
                ALLOCATE(AllSignCohTriHist(2,NoTriConBins),stat=ierr)
                CALL LogMemAlloc('AllSignCohTriHist',2*NoTriConBins,8,this_routine,AllSignCohTriHistTag,ierr)
                ALLOCATE(AllSignIncohTriHist(2,NoTriConBins),stat=ierr)
                CALL LogMemAlloc('AllSignIncohTriHist',2*NoTriConBins,8,this_routine,AllSignIncohTriHistTag,ierr)
     
                ALLOCATE(AllSignCohHFTriHist(2,NoTriConBins),stat=ierr)
                CALL LogMemAlloc('AllSignCohHFTriHist',2*NoTriConBins,8,this_routine,AllSignCohHFTriHistTag,ierr)
                ALLOCATE(AllSignIncohHFTriHist(2,NoTriConBins),stat=ierr)
                CALL LogMemAlloc('AllSignIncohHFTriHist',2*NoTriConBins,8,this_routine,AllSignIncohHFTriHistTag,ierr)
     
                AllSignCohTriHist(:,:)=0.D0
                AllSignIncohTriHist(:,:)=0.D0
                AllSignCohHFTriHist(:,:)=0.D0
                AllSignIncohHFTriHist(:,:)=0.D0
            ENDIF
 
            BinIter=ABS(TriConMax)/REAL(NoTriConBins)

            BinVal=0.D0
            do i=1,NoTriConBins
                SignCohTriHist(1,i)=BinVal
                SignIncohTriHist(1,i)=(-1)*BinVal
                SignCohHFTriHist(1,i)=BinVal
                SignIncohHFTriHist(1,i)=(-1)*BinVal
                BinVal=BinVal+BinIter
            enddo
        ENDIF

        IF(tHistTriConHEls) THEN
            TriConHEls(:,:)=0.D0
            ! TriConHEls(1,1) - number of singles
            ! TriConHEls(1,2) - sum of single elements
            ! TriConHEls(2,1) - number of doubles
            ! TriConHEls(2,2) - sum of double elements
            ! TriConHEls(3,1) - number of Hjk elements
            ! TriConHEls(3,2) - sum of Hjk elements
            ALLOCATE(TriConnHElHistSing(2,NoTriConHElBins),stat=ierr)
            CALL LogMemAlloc('TriConnHElHistSing',2*NoTriConHElBins,8,this_routine,TriConnHElHistSingTag,ierr)
            ALLOCATE(TriConnHElHistDoub(2,NoTriConHElBins),stat=ierr)
            CALL LogMemAlloc('TriConnHElHistDoub',2*NoTriConHElBins,8,this_routine,TriConnHElHistDoubTag,ierr)
            ALLOCATE(TriHjkHistSing(2,NoTriConHElBins),stat=ierr)
            CALL LogMemAlloc('TriHjkHistSing',2*NoTriConHElBins,8,this_routine,TriHjkHistSingTag,ierr)
            ALLOCATE(TriHjkHistDoub(2,NoTriConHElBins),stat=ierr)
            CALL LogMemAlloc('TriHjkHistDoub',2*NoTriConHElBins,8,this_routine,TriHjkHistDoubTag,ierr)

            TriConnHElHistSing(:,:)=0.D0
            TriConnHElHistDoub(:,:)=0.D0
            TriHjkHistSing(:,:)=0.D0
            TriHjkHistDoub(:,:)=0.D0
 
            IF(iProcIndex.eq.Root) THEN
                ALLOCATE(AllTriConnHElHistSing(2,NoTriConHElBins),stat=ierr)
                CALL LogMemAlloc('AllTriConnHElHistSing',2*NoTriConHElBins,8,this_routine,AllTriConnHElHistSingTag,ierr)
                ALLOCATE(AllTriConnHElHistDoub(2,NoTriConHElBins),stat=ierr)
                CALL LogMemAlloc('AllTriConnHElHistDoub',2*NoTriConHElBins,8,this_routine,AllTriConnHElHistDoubTag,ierr)
                ALLOCATE(AllTriHjkHistSing(2,NoTriConHElBins),stat=ierr)
                CALL LogMemAlloc('AllTriHjkHistSing',2*NoTriConHElBins,8,this_routine,AllTriHjkHistSingTag,ierr)
                ALLOCATE(AllTriHjkHistDoub(2,NoTriConHElBins),stat=ierr)
                CALL LogMemAlloc('AllTriHjkHistDoub',2*NoTriConHElBins,8,this_routine,AllTriHjkHistDoubTag,ierr)

                AllTriConnHElHistSing(:,:)=0.D0
                AllTriConnHElHistDoub(:,:)=0.D0
                AllTriHjkHistSing(:,:)=0.D0
                AllTriHjkHistDoub(:,:)=0.D0
            ENDIF
     
            BinIter=ABS(2*TriConHElSingMax)/REAL(NoTriConHElBins)
            BinVal=(-1)*TriConHElSingMax
            do i=1,NoTriConHElBins
                TriConnHElHistSing(1,i)=BinVal
                TriHjkHistSing(1,i)=BinVal
                BinVal=BinVal+BinIter
            enddo
 
            BinIter=ABS(2*TriConHElDoubMax)/REAL(NoTriConHElBins)
            BinVal=(-1)*TriConHElDoubMax
            do i=1,NoTriConHElBins
                TriConnHElHistDoub(1,i)=BinVal
                TriHjkHistDoub(1,i)=BinVal
                BinVal=BinVal+BinIter
            enddo

        ENDIF


        IF(tPrintHElAccept) THEN
            NoNotAccept=0.D0
            NoAccept=0.D0
            TotHElNotAccept=0.D0
            TotHElAccept=0.D0
            MaxHElNotAccept=0.D0
            MinHElAccept=0.D0
            IF(iProcIndex.eq.root) THEN
                OPEN(84,file='HElsAcceptance',status='unknown')
                WRITE(84,'(A10,7A20)') "Iteration","No. Not Accepted","No. Accepted","Ratio NotAcc/Acc","Av.HEl Not Accept","Av.HEl Accept","Max HEl Not Accept","Min HEl Accept"
            ENDIF
        ENDIF

    ENDSUBROUTINE InitTriHElStats




    SUBROUTINE FindSpinCoupHEl(iLutHF,iLutCurr)
! Fed into here is a doubly excited occupied determinant - want to take the two excited orbitals and flip their spins.
! Then find the coupling H element between the original and spin-flipped determinants and add it to the stats.
        USE HPHFRandExcitMod , only : FindExcitBitDetSym 
        use DetBitOps, only: DecodeBitdet
        use SystemData, only: NIfTot, nel
        INTEGER :: iLutCurr(0:NIfTot),iLutHF(0:NIfTot),i
        INTEGER :: iLutSym(0:NIfTot),nI(NEl),nJ(NEl),nHF(NEl),Ex(2,2)
        TYPE(HElement) :: SpinCoupHEl,HElHFI,HElHFJ
        LOGICAL :: DetsEqSpinCoup,tSign

! First get the spin flipped determinant.
! Can do this in two ways.  Either flip the spin of all electrons - this means that doubly occupied spat orbs will be unchanged or

        CALL FindExcitBitDetSym(iLutCurr,iLutSym)


! - just flip the sign of the two excited electrons.
!        CALL GetBitExcitation(iLutHF,iLutCurr,Ex,tSign)
        ! Electrons Ex(1,1) and Ex(1,2) are excited to Ex(2,1) and Ex(2,2)


! Now find the HElement between these two determinants.        
        
        CALL DecodeBitDet(nI,iLutCurr)
        CALL DecodeBitDet(nJ,iLutSym)

        CALL DecodeBitDet(nHF,iLutHF)

! Want to replace the excited electrons in nI with the spin flipped versions.
!        nJ(:)=nI(:)
!        do i=1,NEl
!            IF(nJ(i).eq.Ex(2,1)) THEN
!                IF(MOD(nJ(i),2).eq.0) THEN
!                    nJ(i)=Ex(2,1)-1
!                ELSE
!                    nJ(i)=Ex(2,1)+1
!                ENDIF
!            ELSEIF(nJ(i).eq.Ex(2,2)) THEN
!                IF(MOD(nJ(i),2).eq.0) THEN
!                    nJ(i)=Ex(2,2)-1
!                ELSE
!                    nJ(i)=Ex(2,2)+1
!                ENDIF
!            ENDIF
!        enddo


        DetsEqSpinCoup=.false.
        DetsEqSpinCoup=DetBitEQ(iLutCurr, iLutSym, NIfDBO)

        HElHFI = get_helement (nHF, nI, iLutHF, iLutCurr)
        HElHFI = get_helement (nHF, nJ, iLutHF, iLutSym)

        IF(.not.DetsEqSpinCoup) THEN

            SpinCoupHEl = get_helement (nI, nJ, iLutCurr, iLutSym)

            IF((((REAL(HElHFI%v,dp)).lt.0.D0).and.((REAL(HElHFJ%v,dp)).gt.0.D0)).or.(((REAL(HElHFI%v,dp)).gt.0.D0).and.((REAL(HElHFJ%v,dp)).lt.0.D0))) THEN
!                WRITE(6,*) '*'
!                WRITE(6,'(A30,F15.6,A30,F15.6)') 'HEl between HF and one det : ',REAL(HElHFI%v,dp),' and to the spin coupled : ',REAL(HElHFJ%v,dp)
!                WRITE(6,*) 'HFDet',nHF(:)
!                WRITE(6,*) 'First Det',nI(:)
!                WRITE(6,*) 'Second Det',nJ(:)

                IF((REAL(SpinCoupHEl%v,dp)).lt.0.D0) THEN
                    NoNegSpinCoup=NoNegSpinCoup+1.D0
                    SumNegSpinCoup=SumNegSpinCoup+REAL(SpinCoupHEl%v,dp)
                ELSEIF((REAL(SpinCoupHEl%v,dp)).gt.0.D0) THEN
                    NoPosSpinCoup=NoPosSpinCoup+1.D0
                    SumPosSpinCoup=SumPosSpinCoup+REAL(SpinCoupHEl%v,dp)
                ENDIF
!                WRITE(6,*) 'Spin coupled HEl',REAL(SpinCoupHEl%v,dp)            
                SumHFCon=SumHFCon+ABS(REAL(HElHFI%v,dp))
                SumSpinCon=SumSpinCon+ABS(REAL(SpinCoupHEl%v,dp))

            ENDIF

            IF(((((REAL(HElHFI%v,dp)).lt.0.D0).and.((REAL(HElHFJ%v,dp)).lt.0.D0)).or.(((REAL(HElHFI%v,dp)).gt.0.D0).and.((REAL(HElHFJ%v,dp)).gt.0.D0)))&
            &.and.(REAL(SpinCoupHEl%v,dp).ne.0.D0)) THEN
                WRITE(6,*) '*'
                WRITE(6,'(A30,F15.6,A30,F15.6)') 'HEl between HF and one det : ',REAL(HElHFI%v,dp),' and to the spin coupled : ',REAL(HElHFJ%v,dp)
                WRITE(6,*) 'HFDet',nHF(:)
                WRITE(6,*) 'First Det',nI(:)
                WRITE(6,*) 'Second Det',nJ(:)

                WRITE(6,*) 'Spin coupled HEl',REAL(SpinCoupHEl%v,dp)            
                CALL FLUSH(6)
                WRITE(6,*) '******* Determinants have the same sign with HF, but non-zero connecting element.'
!                CALL Stop_All("FindSpinCoupHEl","Determinants have the same sign with HF, but non-zero connecting element.")
            ENDIF
        ENDIF


    ENDSUBROUTINE FindSpinCoupHEl



    SUBROUTINE PrintSpinCoupHEl(Iteration)
        REAL*8 :: SpinCoupHElStats(4),AllSpinCoupHElStats(4)
        INTEGER :: error,Iteration

!Write to files the sum of the sign coherent and incoherent triangles. 
        SpinCoupHElStats(1)=NoPosSpinCoup
        SpinCoupHElStats(2)=NoNegSpinCoup
        SpinCoupHElStats(3)=SumPosSpinCoup
        SpinCoupHElStats(4)=SumNegSpinCoup
        AllSpinCoupHElStats(:)=0.D0

#ifdef PARALLEL
        CALL MPI_Reduce(SpinCoupHElStats,AllSpinCoupHElStats,4,MPI_DOUBLE_PRECISION,MPI_SUM,Root,MPI_COMM_WORLD,error)
#else        
        AllSpinCoupHElStats=SpinCoupHElStats
#endif

        IF(iProcIndex.eq.Root) THEN

!            WRITE(87,'(I8,10F19.6)') Iteration,AllSpinCoupHElStats(1),AllSpinCoupHElStats(2),AllSpinCoupHElStats(3),AllSpinCoupHElStats(4),(AllSpinCoupHElStats(3)+AllSpinCoupHElStats(4)),&
            WRITE(87,'(I8,11F18.6)') Iteration,AllSpinCoupHElStats(1),AllSpinCoupHElStats(2),AllSpinCoupHElStats(3),AllSpinCoupHElStats(4),&
                                             &(AllSpinCoupHElStats(1)/REAL(Iteration)),(AllSpinCoupHElStats(2)/REAL(Iteration)),(AllSpinCoupHElStats(3)/REAL(Iteration)),&
!                                             &(AllSpinCoupHElStats(4)/REAL(Iteration)),((AllSpinCoupHElStats(3)+AllSpinCoupHElStats(4))/REAL(Iteration))
                                             &(AllSpinCoupHElStats(4)/REAL(Iteration)),SumHFCon,SumSpinCon,SumSpinCon/SumHFCon
        ENDIF

    ENDSUBROUTINE PrintSpinCoupHEl
 



    SUBROUTINE FindTriConnections(DetCurr,iLutnJ,iLutHF,nJ,IC,Ex,pDoubles,tFilled,tParity,Scratch1,Scratch2,exflag)
        use systemdata, only: nifd
        TYPE(HElement) :: Hjk,Hij,Hik,HEl
        INTEGER :: iLutnJ(0:NIfTot),k,DetCurr(NEl),nJ(NEl),IC,Ex(2,2),Scratch1(ScratchSize),Scratch2(ScratchSize)
        INTEGER :: nK(NEl),IC2,IC3,Ex2(2,2),iLutnJ2(0:NIfTot),iLutnK(0:NIfTot),BinNo,NoPos,NoNeg,ICgen,iLutHF(0:NIfTot),exflag
        LOGICAL :: tParity2,DetsEqTri,tHF,tFilled,tParity
        REAL*8 :: Prob2,pDoubles
        

        CALL GenRandSymExcitScratchNU(DetCurr,iLutnJ,nK,pDoubles,IC2,Ex2,tParity2,exFlag,Prob2,Scratch1,Scratch2,tFilled)

        ! Need to check that the determinant we just generated is not the same as nJ.
        DetsEqTri=.false.

        ! These routines find the bit representation of nJ and nK given the excitation matrices Ex and Ex2 respectively.
        call FindExcitBitDet (iLutnJ, iLutnJ2, IC, Ex)
        call FindExcitBitDet (iLutnJ, iLutnK, IC2, Ex2)

        DetsEqTri = DetBitEQ (iLutnJ2, iLutnK, NIfDBO)

        IF(.not.DetsEqTri) THEN
            ! Add the connecting elements to the relevant sum.

            ! First quickly test if any of the determinants are the HF.
            tHF=.false.
            tHF = DetBitEQ(iLutHF, iLutnJ, NIfDBO)
            IF(.not.tHF) tHF = DetBitEQ(iLutHF, iLutnJ2, NIfDBO)
            IF(.not.tHF) tHF = DetBitEQ(iLutHF, iLutnK, NIfDBO)

            ! Calculate Hjk first (connecting element between two excitations), because if this is 0, no need to go further.
            IC3 = -1
            Hjk = get_helement (nJ, nK, iLutnJ2, iLutnK, IC3)

            ! Histogram and add in the Hjk elements - regardless of whether or not this is 0.
            ! If the connection is not via a double or a single, the element will not be histogrammed, but it will always be 0,
            ! and this will be added into the sum.

            TriConHEls(3,1)=TriConHEls(3,1)+1.D0
            TriConHEls(3,2)=TriConHEls(3,2)+ABS(REAL(Hjk%v,dp))
            IF(IC3.eq.1) THEN
                BinNo=CEILING((REAL(Hjk%v,dp)+TriConHElSingMax)*NoTriConHElBins)/(2*TriConHElSingMax)
                TriHjkHistSing(2,BinNo)=TriHjkHistSing(2,BinNo)+1.D0
            ELSEIF(IC3.eq.2) THEN
                BinNo=CEILING((REAL(Hjk%v,dp)+TriConHElDoubMax)*NoTriConHElBins)/(2*TriConHElDoubMax)
                TriHjkHistDoub(2,BinNo)=TriHjkHistDoub(2,BinNo)+1.D0
            ENDIF 

            ! Now histogram all the stats from the whole loops.
            IF((REAL(Hjk%v,dp)).ne.0.D0) THEN
                NoPos=0
                NoNeg=0
                IF((REAL(Hjk%v,dp)).gt.0.D0) NoPos=NoPos+1
                IF((REAL(Hjk%v,dp)).lt.0.D0) NoNeg=NoNeg+1

                Hij = get_helement_excit (DetCurr, nJ, IC, Ex, tParity)
                IF((REAL(Hij%v,dp)).gt.0.D0) NoPos=NoPos+1
                IF((REAL(Hij%v,dp)).lt.0.D0) NoNeg=NoNeg+1

                Hik = get_helement_excit (DetCurr, nK, IC2, Ex2, tParity2)
                IF((REAL(Hik%v,dp)).gt.0.D0) NoPos=NoPos+1
                IF((REAL(Hik%v,dp)).lt.0.D0) NoNeg=NoNeg+1

                ! If there are 1 or 3 positive elements, the triangular connection is 'sign coherent'.
                ! i.e. if a walker starts with a positive sign at i, it would return to i with a positive sign after completing the 
                ! three cycle loop.
                ! If there are 0 or 2 positive elements, the walker would return with the opposite sign from its starting point, 
                ! and the loop is considered 'sign incoherent'.

                IF((NoPos.eq.1).or.(NoPos.eq.3)) THEN
                    SignCohTri=SignCohTri+(REAL(Hjk%v,dp)*REAL(Hij%v,dp)*REAL(Hik%v,dp))
                    NoSignCohTri=NoSignCohTri+1.D0
                    BinNo=CEILING(((REAL(Hjk%v,dp)*REAL(Hij%v,dp)*REAL(Hik%v,dp))*NoTriConBins)/TriConMax)
                    IF((BinNo.gt.NoTriConBins)) THEN
                        WRITE(6,*) 'The value about to be histogrammed is :',(REAL(Hjk%v,dp)*REAL(Hij%v,dp)*REAL(Hik%v,dp))
                        CALL FLUSH(6)
                        CALL Stop_All('PerformFCIMCCycle','Trying to histogram the sign coherent triangles of determinants, &
                                                                                & but a value is outside the chosen range.')
                    ELSEIF((BinNo.le.0).and.((REAL(Hjk%v,dp)*REAL(Hij%v,dp)*REAL(Hik%v,dp)).ne.0.D0)) THEN
                        WRITE(6,*) 'The value about to be histogrammed is :',(REAL(Hjk%v,dp)*REAL(Hij%v,dp)*REAL(Hik%v,dp))
                        CALL FLUSH(6)
                        CALL Stop_All('PerformFCIMCCycle','Trying to histogram the sign coherent triangles of determinants, &
                                                                                & but a value is below 0.')
                    ELSEIF(BinNo.gt.0) THEN
                        SignCohTriHist(2,BinNo)=SignCohTriHist(2,BinNo)+1.D0
                        IF(tHF) SignCohHFTriHist(2,BinNo)=SignCohHFTriHist(2,BinNo)+1.D0
                    ENDIF
                ELSEIF((NoNeg.eq.1).or.(NoNeg.eq.3)) THEN
                    SignIncohTri=SignIncohTri+(REAL(Hjk%v,dp)*REAL(Hij%v,dp)*REAL(Hik%v,dp))
                    NoSignIncohTri=NoSignIncohTri+1.D0
                    BinNo=CEILING((ABS((REAL(Hjk%v,dp)*REAL(Hij%v,dp)*REAL(Hik%v,dp)))*NoTriConBins)/TriConMax)
                    IF((BinNo.gt.NoTriConBins)) THEN
                        WRITE(6,*) 'The value about to be histogrammed is :',(REAL(Hjk%v,dp)*REAL(Hij%v,dp)*REAL(Hik%v,dp))
                        CALL FLUSH(6)
                        CALL Stop_All('PerformFCIMCCycle','Trying to histogram the sign coherent triangles of determinants, &
                                                                                & but a value is outside the chosen range.')
                    ELSEIF((BinNo.le.0).and.((REAL(Hjk%v,dp)*REAL(Hij%v,dp)*REAL(Hik%v,dp)).ne.0.D0)) THEN
                        WRITE(6,*) 'The value about to be histogrammed is :',(REAL(Hjk%v,dp)*REAL(Hij%v,dp)*REAL(Hik%v,dp))
                        CALL FLUSH(6)
                        CALL Stop_All('PerformFCIMCCycle','Trying to histogram the sign coherent triangles of determinants, &
                                                                                & but a value is below 0.')
                    ELSEIF(BinNo.gt.0) THEN 
                        SignIncohTriHist(2,BinNo)=SignIncohTriHist(2,BinNo)+1.D0
                        IF(tHF) SignIncohHFTriHist(2,BinNo)=SignIncohHFTriHist(2,BinNo)+1.D0
                    ENDIF
                ENDIF

                ! TriConHEls(1,1) - number of singles
                ! TriConHEls(1,2) - sum of single elements
                ! TriConHEls(2,1) - number of doubles
                ! TriConHEls(2,2) - sum of double elements
         
                k=1
                do while (k.le.3)
                    ! consider each of the 3 H elements, whose excitation levels have been calculated.
                    IF(k.eq.1) THEN
                        ICgen=IC3
                        HEl=Hjk
                    ELSEIF(k.eq.2) THEN
                        ICgen=IC2
                        HEl=Hik
                    ELSEIF(k.eq.3) THEN
                        ICgen=IC
                        HEl=Hij
                    ELSE
                        WRITE(6,*) 'error in k'
                        CALL FLUSH(6)
                        stop
                    ENDIF

                    ! add the H elements to the appropriate histogram, depending on their excitation level.
                    IF(ICgen.eq.1) THEN
                        TriConHEls(1,1)=TriConHEls(1,1)+1.D0
                        TriConHEls(1,2)=TriConHEls(1,2)+ABS(REAL(HEl%v,dp))
                        BinNo=CEILING((REAL(HEl%v,dp)+TriConHElSingMax)*NoTriConHElBins)/(2*TriConHElSingMax)
                        TriConnHElHistSing(2,BinNo)=TriConnHElHistSing(2,BinNo)+1.D0
                    ELSEIF(ICgen.eq.2) THEN
                        TriConHEls(2,1)=TriConHEls(2,1)+1.D0
                        TriConHEls(2,2)=TriConHEls(2,2)+ABS(REAL(HEl%v,dp))
                        BinNo=CEILING((REAL(HEl%v,dp)+TriConHElDoubMax)*NoTriConHElBins)/(2*TriConHElDoubMax)
                        TriConnHElHistDoub(2,BinNo)=TriConnHElHistDoub(2,BinNo)+1.D0
                    ELSE
                        WRITE(6,*) 'H element value : ',REAL(HEl%v,dp)
                        WRITE(6,*) 'IC (excitation level) : ',ICgen
                        CALL Stop_All('PerformFCIMCCycle','An H element is neither a single nor double, but it is supposedly &
                                                           & connected.')
                    ENDIF

                    IF(BinNo.gt.NoTriConHElBins) THEN
                        WRITE(6,*) 'The value about to be histogrammed is :',(REAL(HEl%v,dp))
                        WRITE(6,*) 'With excitation level : ',ICgen
                        CALL FLUSH(6)
                        CALL Stop_All('PerformFCIMCCycle','Trying to histogram an H element in a triangle of determinants, &
                                                                                & but the value is outside the chosen range.')
                    ENDIF
                    IF((BinNo.le.0).and.(REAL(HEl%v,dp).ne.0.D0)) THEN
                        WRITE(6,*) 'The value about to be histogrammed is :',(REAL(HEl%v,dp))
                        WRITE(6,*) 'With excitation level : ',ICgen
                        WRITE(6,*) 'Bin number : ',BinNo
                        CALL FLUSH(6)
                        CALL Stop_All('PerformFCIMCCycle','Trying to histogram an H element in a triangle of determinants, &
                                                                                & but the value is below 0.')
                    ENDIF

                    k=k+1
                enddo

            ENDIF
        ENDIF

    ENDSUBROUTINE FindTriConnections

    SUBROUTINE PrintTriConnStats(Iteration)
        REAL*8 :: TriConStats(4),AllTriConStats(4)
        INTEGER :: error,Iteration

!Write to files the sum of the sign coherent and incoherent triangles. 
        TriConStats(1)=NoSignCohTri
        TriConStats(2)=NoSignIncohTri
        TriConStats(3)=SignCohTri
        TriConStats(4)=SignIncohTri
        AllTriConStats(:)=0.D0

#ifdef PARALLEL
        CALL MPI_Reduce(TriConStats,AllTriConStats,4,MPI_DOUBLE_PRECISION,MPI_SUM,Root,MPI_COMM_WORLD,error)
#else
        AllTriConStats=TriConStats
#endif

        IF(iProcIndex.eq.Root) THEN
            WRITE(77,"(I12,2F24.2,8F20.10)") Iteration,AllTriConStats(1),AllTriConStats(2),AllTriConStats(3),AllTriConStats(4),(AllTriConStats(3)/(Iteration)),&
                                             &(AllTriConStats(4)/(Iteration)),(AllTriConStats(3)/AllTriConStats(1)),(AllTriConStats(4)/AllTriConStats(2)),&
                                             &(AllTriConStats(1)/AllTriConStats(2)),(ABS(AllTriConStats(3)/AllTriConStats(4)))
        ENDIF

    ENDSUBROUTINE PrintTriConnStats
 
 
    SUBROUTINE PrintTriConnHist()
        INTEGER :: error,i
        CHARACTER(len=*), PARAMETER :: this_routine='PrintTriConnHist'

#ifdef PARALLEL
        CALL MPI_Reduce(SignCohTriHist,AllSignCohTriHist,2*NoTriConBins,MPI_DOUBLE_PRECISION,MPI_SUM,Root,MPI_COMM_WORLD,error)
        CALL MPI_Reduce(SignIncohTriHist,AllSignIncohTriHist,2*NoTriConBins,MPI_DOUBLE_PRECISION,MPI_SUM,Root,MPI_COMM_WORLD,error)

        CALL MPI_Reduce(SignCohHFTriHist,AllSignCohHFTriHist,2*NoTriConBins,MPI_DOUBLE_PRECISION,MPI_SUM,Root,MPI_COMM_WORLD,error)
        CALL MPI_Reduce(SignIncohHFTriHist,AllSignIncohHFTriHist,2*NoTriConBins,MPI_DOUBLE_PRECISION,MPI_SUM,Root,MPI_COMM_WORLD,error)
#else
        AllSignCohTriHist=SignCohTriHist
        AllSignIncohTriHist=SignIncohTriHist
        AllSignCohHFTriHist=SignCohHFTriHist
        AllSignIncohHFTriHist=SignIncohHFTriHist
#endif

        IF(iProcIndex.eq.Root) THEN
            OPEN(78,file='TriConnHistograms',status='unknown')
            WRITE(78,"(4A25)") "Sign Coh Bin Value","No. in bin","SignIncoh Bin Value","No. in bin"
            OPEN(79,file='TriConnHFHistograms',status='unknown')
            WRITE(79,"(4A25)") "Sign Coh Bin Value","No. in bin","SignIncoh Bin Value","No. in bin"
 
            do i=1,NoTriConBins
                IF((AllSignCohTriHist(2,i).ne.0.D0).or.(AllSignIncohTriHist(2,i).ne.0.D0)) THEN
                    WRITE(78,"(4F25.10)") SignCohTriHist(1,i),AllSignCohTriHist(2,i),SignIncohTriHist(1,i),AllSignIncohTriHist(2,i)
                ENDIF
                IF((AllSignCohHFTriHist(2,i).ne.0.D0).or.(AllSignIncohHFTriHist(2,i).ne.0.D0)) THEN
                    WRITE(79,"(4F25.10)") SignCohHFTriHist(1,i),AllSignCohHFTriHist(2,i),SignIncohHFTriHist(1,i),AllSignIncohHFTriHist(2,i)
                ENDIF
            enddo 
            CLOSE(78)
            CLOSE(79)
        ENDIF

#ifdef PARALLEL
        CALL MPI_Barrier(MPI_COMM_WORLD,error)
#endif

        DEALLOCATE(SignIncohTriHist)
        CALL LogMemDealloc(this_routine,SignIncohTriHistTag)
        DEALLOCATE(SignCohTriHist)
        CALL LogMemDealloc(this_routine,SignCohTriHistTag)
        DEALLOCATE(SignCohHFTriHist)
        CALL LogMemDealloc(this_routine,SignCohHFTriHistTag)
        DEALLOCATE(SignIncohHFTriHist)
        CALL LogMemDealloc(this_routine,SignIncohHFTriHistTag)

        IF(iProcIndex.eq.Root) THEN
            DEALLOCATE(AllSignCohTriHist)
            CALL LogMemDealloc(this_routine,AllSignCohTriHistTag)
            DEALLOCATE(AllSignIncohTriHist)
            CALL LogMemDealloc(this_routine,AllSignIncohTriHistTag)
            DEALLOCATE(AllSignCohHFTriHist)
            CALL LogMemDealloc(this_routine,AllSignCohHFTriHistTag)
            DEALLOCATE(AllSignIncohHFTriHist)
            CALL LogMemDealloc(this_routine,AllSignIncohHFTriHistTag)
        ENDIF


    ENDSUBROUTINE PrintTriConnHist


    SUBROUTINE PrintTriConnHElHist()
        INTEGER :: error,i
        CHARACTER(len=*), PARAMETER :: this_routine='PrintTriConnHElHist'
        REAL*8 :: AllTriConHEls(3,2)


        AllTriConHEls(:,:)=0.D0
#ifdef PARALLEL
        CALL MPI_Reduce(TriConHEls,AllTriConHEls,6,MPI_DOUBLE_PRECISION,MPI_SUM,Root,MPI_COMM_WORLD,error)
#else
        AllTriConHEls=TriConHEls
#endif
        ! TriConHEls(1,1) - number of singles
        ! TriConHEls(1,2) - sum of single elements
        ! TriConHEls(2,1) - number of doubles
        ! TriConHEls(2,2) - sum of double elements
        ! TriConHEls(3,1) - number of Hjk elements
        ! TriConHEls(3,2) - sum of Hjk elements
        IF(iProcIndex.eq.Root) THEN
            WRITE(6,*) "***"
            WRITE(6,*) "*** Stats for determinants connected in triangular forms. ***"
            WRITE(6,*) "Number of single H elements included in the histograms : ",AllTriConHEls(1,1)
            WRITE(6,*) "These elements sum to : ",AllTriConHEls(1,2)
            WRITE(6,*) "which amounts to an average SINGLE H element size of : ",(AllTriConHEls(1,2)/AllTriConHEls(1,1)) 
            WRITE(6,*) "***"
            WRITE(6,*) "Number of double H elements included in the histograms : ",AllTriConHEls(2,1)
            WRITE(6,*) "These elements sum to : ",AllTriConHEls(2,2)
            WRITE(6,*) "which amounts to an average DOUBLE H element size of : ",(AllTriConHEls(2,2)/AllTriConHEls(2,1)) 
            WRITE(6,*) "***"
            WRITE(6,*) "The average size of all H elements is then : ",((AllTriConHEls(2,2)+AllTriConHEls(1,2))/(AllTriConHEls(1,1)+AllTriConHEls(2,1)))
            WRITE(6,*) "***"
            WRITE(6,*) "***"
            WRITE(6,*) "Number of Hjk elements histogrammed : ",AllTriConHEls(3,1)
            WRITE(6,*) "These elements sum to : ",AllTriConHEls(3,2)
            WRITE(6,*) "which amounts to an average Hjk elements size of : ",(AllTriConHEls(3,2)/AllTriConHEls(3,1))
            WRITE(6,*) "***"
        ENDIF

#ifdef PARALLEL
        CALL MPI_Reduce(TriConnHElHistSing,AllTriConnHElHistSing,2*NoTriConHElBins,MPI_DOUBLE_PRECISION,MPI_SUM,Root,MPI_COMM_WORLD,error)
        CALL MPI_Reduce(TriConnHElHistDoub,AllTriConnHElHistDoub,2*NoTriConHElBins,MPI_DOUBLE_PRECISION,MPI_SUM,Root,MPI_COMM_WORLD,error)

        CALL MPI_Reduce(TriHjkHistSing,AllTriHjkHistSing,2*NoTriConHElBins,MPI_DOUBLE_PRECISION,MPI_SUM,Root,MPI_COMM_WORLD,error)
        CALL MPI_Reduce(TriHjkHistDoub,AllTriHjkHistDoub,2*NoTriConHElBins,MPI_DOUBLE_PRECISION,MPI_SUM,Root,MPI_COMM_WORLD,error)
#else
        AllTriConnHElHistSing=TriConnHElHistSing
        AllTriConnHElHistDoub=TriConnHElHistDoub
        AllTriHjkHistSing=TriHjkHistSing
        AllTriHjkHistDoub=TriHjkHistDoub
#endif

        IF(iProcIndex.eq.Root) THEN
            OPEN(80,file='TriConHElHistSing',status='unknown')
            WRITE(80,"(2A25)") "Bin Value","No. in bin"
            OPEN(81,file='TriConHElHistDoub',status='unknown')
            WRITE(81,"(2A25)") "Bin Value","No. in bin"
 
            OPEN(82,file='TriHjkHistSing',status='unknown')
            WRITE(82,"(2A25)") "Bin Value","No. in bin"
            OPEN(83,file='TriHjkHistDoub',status='unknown')
            WRITE(83,"(2A25)") "Bin Value","No. in bin"

            do i=1,NoTriConHElBins
                IF(AllTriConnHElHistSing(2,i).ne.0.D0) THEN
                    WRITE(80,"(2F25.10)") TriConnHElHistSing(1,i),AllTriConnHElHistSing(2,i)
                ENDIF
                IF(AllTriConnHElHistDoub(2,i).ne.0.D0) THEN
                    WRITE(81,"(2F25.10)") TriConnHElHistDoub(1,i),AllTriConnHElHistDoub(2,i)
                ENDIF
                IF(AllTriHjkHistSing(2,i).ne.0.D0) THEN
                    WRITE(82,"(2F25.10)") TriHjkHistSing(1,i),AllTriHjkHistSing(2,i)
                ENDIF
                IF(AllTriHjkHistDoub(2,i).ne.0.D0) THEN
                    WRITE(83,"(2F25.10)") TriHjkHistDoub(1,i),AllTriHjkHistDoub(2,i)
                ENDIF
            enddo 
            CLOSE(80)
            CLOSE(81)
            CLOSE(82)
            CLOSE(83)
        ENDIF

#ifdef PARALLEL
        CALL MPI_Barrier(MPI_COMM_WORLD,error)
#endif

        DEALLOCATE(TriConnHElHistSing)
        CALL LogMemDealloc(this_routine,TriConnHElHistSingTag)
        DEALLOCATE(TriConnHElHistDoub)
        CALL LogMemDealloc(this_routine,TriConnHElHistDoubTag)
        DEALLOCATE(TriHjkHistSing)
        CALL LogMemDealloc(this_routine,TriHjkHistSingTag)
        DEALLOCATE(TriHjkHistDoub)
        CALL LogMemDealloc(this_routine,TriHjkHistDoubTag)

        IF(iProcIndex.eq.Root) THEN
            DEALLOCATE(AllTriConnHElHistSing)
            CALL LogMemDealloc(this_routine,AllTriConnHElHistSingTag)
            DEALLOCATE(AllTriConnHElHistDoub)
            CALL LogMemDealloc(this_routine,AllTriConnHElHistDoubTag)
            DEALLOCATE(AllTriHjkHistSing)
            CALL LogMemDealloc(this_routine,AllTriHjkHistSingTag)
            DEALLOCATE(AllTriHjkHistDoub)
            CALL LogMemDealloc(this_routine,AllTriHjkHistDoubTag)
        ENDIF
        
    ENDSUBROUTINE PrintTriConnHElHist


!These are available to both serial and parallel
    SUBROUTINE InitSpinCoupHEl()

        NoNegSpinCoup=0.D0
        NoPosSpinCoup=0.D0
        SumNegSpinCoup=0.D0
        SumPosSpinCoup=0.D0
        SumHFCon=0.D0
        SumSpinCon=0.D0
        
        IF(iProcIndex.eq.root) THEN
            OPEN(87,file='SpinCoupHEl',status='unknown')
!            WRITE(87,'(A8,10A19)') "1.Iter","2.No.Pos HEls","3.No.Neg HEls","4.Sum Pos HEl","5.Sum Neg HEl","6.Net Sum HEl","7.No.Pos/Iter","8.No.Neg/Iter","9.Sum Pos/Iter","10.Sum Neg/Iter","11.Net Sum/Iter"
            WRITE(87,'(A8,11A18)') "1.Iter","2.No.Pos HEls","3.No.Neg HEls","4.Sum Pos HEl","5.Sum Neg HEl","6.No.Pos/Iter","7.No.Neg/Iter","8.Sum Pos/Iter","9.Sum Neg/Iter",&
            &"10.Sum HF HEls","11.Sum SpinCoup","12.HF HEl/SpinHEl"
        ENDIF

    ENDSUBROUTINE InitSpinCoupHEl

! This function is based on attemptcreatepar, however it only attempts to create particles back on a parent determinant from which it
! was spawned.
! It decides whether or not we are going to create a child back on that parent.  It returns 0 for no spawning, and +1/-1 for a child with sign.
    INTEGER FUNCTION AttemptCreateParBack(iLutCurr,iLutParent,WSign,rh,nParts,tMinorDetList)
        use GenRandSymExcitNUMod , only : GenRandSymExcitBiased
        INTEGER :: StoreNumTo,StoreNumFrom,DetLT,i,ExtraCreate,Ex(2,2),WSign,nParts
        INTEGER :: iLutCurr(0:NIfTot),Bin,iLutParent(0:NIfTot),PartInd,ExcitLev,IC
        LOGICAL :: SymAllowed,tSuccess,tMinorDetList
        REAL*8 :: Prob=1.D0,r,rat
        TYPE(HElement) :: rh,rhcheck


!Divide by the probability of creating the excitation to negate the fact that we are only creating a few determinants
        rat=Tau*abs(rh%v)*REAL(nParts,dp)/Prob

!If probability is > 1, then we can just create multiple children at the chosen determinant
        ExtraCreate=INT(rat)
        rat=rat-REAL(ExtraCreate)


!Stochastically choose whether to create or not according to ranlux 
        IF(tMerTwist) THEN
            r = genrand_real2_dSFMT() 
        ELSE
            CALL RANLUX(r,1)
        ENDIF
        IF(rat.gt.r) THEN
!Child is created - what sign is it?
            IF(WSign.gt.0) THEN
!Parent particle is positive
                IF(real(rh%v).gt.0.D0) THEN
                    AttemptCreateParBack=-1     !-ve walker created
                ELSE
                    AttemptCreateParBack=1      !+ve walker created
                ENDIF

            ELSE
!Parent particle is negative
                IF(real(rh%v).gt.0.D0) THEN
                    AttemptCreateParBack=1      !+ve walker created
                ELSE
                    AttemptCreateParBack=-1     !-ve walker created
                ENDIF
            ENDIF

        ELSE
!No child particle created
            AttemptCreateParBack=0
        ENDIF

        IF(ExtraCreate.ne.0) THEN
!Need to include the definitely create additional particles from a initial probability > 1

            IF(AttemptCreateParBack.lt.0) THEN
!In this case particles are negative
                AttemptCreateParBack=AttemptCreateParBack-ExtraCreate
            ELSEIF(AttemptCreateParBack.gt.0) THEN
!Include extra positive particles
                AttemptCreateParBack=AttemptCreateParBack+ExtraCreate
            ELSEIF(AttemptCreateParBack.eq.0) THEN
!No particles were stochastically created, but some particles are still definatly created - we need to determinant their sign...
                IF(WSign.gt.0) THEN
                    IF(real(rh%v).gt.0.D0) THEN
                        AttemptCreateParBack=-1*ExtraCreate    !Additional particles are negative
                    ELSE
                        AttemptCreateParBack=ExtraCreate       !Additional particles are positive
                    ENDIF
                ELSE
                    IF(real(rh%v).gt.0.D0) THEN
                        AttemptCreateParBack=ExtraCreate
                    ELSE
                        AttemptCreateParBack=-1*ExtraCreate
                    ENDIF
                ENDIF
            ENDIF
        ENDIF

        RETURN

    END FUNCTION AttemptCreateParBack

   SUBROUTINE InitMinorDetsStar()
! This routine simply sets up the arrays etc for the particles spawned into the determinant space that is not in the allowed list.
! MinorStarDets etc are the particles remaining after annihilation, death etc, whereas MinorSpawnDets etc are the walkers newly
! spawned in a particular iteration.
        INTEGER :: ierr
        CHARACTER(len=*), PARAMETER :: this_routine='InitMinorDetsStar'

        ! The actual determinants.
        ALLOCATE(MinorStarDets(0:NIfTot,1:MaxWalkersPart),stat=ierr)
        CALL LogMemAlloc('MinorStarDets',(NIfTot+1)*MaxWalkersPart,4,this_routine,MinorStarDetsTag,ierr)
        IF(ierr.ne.0) CALL Stop_All(this_routine,'Problem allocating memory to MinorStarDets')
        ALLOCATE(MinorSpawnDets(0:NIfTot,1:MaxSpawned),stat=ierr)
        CALL LogMemAlloc('MinorSpawnDets',(NIfTot+1)*MaxSpawned,4,this_routine,MinorSpawnDetsTag,ierr)
        IF(ierr.ne.0) CALL Stop_All(this_routine,'Problem allocating memory to MinorSpawnDets')
        MinorSpawnDets(:,:)=0
        ALLOCATE(MinorSpawnDets2(0:NIfTot,1:MaxSpawned),stat=ierr)
        CALL LogMemAlloc('MinorSpawnDets2',(NIftot+1)*MaxSpawned,4,this_routine,MinorSpawnDets2Tag,ierr)
        IF(ierr.ne.0) CALL Stop_All(this_routine,'Problem allocating memory to MinorSpawnDets2')


        ! The sign (number of walkers) on each determinant.
        ALLOCATE(MinorStarSign(1:MaxWalkersPart),stat=ierr)
        CALL LogMemAlloc('MinorStarSign',MaxWalkersPart,4,this_routine,MinorStarSignTag,ierr)
        IF(ierr.ne.0) CALL Stop_All(this_routine,'Problem allocating memory to MinorStarSign')
        ALLOCATE(MinorSpawnSign(0:MaxSpawned),stat=ierr)
        CALL LogMemAlloc('MinorSpawnSign',MaxSpawned+1,4,this_routine,MinorSpawnSignTag,ierr)
        IF(ierr.ne.0) CALL Stop_All(this_routine,'Problem allocating memory to MinorSpawnSign')
        ALLOCATE(MinorSpawnSign2(0:MaxSpawned),stat=ierr)
        CALL LogMemAlloc('MinorSpawnSign2',MaxSpawned+1,4,this_routine,MinorSpawnSign2Tag,ierr)
        IF(ierr.ne.0) CALL Stop_All(this_routine,'Problem allocating memory to MinorSpawnSign2')


        ! The parent from which the walker was spawned.
        ALLOCATE(MinorStarParent(0:NIfTot,1:MaxWalkersPart),stat=ierr)
        CALL LogMemAlloc('MinorStarParent',(NIfTot+1)*MaxWalkersPart,4,this_routine,MinorStarParentTag,ierr)
        IF(ierr.ne.0) CALL Stop_All(this_routine,'Problem allocating memory to MinorStarParent')
        ALLOCATE(MinorSpawnParent(0:NIfTot,1:MaxSpawned),stat=ierr)
        CALL LogMemAlloc('MinorSpawnParent',(NIfTot+1)*MaxSpawned,4,this_routine,MinorSpawnParentTag,ierr)
        IF(ierr.ne.0) CALL Stop_All(this_routine,'Problem allocating memory to MinorSpawnParent')
        ALLOCATE(MinorSpawnParent2(0:NIfTot,1:MaxSpawned),stat=ierr)
        CALL LogMemAlloc('MinorSpawnParent2',(NIfTot+1)*MaxSpawned,4,this_routine,MinorSpawnParent2Tag,ierr)
        IF(ierr.ne.0) CALL Stop_All(this_routine,'Problem allocating memory to MinorSpawnParent2')


        ! The energy of the "forbidden" determinant with a walker on it.
        ALLOCATE(MinorStarHii(1:MaxWalkersPart),stat=ierr)
        CALL LogMemAlloc('MinorStarHii',MaxWalkersPart,8,this_routine,MinorStarHiiTag,ierr)
        IF(ierr.ne.0) CALL Stop_All(this_routine,'Problem allocating memory to MinorStarHii')

        ! The diagonal element connecting the "forbidden" determinant to its allowed parent.
        ALLOCATE(MinorStarHij(1:MaxWalkersPart),stat=ierr)
        CALL LogMemAlloc('MinorStarHij',MaxWalkersPart,8,this_routine,MinorStarHijTag,ierr)
        IF(ierr.ne.0) CALL Stop_All(this_routine,'Problem allocating memory to MinorStarHij')

        ALLOCATE(HashArray(MaxSpawned),stat=ierr)
        CALL LogMemAlloc('HashArray',MaxSpawned,8,this_routine,HashArrayTag,ierr)
        IF(ierr.ne.0) CALL Stop_All(this_routine,'Problem allocating memory to HashArry')
        HashArray(:)=0
        ALLOCATE(Hash2Array(MaxSpawned),stat=ierr)
        CALL LogMemAlloc('Hash2Array',MaxSpawned,8,this_routine,Hash2ArrayTag,ierr)
        IF(ierr.ne.0) CALL Stop_All(this_routine,'Problem allocating memory to Hash2Arry')
        Hash2Array(:)=0
 
        ALLOCATE(IndexTable(MaxSpawned),stat=ierr)
        CALL LogMemAlloc('IndexTable',MaxSpawned,4,this_routine,IndexTableTag,ierr)
        IF(ierr.ne.0) CALL Stop_All(this_routine,'Problem allocating memory to IndexTable')
        IndexTable(:)=0
        ALLOCATE(Index2Table(MaxSpawned),stat=ierr)
        CALL LogMemAlloc('Index2Table',MaxSpawned,4,this_routine,Index2TableTag,ierr)
        IF(ierr.ne.0) CALL Stop_All(this_routine,'Problem allocating memory to Index2Table')
        Index2Table(:)=0

        ALLOCATE(ProcessVec(MaxSpawned),stat=ierr)
        CALL LogMemAlloc('ProcessVec',MaxSpawned,4,this_routine,ProcessVecTag,ierr)
        IF(ierr.ne.0) CALL Stop_All(this_routine,'Problem allocating memory to ProcessVec')
        ProcessVec(:)=0
        ALLOCATE(Process2Vec(MaxSpawned),stat=ierr)
        CALL LogMemAlloc('Process2Vec',MaxSpawned,4,this_routine,Process2VecTag,ierr)
        IF(ierr.ne.0) CALL Stop_All(this_routine,'Problem allocating memory to Process2Vec')
        Process2Vec(:)=0


    END SUBROUTINE InitMinorDetsStar

!********  The rest of the routines in this module, are for the annihilation of "minor" and "dominant" walkers as well as the guiding function  ********   
    
! This routine is based on RotoAnnihilation (with a wee bit of AnnihilatePartPar).
! It first takes MinorSpawnDets and orders the determinants (note, no compression is needed, determinants may be listed more than once, but these will have
! different parents).
! It then runs through these spawned walkers, and annihilates amongst the spawned.
! It then does a rotation around the processors, annihilating with the MinorStarDets.
! Any walkers which survive this are then added to MinorStarDets, maintaining order.
! MinorValidSpawned is the number of newly spawned walkers on the minor determinants whereas NoMinorWalkersNew are the walkers on the minor dets that have survived previous 
! iterations.  NoMinorWalkersNew is the number to be compared to for each processor.
    SUBROUTINE RotoAnnihilateMinorSpawned(MinorValidSpawned,NoMinorWalkersNew)
        INTEGER :: i,j,MinorValidSpawned,NoMinorWalkersNew,n,error,ierr
        CHARACTER , ALLOCATABLE :: mpibuffer(:)

! First order the newly spawned walkers in terms of determinant, then parent, taking the sign and H element information with it.
        CALL Sort2BitDetsPlus3(MinorValidSpawned,MinorSpawnDets(0:NIfTot,1:MinorValidSpawned),MinorSpawnParent(0:NIfTot,1:MinorValidSpawned),&
        &MinorSpawnSign(1:MinorValidSpawned))
        
!        IF(Iter.gt.1220) THEN
!            WRITE(6,*) 'sort'
!            CALL FLUSH(6)
!        ENDIF

! Make sure all processors have done this before carrying on.
        CALL MPIBarrier(error)


! Run through this list of determinants with walkers on it, and annihilate walkers on the same determinant.  Make sure the correct parent information is kept with
! the walkers that survive.
! Then need to communicate between processors, and annihilate the within the spawned particles, between processors.
! At the end, it should be that walkers on the same determinants have the same sign across all processors.
       
      
        CALL AnnihilateAmongstMinorSpawned(MinorValidSpawned)
 
!        IF(Iter.gt.1220) THEN
!            WRITE(6,*) 'annihilate amongst'
!            CALL FLUSH(6)
!        ENDIF


! Should now have the spawned walkers ordered in terms of determinant then parent, with each determinant/parent combination only 
! specified once.

! At the end, should either have each determinant specified once, or more than once with different parents but the same sign.        

! Annihilate with the MinorStarDets on the original processor        
! If multiple entries of the determinant on which we are annihilating - want to kind of add up these walkers, then randomly select the ones to annihilate.


        CALL AnnihilateMinorSpawnedParts(MinorValidSpawned,NoMinorWalkersNew)
 
!        IF(Iter.gt.1220) THEN
!            WRITE(6,*) 'annihilate minor'
!            CALL FLUSH(6)
!        ENDIF


!Allocate a buffer here to hold particles when using a buffered send...
!The buffer wants to be able to hold (MaxSpawned+1)x(NIfD+2) integers (*4 for in bytes). If we could work out the maximum ValidSpawned accross the determinants,
!it could get reduced to this... 
        IF(nProcessors.ne.1) THEN
            ALLOCATE(mpibuffer(8*(MaxSpawned+1)*(NIfTot+3)),stat=ierr)
            IF(ierr.ne.0) THEN
                CALL Stop_All("RotoAnnihilateMinor","Error allocating memory for transfer buffers...")
            ENDIF
#ifdef PARALLEL
            CALL MPI_Buffer_attach(mpibuffer,8*(MaxSpawned+1)*(NIfTot+3),error)
#endif
            IF(error.ne.0) THEN
                CALL Stop_All("RotoAnnihilateMinor","Error allocating memory for transfer buffers...")
            ENDIF
        ENDIF
        CALL MPIBarrier(error)

        do n=1,nProcessors-1

! Take the walkers that survive the annihilation amongst spawned particles and rotate them around each processor, annihilating with MinorStarDets etc.
            CALL RotateMinorParticles(MinorValidSpawned)
     
!            IF(Iter.gt.1220) THEN
!                WRITE(6,*) 'rotate'
!                CALL FLUSH(6)
!            ENDIF


            CALL AnnihilateMinorSpawnedParts(MinorValidSpawned,NoMinorWalkersNew)
     
!            IF(Iter.gt.1220) THEN
!                WRITE(6,*) 'annihilate minor'
!                CALL FLUSH(6)
!            ENDIF

        enddo


! Then do one final rotation (if nProcessors.gt.1) to get back to the original processor, and add the survivors into MinorStarDets (MinorStarDets will not have any contribution 
! to the energy - may want to put in clause that we cannot select the dominant 2s).
        IF(nProcessors.gt.1) THEN

            CALL MPIBarrier(error)
            CALL RotateMinorParticles(MinorValidSpawned)
 
!            IF(Iter.gt.1220) THEN
!                WRITE(6,*) 'last rotate'
!                CALL FLUSH(6)
!            ENDIF
!Detach buffers
#ifdef PARALLEL
            CALL MPI_Buffer_detach(mpibuffer,8*(MaxSpawned+1)*(NIfTot+3),error)
#endif
            DEALLOCATE(mpibuffer)

        ENDIF

        CALL InsertRemoveMinorParts(MinorValidSpawned,NoMinorWalkersNew)

!        IF(Iter.gt.1220) THEN
!            WRITE(6,*) 'insert remove'
!            CALL FLUSH(6)
!        ENDIF



    ENDSUBROUTINE RotoAnnihilateMinorSpawned




    SUBROUTINE AnnihilateAmongstMinorSpawned(MinorValidSpawned)
! This routine takes the newly spawned walkers on the minor determinants, and annihilates those on the same determinant    
        INTEGER :: i,j,k,ToAnnihilateIndex,MinorValidSpawned,MinorValidSpawnedNew,ierr,error,sendcounts(nProcessors)
        INTEGER :: TotWalkersDet,InitialBlockIndex,FinalBlockIndex,ToAnnihilateOnProc,VecSlot
        INTEGER :: disps(nProcessors),recvcounts(nProcessors),recvdisps(nProcessors)
        INTEGER :: Minsendcounts,Maxsendcounts,DebugIter,SubListInds(2,nProcessors),MinProc,MinInd
        INTEGER :: SumOppSign,WalkertoAnnihil,NoNegWalk,NoPosWalk
        REAL*8 :: r
        INTEGER(KIND=i2) :: HashCurr,MinBin,RangeofBins,NextBinBound,MinHash
        INTEGER(KIND=i2) , ALLOCATABLE :: TempHash(:)
        INTEGER , ALLOCATABLE :: TempSign(:),TempMinorSpawnSign(:)                                                      
        LOGICAL :: tWrite
        CHARACTER(len=*), PARAMETER :: this_routine='AnnihilateAmongstMinorSpawned'


!First, allocate memory to hold the signs and the hashes while we annihilate
        ALLOCATE(TempSign(MinorValidSpawned),stat=ierr)
        IF(ierr.ne.0) CALL Stop_All(this_routine, 'problem allocating memory to tempsign')
!TempMinorSpawnSign is just MinorSpawnSign, but MinorSpawnSign is used as a kind of AllMinorSpawnSign.
        ALLOCATE(TempMinorSpawnSign(MaxSpawned),stat=ierr)
        IF(ierr.ne.0) CALL Stop_All(this_routine, 'problem allocating memory to tempminorspawnsign')

!Temporary arrays, storing the signs these are going to be mixed.  The hashes are also mixed, but these are not needed after
!so are not reordered.
        TempSign(1:MinorValidSpawned)=MinorSpawnSign(1:MinorValidSpawned)
        TempMinorSpawnSign(1:MinorValidSpawned)=MinorSpawnSign(1:MinorValidSpawned)
        MinorSpawnSign(:)=0

!Create the arrays for index and process
        do i=1,MinorValidSpawned
            IndexTable(i)=i
        enddo
        ProcessVec(1:MinorValidSpawned)=iProcIndex

!Next, order the hash array, taking the index, CPU and sign with it...
!Order the array by abs(mod(Hash,nProcessors)). This will result in a more load-balanced system

        CALL Sort4ILong(MinorValidSpawned,HashArray(1:MinorValidSpawned),IndexTable(1:MinorValidSpawned),ProcessVec(1:MinorValidSpawned),TempMinorSpawnSign(1:MinorValidSpawned))
!Hash's ordered, taking index, ProcessVec and sign with them.  Forget determinants, they're just determined by their hash now.

        IF(nProcessors.ne.1) THEN
!We also need to know the ranges of the hashes to send to each processor. Each range should be the same.
            Rangeofbins=INT(HUGE(Rangeofbins)/(nProcessors/2),8)
            MinBin=-HUGE(MinBin)
            NextBinBound=MinBin+Rangeofbins

!We need to find the indices for each block of hashes which are to be sent to each processor.
!Sendcounts is the size of each block of ordered dets which are going to each processors. This could be binary searched for extra speed.
            j=1
            do i=1,nProcessors    !Search through all possible values of the hashes
                do while((HashArray(j).le.NextBinBound).and.(j.le.MinorValidSpawned))
                    j=j+1
                enddo
                sendcounts(i)=j-1
                IF(i.eq.nProcessors-1) THEN
!Make sure the final bin catches everything...
                    NextBinBound=HUGE(NextBinBound)
                ELSE
                    NextBinBound=NextBinBound+Rangeofbins
                ENDIF
            enddo
        ELSE
            sendcounts(1)=MinorValidSpawned
        ENDIF

        IF(sendcounts(nProcessors).ne.MinorValidSpawned) THEN
            WRITE(6,*) "SENDCOUNTS is: ",sendcounts(:)
            WRITE(6,*) "TOTWALKERSNEW is: ",MinorValidSpawned
            CALL FLUSH(6)
            CALL Stop_All("RotoAnnihilateMinorSpawned","Incorrect calculation of sendcounts")
        ENDIF

!Oops, we have calculated them cumulativly - undo this
        maxsendcounts=sendcounts(1)
        minsendcounts=sendcounts(1)     !Find max & min sendcounts, so that load-balancing can be checked
!        WRITE(6,*) maxsendcounts,minsendcounts
        do i=2,nProcessors
            do j=1,i-1
                sendcounts(i)=sendcounts(i)-sendcounts(j)
            enddo
            IF(sendcounts(i).gt.maxsendcounts) THEN
                maxsendcounts=sendcounts(i)
            ELSEIF(sendcounts(i).lt.minsendcounts) THEN
                minsendcounts=sendcounts(i)
            ENDIF
        enddo

!The disps however do want to be cumulative - this is the array indexing the start of the data block
        disps(1)=0      !Starting element is always the first element
        do i=2,nProcessors
            disps(i)=disps(i-1)+sendcounts(i-1)
        enddo
        
!        IF(Iter.eq.DebugIter) THEN
!            WRITE(6,*) "SENDCOUNTS: "
!            WRITE(6,*) sendcounts(:)
!            WRITE(6,*) "DISPS: "
!            WRITE(6,*) disps(:)
!            CALL FLUSH(6)
!        ENDIF


!We now need to calculate the recvcounts and recvdisps - this is a job for AlltoAll
        recvcounts(1:nProcessors)=0
!Put a barrier here so all processes synchronise
        CALL MPIBarrier(error)

        CALL MPIAlltoAllI(sendcounts(1:nProcessors),1,recvcounts(1:nProcessors),1,error)

!We can now get recvdisps from recvcounts in the same way we obtained disps from sendcounts
        recvdisps(1)=0
        do i=2,nProcessors
            recvdisps(i)=recvdisps(i-1)+recvcounts(i-1)
        enddo

        MaxIndex=recvdisps(nProcessors)+recvcounts(nProcessors)
!Max index is the largest occupied index in the array of hashes to be ordered in each processor 
        IF(MaxIndex.gt.(0.95*MaxSpawned)) THEN
            CALL Warning("AnnihilateAmongstMinorSpawned","Maximum index of annihilation array is close to maximum length. Increase MemoryFacAnnihil")
        ENDIF
!Uncomment this if you want to write out load-balancing statistics.
!        AnnihilPart(:)=0
!        CALL MPI_Gather(MaxIndex,1,MPI_INTEGER,AnnihilPart,1,MPI_INTEGER,root,MPI_COMM_WORLD,error)
!        IF(iProcIndex.eq.root) THEN
!            WRITE(13,"(I10)",advance='no') Iter
!            do i=1,nProcessors
!                WRITE(13,"(I10)",advance='no') AnnihilPart(i)
!            enddo
!            WRITE(13,"(A)") ""
!            CALL FLUSH(13)
!        ENDIF

!        IF(Iter.eq.DebugIter) THEN
!            WRITE(6,*) "RECVCOUNTS: "
!            WRITE(6,*) recvcounts(:)
!            WRITE(6,*) "RECVDISPS: "
!            WRITE(6,*) recvdisps(:),MaxIndex
!            CALL FLUSH(6)
!        ENDIF

!Insert a load-balance check here...maybe find the s.d. of the sendcounts array - maybe just check the range first.
!        IF(TotWalkersNew.gt.200) THEN
!            IF((Maxsendcounts-Minsendcounts).gt.(TotWalkersNew/3)) THEN
!                WRITE(6,"(A,I12)") "**WARNING** Parallel annihilation not optimally balanced on this node, for iter = ",Iter
!                WRITE(6,*) "Sendcounts is: ",sendcounts(:)
!!                CALL FLUSH(6)
!            ENDIF
!        ENDIF
!
        CALL MPIBarrier(error)

!Now send the chunks of hashes to the corresponding processors
!All the '2' arrays are like the 'All' arrays.
!TempMinorSpawnSign is the Signs from each processor, when just MinorSpawnSign is the 'All' array.
        CALL MPIAlltoAllvI8(HashArray(1:MinorValidSpawned),sendcounts,disps,Hash2Array(1:MaxIndex),recvcounts,recvdisps,error)        

!        tWrite=.false.
!        IF(MinorValidSpawned.gt.3) THEN
!            WRITE(6,*) 'TempMinorSpawnSign'
!            do i=1,MinorValidSpawned
!                WRITE(6,*) TempMinorSpawnSign(i)
!            enddo
!            tWrite=.true.
!        ENDIF

!The signs of the hashes, index and CPU also need to be taken with them.
        CALL MPIAlltoAllvI(TempMinorSpawnSign(1:MinorValidSpawned),sendcounts,disps,MinorSpawnSign(1:MaxIndex),recvcounts,recvdisps,error)
        CALL MPIAlltoAllvI(IndexTable(1:MinorValidSpawned),sendcounts,disps,Index2Table(1:MaxIndex),recvcounts,recvdisps,error)
        CALL MPIAlltoAllvI(ProcessVec(1:MinorValidSpawned),sendcounts,disps,Process2Vec(1:MaxIndex),recvcounts,recvdisps,error)
        
!        IF(tWrite) THEN
!            WRITE(6,*) 'MinorSpawnSign'
!            do i=1,20
!                WRITE(6,*) MinorSpawnSign(i)
!            enddo
!            CALL FLUSH(6)
!            CALL Stop_All('','')
!        ENDIF



!Now we need to perform the actual annihilation, running through all the particles and calculating which ones want to be annihilated.

!Here, because we have ordered the hashes initially numerically, we have a set of ordered lists. It is therefore easier to sort them.
!We have to work out how to run sequentially through the hashes, which are a set of nProc seperate ordered lists.
!We would need to have 2*nProc indices, since we will have a set of nProc disjoint ordered sublists.
!SubListInds(1,iProc)=index of current hash from processor iProc
!SubListInds(2,iProc)=index of final hash from processor iProc
!Indices can be obtained from recvcounts and recvdisps - recvcounts(iProc-1) is number of hashes from iProc
!recvdisps(iProc-1) is the displacement to the start of the hashes from iProc
        do i=1,nProcessors-1
            SubListInds(1,i)=recvdisps(i)+1
            SubListInds(2,i)=recvdisps(i+1)
        enddo
        SubListInds(1,nProcessors)=recvdisps(nProcessors)+1
        SubListInds(2,nProcessors)=MaxIndex

!Reorder the lists so that they are in numerical order.
        j=1
        do while(j.le.MaxIndex)
            do i=1,nProcessors
                IF(SubListInds(1,i).le.SubListInds(2,i)) THEN
!This block still has hashes which want to be sorted
                    MinHash=Hash2Array(SubListInds(1,i))
                    MinProc=i
                    MinInd=SubListInds(1,i)
                    EXIT
                ENDIF
!                    IF(i.eq.nProcessors) THEN
!                        WRITE(6,*) "ERROR HERE!!"
!                        CALL FLUSH(6)
!                    ENDIF
            enddo
            IF(MinHash.ne.HashCurr) THEN
                do i=MinProc+1,nProcessors
                    IF((SubListInds(1,i).le.SubListInds(2,i)).and.(Hash2Array(SubListInds(1,i)).lt.MinHash)) THEN
                        MinHash=Hash2Array(SubListInds(1,i))
                        MinProc=i
                        MinInd=SubListInds(1,i)
                        IF(MinHash.eq.HashCurr) THEN
                            EXIT
                        ENDIF
                    ENDIF
                enddo
            ENDIF
!Next smallest hash is MinHash - move the ordered elements into the other array.
            HashArray(j)=MinHash
            IndexTable(j)=Index2Table(MinInd)
            ProcessVec(j)=Process2Vec(MinInd)
            TempMinorSpawnSign(j)=MinorSpawnSign(MinInd)
            HashCurr=MinHash
!Move through the block
            j=j+1
            SubListInds(1,MinProc)=SubListInds(1,MinProc)+1
        enddo

        IF((j-1).ne.MaxIndex) THEN
            CALL Stop_All(this_routine,"Error here in the merge sort algorithm")
        ENDIF

!Need to copy the lists back to the original array
        do i=1,MaxIndex
            Index2Table(i)=IndexTable(i)
            Process2Vec(i)=ProcessVec(i)
            MinorSpawnSign(i)=TempMinorSpawnSign(i)
            Hash2Array(i)=HashArray(i)
        enddo
 
!            Index2Table(1:MaxIndex)=IndexTable(1:MaxIndex)
!            Process2Vec(1:MaxIndex)=ProcessVec(1:MaxIndex)
!            CurrentSign(1:MaxIndex)=NewSign(1:MaxIndex)
!            HashArray(1:MaxIndex)=Hash2Array(1:MaxIndex)
                
!        WRITE(6,*) 'MinorSpawnSign'
!        do i=1,MaxIndex
!            WRITE(6,*) MinorSpawnSign(i)
!        enddo

!Work out the index of the particles which want to be annihilated
        j=1
        ToAnnihilateIndex=1
        do while(j.le.MaxIndex)
            TotWalkersDet=0
            NoPosWalk=0
            NoNegWalk=0
            InitialBlockIndex=j
            FinalBlockIndex=j-1         !Start at j-1 since we are increasing FinalBlockIndex even with the first det in the next loop
            HashCurr=Hash2Array(j)
            do while((Hash2Array(j).eq.HashCurr).and.(j.le.MaxIndex))
!                WRITE(6,*) 'Hash2Array',Hash2Array(j)
!                WRITE(6,*) 'HashCurr',HashCurr
!                WRITE(6,*) 'MinorSpawnSign',MinorSpawnSign(j)
!First loop counts walkers in the block - TotWalkersDet is then the residual sign of walkers on that determinant
                TotWalkersDet=TotWalkersDet+MinorSpawnSign(j)
                IF(MinorSpawnSign(j).gt.0) NoPosWalk=NoPosWalk+ABS(MinorSpawnSign(j))
                IF(MinorSpawnSign(j).lt.0) NoNegWalk=NoNegWalk+ABS(MinorSpawnSign(j))
! These will just annihilate each other until TotWalkersDet is the Total number of walkers (w sign) that should remain on that determinant.
!                IF(MinorSpawnSign(j).eq.1) THEN
!                    TotWalkersDet=TotWalkersDet+1
!                ELSE
!                    TotWalkersDet=TotWalkersDet-1
!                ENDIF
                FinalBlockIndex=FinalBlockIndex+1
                j=j+1
            enddo

!            IF((NoPosWalk.gt.0).and.(NoNegWalk.gt.0)) THEN
!                WRITE(6,*) 'NoPosWalk gt 0 and NoNegWalk gt 0'
!                WRITE(6,*) 'Index,hash,and Sign'
!                do i=InitialBlockIndex,FinalBlockIndex
!                    WRITE(6,*) i,Index2Table(i),IndexTable(i),hash2array(i),hasharray(i),MinorSpawnSign(i)
!                enddo
!                WRITE(6,*) 'NoPosWalk,',NoPosWalk,'NoNegWalk',NoNegWalk
!                WRITE(6,*) 'TotWalkersDet',TotWalkersDet
!            ENDIF

!Second run through the block of same determinants marks walkers for annihilation
            IF((TotWalkersDet.eq.0).and.(NoPosWalk.gt.0)) THEN

                do k=InitialBlockIndex,FinalBlockIndex
!All walkers in block want to be annihilated from now on.
                    IndexTable(ToAnnihilateIndex)=Index2Table(k)
                    ProcessVec(ToAnnihilateIndex)=Process2Vec(k)
!                    Hash2Array(ToAnnihilateIndex)=HashArray(k)     !This is not strictly needed - remove after checking
!                    NewSign(ToAnnihilateIndex)=CurrentSign(k)       !This is also need needed, but useful for checking
!                    IF(Iter.eq.DebugIter) WRITE(6,*) "Annihilating from if block 1",j,k
                    ToAnnihilateIndex=ToAnnihilateIndex+1
!                    WRITE(6,*) 'adding to annihilate index 01'
!                    CALL FLUSH(6)
!                    IF(HashCurr.eq.HFHash) THEN
!                        WRITE(6,*) "HF Determinant particle annihilated"
!                    ENDIF
                enddo   

!            ELSEIF((TotWalkersDet.lt.0).and.(MinorSpawnSign(k).gt.0)) THEN
            ELSEIF(TotWalkersDet.lt.0) THEN
!Need to run through the determinants, find those with positive walkers, and randomly annihilate these.            
                
                do while (NoPosWalk.gt.0)
!                    WRITE(6,*) 'into this loop'

                    ! call a random number between 1 and 0.
                    IF(tMerTwist) THEN
                        r = genrand_real2_dSFMT() 
                    ELSE
                        CALL RANLUX(r,1)
                    ENDIF

                    ! multiply this by the number we need to annihilate, and the round up to the nearest integer.
                    ! this integer indicates the walker we need to annihilate.
                    WalkertoAnnihil=CEILING(r*NoPosWalk)
                    SumOppSign=0
                    do k=InitialBlockIndex,FinalBlockIndex

                        IF(MinorSpawnSign(k).gt.0) SumOppSign=SumOppSign+ABS(MinorSpawnSign(k))
                        IF(SumOppSign.ge.WalkertoAnnihil) THEN
                            MinorSpawnSign(k)=MinorSpawnSign(k)-1
                            NoPosWalk=NoPosWalk-1
                            IndexTable(ToAnnihilateIndex)=Index2Table(k)
                            ProcessVec(ToAnnihilateIndex)=Process2Vec(k)
!                    Hash2Array(ToAnnihilateIndex)=HashArray(k)     !This is not strictly needed - remove after checking
!                    NewSign(ToAnnihilateIndex)=CurrentSign(k)       !This is also need needed, but useful for checking
!                    IF(Iter.eq.DebugIter) WRITE(6,*) "Annihilating from if block 2",j,k
                            ToAnnihilateIndex=ToAnnihilateIndex+1

!                            WRITE(6,*) 'adding to annihilate index 02'
!                            CALL FLUSH(6)

                            EXIT
                        ENDIF
                    enddo
                enddo

            ELSEIF(TotWalkersDet.gt.0) THEN
!Annihilate if block has a net positive walker count, and current walker is negative
                do while (NoNegWalk.gt.0)

                    ! call a random number between 1 and 0.
                    IF(tMerTwist) THEN
                        r = genrand_real2_dSFMT() 
                    ELSE
                        CALL RANLUX(r,1)
                    ENDIF

                    ! multiply this by the number we need to annihilate, and the round up to the nearest integer.
                    ! this integer indicates the walker we need to annihilate.
                    WalkertoAnnihil=CEILING(r*NoNegWalk)
                    SumOppSign=0
                    do k=InitialBlockIndex,FinalBlockIndex

                        IF(MinorSpawnSign(k).lt.0) SumOppSign=SumOppSign+ABS(MinorSpawnSign(k))
                        IF(SumOppSign.ge.WalkertoAnnihil) THEN
                            MinorSpawnSign(k)=MinorSpawnSign(k)+1
                            NoNegWalk=NoNegWalk-1
                            IndexTable(ToAnnihilateIndex)=Index2Table(k)
                            ProcessVec(ToAnnihilateIndex)=Process2Vec(k)
!                    Hash2Array(ToAnnihilateIndex)=HashArray(k)     !This is not strictly needed - remove after checking
!                    NewSign(ToAnnihilateIndex)=CurrentSign(k)       !This is also need needed, but useful for checking
!                    IF(Iter.eq.DebugIter) WRITE(6,*) "Annihilating from if block 3",j,k
                            ToAnnihilateIndex=ToAnnihilateIndex+1

!                            WRITE(6,*) 'adding to annihilate index 03'
!                            CALL FLUSH(6)


                            EXIT
                        ENDIF
                    enddo
                enddo
            ENDIF

!            IF((ToAnnihilateIndex).gt.1) THEN
!                WRITE(6,*) '** Toannihilateindex gt 1'
!                WRITE(6,*) 'InitialBlockIndex,',InitialBlockIndex,'FinalBlockIndex',FinalBlockIndex
!
!                WRITE(6,*) 'index,hash,sign'
!                do i=InitialBlockIndex,FinalBlockIndex
!                    WRITE(6,*) i,Hash2Array(i),MinorSpawnSign(i)
!                enddo
!                WRITE(6,*) 'ToAnnihilateIndex',ToAnnihilateIndex
!                do i=1,ToAnnihilateIndex-1
!                    WRITE(6,*) IndexTable(i),ProcessVec(i),Hash2Array(i),MinorSpawnSign(i)
!                enddo
!                CALL Stop_All('','')
!            ENDIF


        enddo


        ToAnnihilateIndex=ToAnnihilateIndex-1   !ToAnnihilateIndex now tells us the total number of particles to annihilate from the list on this processor
!        IF(Iter.eq.DebugIter) THEN
!            WRITE(6,*) "Number of particles to annihilate from hashes on this processor: ",ToAnnihilateIndex
!            CALL FLUSH(6)
!        ENDIF
        MinorAnnihilated=MinorAnnihilated+ToAnnihilateIndex
        Annihilated=Annihilated+ToAnnihilateIndex

!The annihilation is complete - particles to be annihilated are stored in IndexTable and need to be sent back to their original processor
!To know which processor that is, we need to order the particles to be annihilated in terms of their CPU, i.e. ProcessVec(1:ToAnnihilateIndex)
!Is the list already ordered according to CPU? Is this further sort even necessary?

        IF(ToAnnihilateIndex.gt.1) THEN
!Do not actually have to take indextable, hash2array or newsign with it...
            CALL Sort2IILongI(ToAnnihilateIndex,ProcessVec(1:ToAnnihilateIndex),IndexTable(1:ToAnnihilateIndex),HashArray(1:ToAnnihilateIndex),MinorSpawnSign(1:ToAnnihilateIndex))
        ENDIF

!We now need to regenerate sendcounts and disps
        sendcounts(1:nProcessors)=0
        do i=1,ToAnnihilateIndex
            IF(ProcessVec(i).gt.(nProcessors-1)) THEN
                CALL Stop_All("RotoAnnihilateMinor","Annihilation error")
            ENDIF
            sendcounts(ProcessVec(i)+1)=sendcounts(ProcessVec(i)+1)+1
        enddo
!The disps however do want to be cumulative
        disps(1)=0      !Starting element is always the first element
        do i=2,nProcessors
            disps(i)=disps(i-1)+sendcounts(i-1)
        enddo

!We now need to calculate the recvcounts and recvdisps - this is a job for AlltoAll
        recvcounts(1:nProcessors)=0
!Put a barrier here so all processes synchronise
        CALL MPIBarrier(error)

        CALL MPIAlltoAllI(sendcounts,1,recvcounts,1,error)

!We can now get recvdisps from recvcounts in the same way we obtained disps from sendcounts
        recvdisps(1)=0
        do i=2,nProcessors
            recvdisps(i)=recvdisps(i-1)+recvcounts(i-1)
        enddo

        ToAnnihilateonProc=recvdisps(nProcessors)+recvcounts(nProcessors)
        
!        IF(Iter.eq.DebugIter) THEN
!            WRITE(6,*) "FOR RETURN OF ANNIHILATED PARTICLES, SENDCOUNTS: ",sendcounts(:)
!            WRITE(6,*) "DISPS: ",disps(:)
!            WRITE(6,*) "RECVCOUNTS: ",recvcounts(:)
!            WRITE(6,*) "RECVDISPS: ",recvdisps(:)
!            WRITE(6,*) "ToAnnihilateOnProc: ",ToAnnihilateonProc
!            CALL FLUSH(6)
!        ENDIF

        CALL MPIBarrier(error)

!Perform another matrix transpose of the annihilation data using MPI_AlltoAllv, to send the data back to its correct Processor
!The signs of the hashes, index and CPU also need to be taken with them. (CPU does not need to be taken - every element of CPU should be equal to the rank of the processor+1)
!Hash also does not need to be taken, but will be taken as a precaution
        CALL MPIAlltoAllvI(IndexTable(1:ToAnnihilateonProc),sendcounts,disps,Index2Table,recvcounts,recvdisps,error)


!TEST
!        do i=1,ToAnnihilateonProc
!            IF(Process2Vec(i).ne.(iProcIndex)) THEN
!                CALL Stop_All("AnnihilateAmongstMinorSpawned","AlltoAllv performed incorrectly")
!            ENDIF
!        enddo

!Index2Table now is a list, of length "ToAnnihilateonProc", of walkers which should NOT be transferred to the next array. 
!Order the list according to this index (Hash and sign does not need to be sorted, but will for debugging purposes)
        CALL SORTIILongI(ToAnnihilateonProc,Index2Table(1:ToAnnihilateonProc),Hash2Array(1:ToAnnihilateonProc),MinorSpawnSign(1:ToAnnihilateonProc))

!        IF(Iter.eq.DebugIter) THEN
!            WRITE(6,*) "Number of hashes originally on processor which need to be removed=",ToAnnihilateonProc
!            WRITE(6,*) "To annihilate from processor: "
!            do i=1,ToAnnihilateonProc
!                WRITE(6,*) Index2Table(i),HashArray(i),CurrentSign(i)
!            enddo
!        ENDIF

!TEST - do the hashes and signs match the ones that are returned?
!        do i=1,ToAnnihilateonProc
!            IF(TempHash(Index2Table(i)).ne.(HashArray(i))) THEN
!                CALL Stop_All("AnnihilateAmongstMinorSpawned","Incorrect Hash returned")
!            ENDIF
!            IF(TempSign(Index2Table(i))) THEN
!                IF(.not.CurrentSign(i)) THEN
!                    CALL Stop_All("AnnihilateAmongstMinorSpawned","Incorrect Sign returned")
!                ENDIF
!            ELSE
!                IF(CurrentSign(i)) THEN
!                    CALL Stop_All("AnnihilateAmongstMinorSpawned","Incorrect Sign returned")
!                ENDIF
!            ENDIF
!        enddo
        

        IF(ToAnnihilateonProc.ne.0) THEN
!Copy across the data, apart from ones which have an index given by the indicies in Index2Table(1:ToAnnihilateonProc)
            VecSlot=1       !VecSlot is the index in the final array of TotWalkers
            i=1             !i is the index in the original array of TotWalkersNew
            do j=1,ToAnnihilateonProc
!Loop over all particles to be annihilated
!                IF(Iter.eq.DebugIter) WRITE(6,*) Index2Table(j)
                do while(i.lt.Index2Table(j))
!Copy accross all particles less than this number
                    MinorSpawnDets(:,VecSlot)=MinorSpawnDets(:,i)
                    MinorSpawnParent(:,VecSlot)=MinorSpawnParent(:,i)
                    MinorSpawnSign(VecSlot)=TempSign(i)
                    i=i+1
                    VecSlot=VecSlot+1
                enddo
                i=i+1
            enddo

!Now need to copy accross the residual - from Index2Table(ToAnnihilateonProc) to TotWalkersNew
            do i=Index2Table(ToAnnihilateonProc)+1,MinorValidSpawned
                MinorSpawnDets(:,VecSlot)=MinorSpawnDets(:,i)
                MinorSpawnParent(:,VecSlot)=MinorSpawnParent(:,i)
                MinorSpawnSign(VecSlot)=TempSign(i)
                VecSlot=VecSlot+1
            enddo

        ELSE
!No particles annihilated
            VecSlot=1
            do i=1,MinorValidSpawned
                MinorSpawnDets(:,VecSlot)=MinorSpawnDets(:,i)
                MinorSpawnParent(:,VecSlot)=MinorSpawnParent(:,i)
                MinorSpawnSign(VecSlot)=TempSign(i)
                VecSlot=VecSlot+1
            enddo
        ENDIF
                
        MinorValidSpawnedNew=VecSlot-1

!        IF(Iter.eq.DebugIter) THEN
!            WRITE(6,*) "FINAL CONFIGURATION: "
!            do i=1,TotWalkers
!                WRITE(6,*) i,HashArray(i),CurrentSign(i)
!            enddo
!        ENDIF

        IF((MinorValidSpawned-MinorValidSpawnedNew).ne.ToAnnihilateonProc) THEN
            WRITE(6,*) 'MinorValidSpawnedNew,MinorValidSpawned,ToAnnihilateonProc,Iter'
            WRITE(6,*) MinorValidSpawnedNew,MinorValidSpawned,ToAnnihilateonProc,Iter
            CALL FLUSH(6)
            CALL Stop_All("AnnihilateAmongstMinorSpawned","Problem with numbers when annihilating")
        ENDIF

        MinorValidSpawned=MinorValidSpawnedNew

        ! Don't need these after this, so rather than copying them back in the right order, re-zero to be ready for the 
        ! next set of spawned walkers on the minor determinants.
        HashArray(:)=0
        Hash2Array(:)=0


        DEALLOCATE(TempSign)
        DEALLOCATE(TempMinorSpawnSign)
        


    END SUBROUTINE AnnihilateAmongstMinorSpawned



    SUBROUTINE RotateMinorParticles(MinorValidSpawned)
        INTEGER :: i,MinorValidSpawned,error
#ifdef PARALLEL
        INTEGER :: Stat(MPI_STATUS_SIZE)

! This is the number of particles spawned (and still alive).  Must be sent with the arrays so the next processor knows the size.        
        MinorSpawnSign(0)=MinorValidSpawned

!Send the signs of the particles (number sent is in the first element)
        CALL MPI_BSend(MinorSpawnSign(0:MinorValidSpawned),MinorValidSpawned+1,MPI_INTEGER,MOD(iProcIndex+1,nProcessors),123,MPI_COMM_WORLD,error)
        IF(error.ne.MPI_SUCCESS) THEN
            CALL Stop_All("RotateParticles","Error in sending signs")
        ENDIF

!...then send the particles themselves...
        CALL MPI_BSend(MinorSpawnDets(0:NIfTot,1:MinorValidSpawned),MinorValidSpawned*(NIfTot+1),MPI_INTEGER,MOD(iProcIndex+1,nProcessors),456,MPI_COMM_WORLD,error)
        IF(error.ne.MPI_SUCCESS) THEN
            CALL Stop_All("RotateParticles","Error in sending particles")
        ENDIF


!...and then send the parents of the walkers...
        CALL MPI_BSend(MinorSpawnParent(0:NIfTot,1:MinorValidSpawned),MinorValidSpawned*(NIfTot+1),MPI_INTEGER,MOD(iProcIndex+1,nProcessors),789,MPI_COMM_WORLD,error)
        IF(error.ne.MPI_SUCCESS) THEN
            CALL Stop_All("RotateParticles","Error in sending particle parents")
        ENDIF

        CALL MPIBarrier(error)

!Receive signs (let it receive the maximum possible (only the first ValidSpawned will be updated.))
        CALL MPI_Recv(MinorSpawnSign2(0:MaxSpawned),MaxSpawned+1,MPI_INTEGER,MOD(iProcIndex+nProcessors-1,nProcessors),123,MPI_COMM_WORLD,Stat,error)
        IF(error.ne.MPI_SUCCESS) THEN
            CALL Stop_All("RotateParticles","Error in receiving signs")
        ENDIF

!Update the ValidSpawned variable for this new set of data we are about to receive...
        MinorValidSpawned=MinorSpawnSign2(0)

        CALL MPI_Recv(MinorSpawnDets2(0:NIfTot,1:MinorValidSpawned),MinorValidSpawned*(NIfTot+1),MPI_INTEGER,MOD(iProcIndex+nProcessors-1,nProcessors),456,MPI_COMM_WORLD,Stat,error)
        IF(error.ne.MPI_SUCCESS) THEN
            CALL Stop_All("RotateParticles","Error in receiving particles")
        ENDIF

        CALL MPI_Recv(MinorSpawnParent2(0:NIfTot,1:MinorValidSpawned),MinorValidSpawned*(NIfTot+1),MPI_INTEGER,MOD(iProcIndex+nProcessors-1,nProcessors),789,MPI_COMM_WORLD,Stat,error)
        IF(error.ne.MPI_SUCCESS) THEN
            CALL Stop_All("RotateParticles","Error in receiving particle parents")
        ENDIF

        do i=1,MinorValidSpawned
            MinorSpawnDets(0:NIfTot,i)=MinorSpawnDets2(0:NIfTot,i)
            MinorSpawnParent(0:NIfTot,i)=MinorSpawnParent2(0:NIfTot,i)
            MinorSpawnSign(i)=MinorSpawnSign2(i)
        enddo

!Really need to fix this so that I'm using pointers at some stage...

!We now want to make sure that we are working on the correct array. We have now received particles in SpawnedParts2 - switch it so that we are pointing at the other array.
!We always want to annihilate from the SpawedParts and SpawnedSign arrays.
!        IF(associated(SpawnedParts2,target=SpawnVec2)) THEN
!            SpawnedParts2 => SpawnVec
!            SpawnedSign2 => SpawnSignVec
!            SpawnedParts => SpawnVec2
!            SpawnedSign => SpawnSignVec2
!        ELSE
!            SpawnedParts => SpawnVec
!            SpawnedSign => SpawnSignVec
!            SpawnedParts2 => SpawnVec2
!            SpawnedSign2 => SpawnSignVec2
!        ENDIF

#endif

    END SUBROUTINE RotateMinorParticles



    SUBROUTINE AnnihilateMinorSpawnedParts(MinorValidSpawned,NoMinorWalkersNew)
        INTEGER :: i,j,k,MinorValidSpawned,NoMinorWalkersNew,MinInd,MaxDetInd,MinDetInd,SumDetPop,SumMinorDetPop
        INTEGER :: ToRemove,DetsMerged,SignProd,PartInd,EqDetPopsTag,ierr,FinalMinorDet
        LOGICAL :: DetsEq,tSuccess,tAnnihilateOne
        REAL*8 :: r,Prob
        INTEGER , ALLOCATABLE :: EqDetPops(:)

        MinInd=1
        ! This is the minimum index to start the search.  We are running through MinorSpawnDets (which is ordered), to find the matching det in 
        ! MinorStarDets (which is also ordered).  So if we find one det at a particular position, we only need to search MinorStarDets at positions
        ! lower than this.  But we start at 1.
        
        ToRemove=0 
        ! This is the number of particles to annihilate.

! Run through the newly spawned walkers
!        WRITE(6,*) 'MinorSpawedDets'
!        do j=1,MinorValidSpawned
!            WRITE(6,*) MinorSpawnDets(:,j),MinorSpawnSign(j)
!        enddo

        i=1
        do while (i.le.MinorValidSpawned)
            DetsEq=.false.
            SumMinorDetPop=MinorSpawnSign(i)
            j=1
            IF((i+j).le.MinorValidSpawned) DetsEq=DetBitEQ(MinorSpawnDets(0:NIfTot,i),MinorSpawnDets(0:NIfTot,i+j),NIfDBO)
            do while (DetsEq)
                SumMinorDetPop=SumMinorDetPop+MinorSpawnSign(i+j)
                j=j+1
                IF((i+j).gt.MinorValidSpawned) EXIT
                DetsEq=DetBitEQ(MinorSpawnDets(0:NIfTot,i),MinorSpawnDets(0:NIfTot,i+j),NIfDBO)
            enddo
            FinalMinorDet=i+j-1
            IF(FinalMinorDet.gt.MinorValidSpawned) FinalMinorDet=MinorValidSpawned
            ! The current spawned determinants therefore run from i to FinalMinorDet.
            ! These have an overall population of SumMinorDetPop.

!            IF((FinalMinorDet-i).gt.0) THEN
!                WRITE(6,*) 'MinorValidSpawned',MinorValidSpawned
!                WRITE(6,*) 'Starting Determinant',MinorSpawnDets(:,i)
!                WRITE(6,*) 'Determinant',MinorSpawnDets(:,FinalMinorDet)
!                WRITE(6,*) 'i',i
!                WRITE(6,*) 'FinalMinorDet',FinalMinorDet
!                WRITE(6,*) 'SumMinorDetPop',SumMinorDetPop
!                CALL FLUSH(6)
!            ENDIF

! Search for the determinant in the MinorStarDets list.
! tSuccess is true if the particle is found.
! This routine takes the MinorSpawnDets given and searches through MinorStarDets between MinInd and TotWalkersNew to find a match.  The index of this match is
! PartInd.
! In this case we need to check the determinants before and after the one found, to see if these are also equal.
            CALL BinSearchMinorParts(MinorSpawnDets(:,i),MinInd,NoMinorWalkersNew,PartInd,tSuccess)

            IF(tSuccess) THEN
!                WRITE(6,*) 'tSuccess'
                CALL FLUSH(6)
                ! Need to run forwards and backwards in the list of MinorStarDets, finding all the determinants that are equal, summing the particles on this determinant
                ! to find out how many need to be annihilated.  All the equal determinants in MinorStarDets should be the same sign, otherwise they will have annihilated already.

                ! Find out how many walkers are already on this determinant.
                SumDetPop=MinorStarSign(PartInd)
                DetsEq=.false.
                MinDetInd=PartInd
                MaxDetInd=PartInd

                ! First check one below the determinant found.
                j=1
                DetsEq=DetBitEQ(MinorSpawnDets(0:NIfTot,i),MinorStarDets(0:NIfTot,PartInd-j),NIfDBO)
                do while (DetsEq)
                    ! If the determinant is still equal, add the walkers on it to SumDetPop, and this index becomes the minimum.
                    SumDetPop=SumDetPop+MinorStarSign(PartInd-j)
                    MinDetInd=PartInd-j
                    j=j+1
                    DetsEq=DetBitEQ(MinorSpawnDets(0:NIfTot,i),MinorStarDets(0:NIfTot,PartInd-j),NIfDBO)
                    ! If this is true, the walkers on the next determinant will be added.
                enddo

                ! Now check those above the determinant found.
                j=1
                DetsEq=DetBitEQ(MinorSpawnDets(0:NIfTot,i),MinorStarDets(0:NIfTot,PartInd+j),NIfDBO)
                do while (DetsEq)
                    ! If the determinant is still equal, add the walkers on it to SumDetPop, and this index becomes the minimum.
                    SumDetPop=SumDetPop+MinorStarSign(PartInd+j)
                    MaxDetInd=PartInd+j
                    j=j+1
                    DetsEq=DetBitEQ(MinorSpawnDets(0:NIfTot,i),MinorStarDets(0:NIfTot,PartInd+j),NIfDBO)
                    ! If this is true, the walkers on the next determinant will be added.
                enddo
                ! SumDetPop now gives the number of walkers (with sign) currently on this determinant, and the Min and Max index of where these lie in MinorStarDets.  

!                SignProd=SumDetPop*MinorSpawnSign(i)
                SignProd=SumDetPop*SumMinorDetPop

!                IF((FinalMinorDet-i).gt.0) THEN
!                    WRITE(6,*) '*** Star stuff'
!                    WRITE(6,*) 'MinDetInd',MinDetInd
!                    WRITE(6,*) 'MaxDetInd',MaxDetInd
!                    WRITE(6,*) 'Determinant',MinorStarDets(:,MinDetInd)
!                    WRITE(6,*) 'SumDetPop',SumDetPop
!                ENDIF
                
                IF(SignProd.lt.0) THEN
                ! This suggests the spawned particles are of opposite sign to those currently on the determinant, and so must undergo annihilation.

                    IF((ABS(SumMinorDetPop)).ge.(ABS(SumDetPop))) THEN

!                        WRITE(6,*) 'In this bit 01'
!                        CALL FLUSH(6)

                        ! i.e. more (or equal) spawned than currently there, all walkers currently on that determinant are annihilated (regardless of parent), and the number
                        ! spawned is accordingly reduced.

                        ! Need to figure out which of the MinorSpawnSigns to annihilate.
!                        MinorSpawnSign(i)=MinorSpawnSign(i)+SumDetPop !!!!!!!!!!!
                        MinorAnnihilated=MinorAnnihilated+2*(ABS(SumDetPop))
                        Annihilated=Annihilated+2*(ABS(SumDetPop))

                        ALLOCATE(EqDetPops(i:FinalMinorDet),stat=ierr)
                        CALL LogMemAlloc('EqDetPops',FinalMinorDet-i+1,4,'AnnihilateMinorSpawnedParts',EqDetPopsTag,ierr)
                        IF(ierr.ne.0) CALL Stop_All('AnnihilateMinorSpawnedParts','Error allocating memory for EqDetPops')

                        do j=i,FinalMinorDet
                            EqDetPops(j)=ABS(MinorSpawnSign(j))
                        enddo

                        ! run through each walker on MinorSpawnSign, annihilating those in MinorStarSign one by one randomly.
                        ! the probability is the population in a particular entry of MinorStarSign / the total population from MinorStarSign on that determinant.
                        ! for each walker that annihilates, a random number is called, and based on these probabilities (which are calculated from the initial
                        ! populations before this annihilation i.e. the probabilities do not change as a walker is annihilated) a walker is annihilated from on of the entries.
!                        do j=1,ABS(SumDetPop)
                        j=1
                        do while (j.le.ABS(SumDetPop))
!                            WRITE(6,*) 'in this loop'
!                            CALL FLUSH(6)

                            ! call a random number
                            IF(tMerTwist) THEN
                                r = genrand_real2_dSFMT() 
                            ELSE
                                CALL RANLUX(r,1)
                            ENDIF

                            tAnnihilateOne=.false.
                            
                            do while(.not.tAnnihilateOne)
                                ! tAnnihilateOne becomes true when a particle is annihilated, otherwise need to run through the probabilities again with a different random number.
!                                WRITE(6,*) 'in this loop 02'
!                                CALL FLUSH(6)
                                
                                Prob=0.D0
                                
                                do k=i,FinalMinorDet
!                                    WRITE(6,*) 'in this loop 03'
!                                    CALL FLUSH(6)
!                                    WRITE(6,*) 'i',i
!                                    WRITE(6,*)'FinalMinorDet',FinalMinorDet
!                                    WRITE(6,*) 'EqDetPops',EqDetPops(k)
!                                    WRITE(6,*) 'MinorSpawnSign',MinorSpawnSign(k)
!                                    WRITE(6,*) 'SumMinorDetPop',SumMinorDetPop

                                    Prob=Prob+ABS(REAL(EqDetPops(k),dp)/REAL(SumMinorDetPop,dp))
!                                    WRITE(6,*) 'Prob',Prob
!                                    WRITE(6,*) 'r',r

                                    IF(r.le.Prob) THEN
                                        IF(MinorSpawnSign(k).gt.0) THEN
                                            MinorSpawnSign(k)=MinorSpawnSign(k)-1
                                            tAnnihilateOne=.true.
                                        ELSEIF(MinorSpawnSign(k).lt.0) THEN
                                            MinorSpawnSign(k)=MinorSpawnSign(k)+1
                                            tAnnihilateOne=.true.
                                        ELSEIF(MinorSpawnSign(k).eq.0) THEN
                                            IF(tMerTwist) THEN
                                                r = genrand_real2_dSFMT() 
                                            ELSE
                                                CALL RANLUX(r,1)
                                            ENDIF
                                            tAnnihilateOne=.false.
                                        ENDIF 
                                        EXIT
                                    ENDIF
                                enddo
                            enddo
                            j=j+1
                        enddo
                        DEALLOCATE(EqDetPops)
                        CALL LogMemDealloc('AnnihilateMinorSpawnedParts',EqDetPopsTag)

!                        WRITE(6,*) 'this o.k'
!                        CALL FLUSH(6)
 
                        do j=MinDetInd,MaxDetInd
                            MinorStarSign(j)=0
                        enddo

!                        WRITE(6,*) 'this o.k too'
!                        CALL FLUSH(6)
 
                        do j=i,FinalMinorDet
                            IF(MinorSpawnSign(j).eq.0) ToRemove=ToRemove+1
                            ! All particles have annihilated each other, there is none left in the spawned array so this determinant can be removed.
                        enddo
                        ! remaining walkers in MinorSpawnSign are not transferred across to MinorStarSign yet, as they need to be rotated, to test for other possible annihilations.

!                        WRITE(6,*) 'this o.k three'
!                        CALL FLUSH(6)

                    ELSE

!                        WRITE(6,*) 'In this bit 02'
!                        CALL FLUSH(6)


                        ! if there are less spawned than are currently on this determinant, the spawned annihilate some but not all.  need to randomly choose which to annihilate.
                        Annihilated=Annihilated+2*(ABS(SumMinorDetPop))
                        MinorAnnihilated=MinorAnnihilated+2*(ABS(SumMinorDetPop))

                        ALLOCATE(EqDetPops(MinDetInd:MaxDetInd),stat=ierr)
                        CALL LogMemAlloc('EqDetPops',MaxDetInd-MinDetInd+1,4,'AnnihilateMinorSpawnedParts',EqDetPopsTag,ierr)
                        IF(ierr.ne.0) CALL Stop_All('AnnihilateMinorSpawnedParts','Error allocating memory for EqDetPops')

                        do j=MinDetInd,MaxDetInd
                            EqDetPops(j)=ABS(MinorStarSign(j))
                        enddo

                        ! run through each walker on MinorSpawnSign, annihilating those in MinorStarSign one by one randomly.
                        ! the probability is the population in a particular entry of MinorStarSign / the total population from MinorStarSign on that determinant.
                        ! for each walker that annihilates, a random number is called, and based on these probabilities (which are calculated from the initial
                        ! populations before this annihilation i.e. the probabilities do not change as a walker is annihilated) a walker is annihilated from on of the entries.
                        j=1
!                        do j=1,ABS(SumMinorDetPop)
                        do while (j.le.ABS(SumMinorDetPop))

                            ! call a random number
                            IF(tMerTwist) THEN
                                r = genrand_real2_dSFMT() 
                            ELSE
                                CALL RANLUX(r,1)
                            ENDIF

                            tAnnihilateOne=.false.
                            
                            do while(.not.tAnnihilateOne)
                                ! tAnnihilateOne becomes true when a particle is annihilated, otherwise need to run through the probabilities again with a different random number.
                                
                                Prob=0.D0
                                
                                do k=MinDetInd,MaxDetInd
                                    Prob=Prob+REAL(EqDetPops(k),dp)/ABS(REAL(SumDetPop,dp))
                                    IF(r.le.Prob) THEN
                                        IF(MinorStarSign(k).gt.0) THEN
                                            MinorStarSign(k)=MinorStarSign(k)-1
                                            tAnnihilateOne=.true.
                                        ELSEIF(MinorStarSign(k).lt.0) THEN
                                            MinorStarSign(k)=MinorStarSign(k)+1
                                            tAnnihilateOne=.true.
                                        ELSEIF(MinorStarSign(k).eq.0) THEN
                                            IF(tMerTwist) THEN
                                                r = genrand_real2_dSFMT() 
                                            ELSE
                                                CALL RANLUX(r,1)
                                            ENDIF
                                            tAnnihilateOne=.false.
                                        ENDIF 
                                        EXIT
                                    ENDIF
                                enddo
                            enddo
                            j=j+1
                        enddo
                        DEALLOCATE(EqDetPops)
                        CALL LogMemDealloc('AnnihilateMinorSpawnedParts',EqDetPopsTag)
 
                        do j=i,FinalMinorDet
                            MinorSpawnSign(j)=0
                            ToRemove=ToRemove+1
                        enddo
                        
                    ENDIF

                ELSEIF(SignProd.gt.0) THEN
                    ! This means that the particle has found other particles on the same determinant with the same sign, therefore it cannot annihilate (as all other 
                    ! walkers on the same sign must be sign-coherent).  Therefore it can be just transferred across now.

                    ! These walkers however, must be added to MinorStarSign walkers with the same parent as these spawned ones.
                    ! I.e run over all the parents of all entries in MinorStarSign with the same determinants, until one is found that is the same as the parent of the spawned.


!                    WRITE(6,*) 'In this bit 03'
!                    CALL FLUSH(6)


                    DetsEq=.false.
                    do j=MinDetInd,MaxDetInd
                        DetsEq=DetBitEQ(MinorSpawnParent(0:NIfTot,i),MinorStarParent(0:NIfTot,j),NIfDBO)
                        IF(DetsEq) THEN
                            MinorStarSign(j)=MinorStarSign(j)+MinorSpawnSign(i)
                            MinorSpawnSign(i)=0
                            ToRemove=ToRemove+1
                            EXIT
                        ENDIF
                    enddo
!                    IF(.not.DetsEq) THEN
                        ! This just means the determinant has been spawned on from a different parent.
                        ! Leave this in the spawned list - it will be quicker to just merge them all at once, rather than merging now.
!                        WRITE(6,*) 'determinant then parent of star then spawn'
!                        WRITE(6,*) MinorStarDets(0:NIfTot,i),'*',MinorStarParent(0:NIfTot,i)
!                        do j=MinDetInd,MaxDetInd
!                            WRITE(6,*) MinorSpawnDets(0:NIfTot,j),'*',MinorSpawnParent(0:NIfTot,j)
!                        enddo
!                        CALL FLUSH(6)
!                        CALL Stop_All('AnnihilateMinorSpawnedParts','Error adding sign coherent spawned particles to the list of current determinants.')
!                    ENDIF
                ELSEIF(SignProd.eq.0) THEN

                    IF(MinorSpawnSign(i).eq.0) ToRemove=ToRemove+1
                ENDIF
                ! This ENDIF means we have dealt with all the cases where the spawned determinant is found in the MinorStarDets list and the signs are the same/different etc.
                
            ENDIF
            ! If the spawned determinant isn't in the MinorStarDets list there isn't anything else to do.

            MinInd=MaxDetInd
            i=FinalMinorDet+1
        enddo
        ! Do this for all spawned on determinants.

!        WRITE(6,*) 'here o.k'
!        CALL FLUSH(6)

! Now remove all the annihilated particles from the spawned list.  I.e. those which now have 0 particles on that determinant, do not need to be in the list.
        IF(ToRemove.gt.0) THEN
            DetsMerged=0
            do i=1,MinorValidSpawned
                IF(MinorSpawnSign(i).eq.0) THEN
                    DetsMerged=DetsMerged+1
                ELSE
                    MinorSpawnDets2(0:NIfTot,i-DetsMerged)=MinorSpawnDets(0:NIfTot,i)
                    MinorSpawnSign2(i-DetsMerged)=MinorSpawnSign(i)
                    MinorSpawnParent2(0:NIfTot,i-DetsMerged)=MinorSpawnParent(0:NIfTot,i)
                ENDIF
            enddo
            MinorValidSpawned=MinorValidSpawned-DetsMerged
            IF(DetsMerged.ne.ToRemove) THEN
                WRITE(6,*) "*** Iteration number", Iter
                WRITE(6,*) 'DetsMerged,',DetsMerged,'ToRemove,',ToRemove
                CALL Stop_All("AnnihilateMinorSpawnedParts","Incorrect number of particles removed from minor spawned list")
            ENDIF

            ! My version of changing the pointers over, need to fix this.
            do i=1,MinorValidSpawned
                MinorSpawnDets(0:NIfTot,i)=MinorSpawnDets2(0:NIfTot,i)
                MinorSpawnParent(0:NIfTot,i)=MinorSpawnParent2(0:NIfTot,i)
                MinorSpawnSign(i)=MinorSpawnSign2(i)
            enddo
        ENDIF

!        WRITE(6,*) 'here o.k too'
!        CALL FLUSH(6)


    END SUBROUTINE AnnihilateMinorSpawnedParts


!This routine will run through the total list of minor particles (NoMinorWalkersNew in MinorStarDets with sign MinorStarSign) and the list of newly-spawned but
!surviving particles (MinorValidSpawned in MinorSpawnDets and MinorSpawnSign) and move the new particles into the correct place in the new list,
!while removing the particles with sign = 0 from MinorStarDets. 
!Binary searching can be used to speed up this transfer substantially.
!This needs to be modified slightly compared to InsertRemoveParts, as in this case, it is possible for the same determinant to be specified in both the
!spawned and main list, but these will have different parents, and thus must be kept separate.
    SUBROUTINE InsertRemoveMinorParts(MinorValidSpawned,NoMinorWalkersNew)
        INTEGER :: NoMinorWalkersNew,MinorValidSpawned
        INTEGER :: i,DetsMerged

        
! Remove determinants from the main array which have 0 population.        
        TotParts=0
        DetsMerged=0
        do i=1,NoMinorWalkersNew
            IF(MinorStarSign(i).eq.0) THEN
                DetsMerged=DetsMerged+1
            ELSE
! We want to move all the elements above this point down to 'fill in' the annihilated determinant.
                IF(DetsMerged.ne.0) THEN
                    MinorStarDets(0:NIfTot,i-DetsMerged)=MinorStarDets(0:NIfTot,i)
                    MinorStarSign(i-DetsMerged)=MinorStarSign(i)
                    MinorStarParent(0:NIfTot,i-DetsMerged)=MinorStarParent(0:NIfTot,i)
                    MinorStarHii(i-DetsMerged)=MinorStarHii(i)
                    MinorStarHij(i-DetsMerged)=MinorStarHij(i)
                ENDIF
                TotParts=TotParts+abs(MinorStarSign(i))
            ENDIF
        enddo
        NoMinorWalkersNew=NoMinorWalkersNew-DetsMerged
        ! So this is the number of determinants specified in the main list before those spawned and survived have been added.

!We now need to compress the spawned list, so that no particles are specified more than once.
!We also want to find the number of particles we are adding to the list from the spawned list.
!We now calculate the contribution to the total number of particles from the spawned lists.
!The list has previously been compressed before the annihilation began.
        IF(MinorValidSpawned.gt.0) THEN
            TotParts=TotParts+abs(MinorSpawnSign(1))
        ENDIF
        do i=2,MinorValidSpawned
            TotParts=TotParts+abs(MinorSpawnSign(i))
        enddo

!We now want to merge the main list with the spawned list of surviving spawned particles.
!The final list will be of length NoMinorWalkers+MinorValidSpawned. This will be returned in the first element of MergeLists updated.
        
        IF(TotParts.gt.0) THEN

            CALL MergeListswH2(NoMinorWalkersNew,MaxWalkersPart,MinorValidSpawned,MinorSpawnDets(0:NIfTot,1:MinorValidSpawned),&
            &MinorSpawnParent(0:NIfTot,1:MinorValidSpawned),MinorSpawnSign(1:MinorValidSpawned))
            
        ENDIF

        NoMinorWalkers=NoMinorWalkersNew    


    END SUBROUTINE InsertRemoveMinorParts

!Do a binary search in MinorStarDets, between the indices of MinInd and MaxInd. If successful, tSuccess will be true and 
!PartInd will be a coincident determinant. If there are multiple values, the chosen one may be any of them...
!If failure, then the index will be one less than the index that the particle would be in if it was present in the list.
!(or close enough!)
    SUBROUTINE BinSearchMinorParts(iLut,MinInd,MaxInd,PartInd,tSuccess)
        INTEGER :: iLut(0:NIfTot),MinInd,MaxInd,PartInd
        INTEGER :: i,j,N,Comp
        LOGICAL :: tSuccess

!        WRITE(6,*) "Binary searching between ",MinInd, " and ",MaxInd
!        CALL FLUSH(6)
        i=MinInd
        j=MaxInd
        do while(j-i.gt.0)  !End when the upper and lower bound are the same.
            N=(i+j)/2       !Find the midpoint of the two indices
!            WRITE(6,*) i,j,n

!Comp is 1 if CyrrebtDets(N) is "less" than iLut, and -1 if it is more or 0 if they are the same
            Comp=DetBitLT(MinorStarDets(:,N),iLut(:),NIfDBO)

            IF(Comp.eq.0) THEN
!Praise the lord, we've found it!
                tSuccess=.true.
                PartInd=N
                RETURN
            ELSEIF((Comp.eq.1).and.(i.ne.N)) THEN
!The value of the determinant at N is LESS than the determinant we're looking for. Therefore, move the lower bound of the search up to N.
!However, if the lower bound is already equal to N then the two bounds are consecutive and we have failed...
                i=N
            ELSEIF(i.eq.N) THEN


                IF(i.eq.MaxInd-1) THEN
!This deals with the case where we are interested in the final/first entry in the list. Check the final entry of the list and leave
!We need to check the last index.
                    Comp=DetBitLT(MinorStarDets(:,i+1),iLut(:),NIfDBO)
                    IF(Comp.eq.0) THEN
                        tSuccess=.true.
                        PartInd=i+1
                        RETURN
                    ELSEIF(Comp.eq.1) THEN
!final entry is less than the one we want.
                        tSuccess=.false.
                        PartInd=i+1
                        RETURN
                    ELSE
                        tSuccess=.false.
                        PartInd=i
                        RETURN
                    ENDIF

                ELSEIF(i.eq.MinInd) THEN
                    tSuccess=.false.
                    PartInd=i
                    RETURN

                ELSE
                    i=j
                ENDIF


            ELSEIF(Comp.eq.-1) THEN
!The value of the determinant at N is MORE than the determinant we're looking for. Move the upper bound of the search down to N.
                j=N
            ELSE
!We have failed - exit loop
                i=j
            ENDIF

        enddo

!If we have failed, then we want to find the index that is one less than where the particle would have been.
        tSuccess=.false.
        PartInd=MAX(MinInd,i-1)

    END SUBROUTINE BinSearchMinorParts

! This is pretty much the same as MergeListswH, however in this case, as well as sorting the determinants
! and signs, the Hii and Hij and parents are taken with the determinants too.
   SUBROUTINE MergeListswH2(nlist1,nlist1max,nlist2,list2,list3,SignList2)
        USE FciMCParMOD , only : iLutHF,Hii,MinorStarDets,MinorStarSign,MinorStarParent,MinorStarHii,MinorStarHij
        USE SystemData , only : NEl,Alat,Brr,ECore,G1,nBasis,nBasisMax,nMsh,tHPHF,NIfTot
        USE Determinants , only : get_helement
        USE IntegralsData , only : fck,NMax,UMat
        USE HElem
        use DetBitOps, only: DecodeBitDet
        use hphf_integrals, only: hphf_diag_helement, hphf_off_diag_helement
        IMPLICIT NONE
        INTEGER :: list2(0:NIfTot,1:nlist2),list3(0:NIfTot,1:nlist2)
        INTEGER :: nlisto,nlist1,nlist2,nlo,i,DetCurr(0:NIfTot),DetCurr2(0:NIfTot) 
        INTEGER :: ips,ips1,SignList2(nlist2)
        TYPE(HElement) :: HDiagTemp,HOffDiagTemp
        REAL*8 :: HDiag,HOffDiag
        INTEGER :: nJ(NEl),j,nlist1max,ExcitLevel,nK(NEl)
        LOGICAL :: Det2BitEQ
!.................................................................
!..starting from the end of the list, expand list1 to accomodate
!.. elements of list2
        IF(nlist1.gt.0) THEN
           nlisto=nlist1
           nlo=nlist1
           do i=nlist2,1,-1
!.. find the positions in list1 which the list2 would be inserted
               DetCurr(0:NIfTot)=list2(0:NIfTot,i)
               DetCurr2(0:NIfTot)=list3(0:NIfTot,i)
               call searchminor(nlisto,DetCurr,DetCurr2,ips1)
!              write(6,*) 'position in list1 to be inserted:',ips1
!..ips1 is the position in list1 which num is to be inserted
               ips=ips1      
!           write(6,*) ' Going to insert into position:',ips
!           write(6,*) ' Copy elements from:',ips,' to',nlisto
!..if ips is less than nlisto, then no elements will be copied.
               do j=nlisto,ips,-1
                  if(j.le.nlo) then 
!                 write(6,*) j,'->',j+i
                     MinorStarDets(0:NIfTot,j+i)=MinorStarDets(0:NIfTot,j)
                     MinorStarParent(0:NIfTot,j+i)=MinorStarParent(0:NIfTot,j)
                     MinorStarSign(j+i)=MinorStarSign(j)
                     MinorStarHii(j+i)=MinorStarHii(j)
                     MinorStarHij(j+i)=MinorStarHij(j+1)
                  endif
               enddo
!.elements of list1 which were copied over started
!.. from nlisto and went up to ips
               nlo=ips
!           write(6,*) ' position labels of newly enlarged list:'
!           write(6,'(20i15)') (j,j=1,nlist1+nlist2)
!           write(6,*) 'new enlarged list on step:',i
!           do j=1,nlist1+nlist2
!               write(6,'(20i15)') j,list1(:,j)
!           enddo
!           write(6,'(20i15)') (list1(:,j),j=1,nlist1+nlist2)
               MinorStarDets(0:NIfTot,ips+i-1)=list2(0:NIfTot,i)
               MinorStarSign(ips+i-1)=SignList2(i)
               MinorStarParent(0:NIfTot,ips+i-1)=list3(0:NIfTot,i)

! Want to calculate the diagonal and off diagonal H elements of the particle to be merged.           
               CALL DecodeBitDet(nJ,list2(:,i))
               if (tHPHF) then
                   HDiagTemp = hphf_diag_helement (nJ, list2(:,i))
               else
                   HDiagTemp = get_helement (nJ, nJ, 0)
               endif
               HDiag=(REAL(HDiagTemp%v,8))-Hii
               MinorStarHii(ips+i-1)=HDiag

               CALL DecodeBitDet(nK,list3(:,i))
               if (tHPHF) then
                   HOffDiagTemp = hphf_off_diag_helement (nJ, nK, list2(:,i),&
                                                          list3(:,i))
               else
                   HOffDiagTemp = get_helement(nJ, nK, list2(:,i), list3(:,i))
               endif
               HOffDiag=(REAL(HOffDiagTemp%v,8))
               MinorStarHij(ips+i-1)=HOffDiag


               nlisto=min(nlisto,ips-1)
!           write(6,*) ' new end of list position:',nlisto
            enddo
            nlist1=nlist1+nlist2
            return
        ELSE
! If there are no entries in the star arrays to merge with, just copy the spawned walkers straight over to star array            
            do j=1,nlist2
                MinorStarDets(:,j)=list2(:,j)
                MinorStarSign(j)=SignList2(j)
                MinorStarParent(:,j)=list3(:,j)

                CALL DecodeBitDet(nJ,list2(:,j))
                if (tHPHF) then
                    HDiagTemp = hphf_diag_helement (nJ, list2(:,j))
                else
                    HDiagTemp = get_helement (nJ, nJ, 0)
                endif
                HDiag=(REAL(HDiagTemp%v,8))-Hii
                MinorStarHii(j)=HDiag

                CALL DecodeBitDet(nK,list3(:,j))
                if (tHPHF) then
                    HOffDiagTemp = hphf_off_diag_helement (nJ, nJ,list2(:,j),&
                                                           list3(:,j))
                else
                    HOffDiagTemp = get_helement(nJ, nK, list2(:,j),list3(:,j))
                endif
                HOffDiag=(REAL(HOffDiagTemp%v,8))
                MinorStarHij(j)=HOffDiag
            enddo
            nlist1=nlist2
            return
        ENDIF


    END SUBROUTINE MergeListswH2

!..............................................................................
!..find the position in list such that 
!.. list(0:NIfTot,ipos-1) le DetCurr(0:NIfTot)
!.. list(0:NIfTot,ipos) ge DetCurr(0:NIfTot)
!.. AND
!.. list2(0:NIfTot,ipos-1) < DetCurr2(0:NIfTot)
!.. list2(0:NIfTot,ipos) ge DetCurr2(0:NIfTot)
!..list is assumed to be in increasing order
!..i.e inserting an entry in two lists in the correct position relative to both lists.
    SUBROUTINE searchminor(n,DetCurr,DetCurr2,ipos)
        use SystemData, only: NIfTot,NIfDBO
        use DetBitOps, only: Det2BitLT
        USE FciMCParMOD , only : MinorStarDets,MinorStarParent
        IMPLICIT NONE
        INTEGER :: n,DetCurr(0:NIfTot),DetCurr2(0:NIfTot)!,list(0:NIFd,n)
        INTEGER :: nlo,nup,i,ipos,ncurr,CompPart
!        logical :: tbin
!        if(.not.tbin) goto 200
!.......................................................................
!..binary seach
        nlo=1
        nup=n
        IF(n.eq.0) THEN
            ipos=1
            return
        ENDIF
 100    continue
!..if num is larger than the last element of list,
!.. return ipos as nup+1
!        WRITE(6,*) 'in 100 loop'
        if(Det2BitLT(MinorStarDets(:,nup),DetCurr(:),MinorStarParent(:,nup),DetCurr2(:),NIfDBO).eq.1) then 
           ipos=nup+1
           return
        endif
!..if num is le the first element of the list
!.. return ipos as nlo
        if(Det2BitLT(DetCurr(:),MinorStarDets(:,nlo),DetCurr2(:),MinorStarParent(:,nlo),NIfDBO).eq.1) then
           ipos=nlo
           return
        endif
!..at this point num is within the range of list
!.. take the mid-point and see how num compares
        ncurr=(nlo+nup)/2
        IF(nlo.eq.ncurr) THEN
!Insertion point is between nlo and nup...
            ipos=nlo+1
            return
        ENDIF

        CompPart=Det2BitLT(MinorStarDets(:,ncurr),DetCurr(:),MinorStarParent(:,ncurr),DetCurr2(:),NIfDBO)
        ! Compares determinants w regards to both the determinants and the parents.


!.. if list(ncurr) gt num then the upper bound to the 
!.. list can be shifted to nup
!        if(list(ncurr).gt.num) nup=ncurr
        if(CompPart.eq.-1) THEN
            nup=ncurr
        else
!..if list(ncurr) le num then the lower bound can be 
!.. can be shifted to ncurr
            nlo=ncurr
        endif
!..
!.. list(ncurr).eq.num
        if(CompPart.eq.0) then 
!..check to see if the previous member is less than num.
!.. if so, return ipose=ncurr
           if(Det2BitLT(MinorStarDets(:,ncurr-1),DetCurr(:),MinorStarParent(:,ncurr-1),DetCurr2(:),NIfDBO).eq.1) then
!           if(list(ncurr-1).lt.num) then
              ipos=ncurr 
              return
           endif
!..check to see if the next member of list is ge num
!.. if so, return ipos=ncurr
           if(Det2BitLT(MinorStarDets(:,ncurr+1),DetCurr(:),MinorStarParent(:,ncurr+1),DetCurr2(:),NIfDBO).eq.-1) then
!           if(list(ncurr+1).gt.num) then
              ipos=ncurr 
              return
           endif
        endif
        goto 100
!...........................................................................
 200    continue
!..simple linear search. At the moment, you cannot get here.
        do i=1,n
           if(Det2BitLT(MinorStarDets(:,i),DetCurr(:),MinorStarParent(:,i),DetCurr2(:),NIfDBO).ne.1) then 
             ipos=i
             return
           endif
        enddo
        ipos=n+1
    END SUBROUTINE searchminor


!This routine will check to see if any of the orbitals in the determinant are in the orbitals which are only to be attached to HF in a 'star'
    SUBROUTINE CheckStarOrbs(DetCurr,tStarDet)
        INTEGER :: DetCurr(NEl),i
        LOGICAL :: tStarDet

        tStarDet=.false.
        do i=NEl,1,-1
            IF(SpinInvBrr(DetCurr(i)).gt.(nBasis-iStarOrbs)) THEN
                tStarDet=.true.
                EXIT
            ENDIF
        enddo

    END SUBROUTINE CheckStarOrbs

SUBROUTINE DissociateExitgen(Exitgen)
    use FCIMCParMod
    TYPE(ExcitPointer) :: Exitgen
    INTEGER :: ind

    IF(.not.ASSOCIATED(Exitgen%PointToExcit)) THEN
        RETURN
    ENDIF
    Ind=Exitgen%IndexinExArr

    IF(Excitgens(Ind)%nPointed.eq.1) THEN
!We want to delete this excitgen.
        DEALLOCATE(Excitgens(Ind)%ExcitData)
        Excitgens(Ind)%nPointed=0

!Add removed excitgen to the front of the free index list
        FreeIndArray(FrontOfList)=Ind
!Increment frontoflist in a circular fashion.
        IF(FrontOfList.eq.MaxWalkersPart) THEN
            FrontOfList=1
        ELSE
            FrontOfList=FrontOfList+1
        ENDIF

    ELSE
        Excitgens(Ind)%nPointed=Excitgens(Ind)%nPointed-1
    ENDIF
    Exitgen%PointToExcit=>null()    !Point to null to show that it is now free.

END SUBROUTINE DissociateExitgen

!This routine acts as a thermostat for the simulation - killing random particles if the population becomes too large, or 
!Doubling them if it gets too low...
    SUBROUTINE ThermostatParticlesPar(HighLow)
        IMPLICIT NONE
        LOGICAL :: HighLow
        INTEGER :: VecSlot,i,j,ToCull,Culled,OrigWalkers,Chosen
        REAL*8 :: r

        IF(HighLow) THEN
!The population is too large - cull TotWalkers/CullFactor randomly selected particles

            OrigWalkers=TotWalkers
            ToCull=TotWalkers-nint((TotWalkers+0.D0)/CullFactor)
            Culled=0

            do while (Culled.lt.ToCull)

!Pick a random walker between 1 and TotWalkers
                IF(tMerTwist) THEN
                    r = genrand_real2_dSFMT() 
                ELSE
                    CALL RANLUX(r,1)
                ENDIF
                Chosen=int((r*TotWalkers)+1.D0)

!Move the Walker at the end of the list to the position of the walker we have chosen to destroy
                CurrentDets(:,Chosen)=CurrentDets(:,TotWalkers)
                CurrentSign(Chosen)=CurrentSign(TotWalkers)
                IF(.not.tRegenDiagHEls) CurrentH(Chosen)=CurrentH(TotWalkers)

                TotWalkers=TotWalkers-1
                Culled=Culled+1

            enddo

            IF(TotWalkers.ne.(OrigWalkers-ToCull)) THEN
                WRITE(6,*) "Error in culling walkers..."
                STOP "Error in culling walkers..."
            ENDIF

!CullInfo(:,2) is the new number of total walkers
            CullInfo(NoCulls,2)=TotWalkers

        ELSE
!The population is too low - give it a boost by doubling every particle

            IF(tRotoAnnihil) THEN

                do i=1,TotWalkers
                    CurrentSign(i)=CurrentSign(i)*2
                enddo
                TotParts=TotParts*2
                CullInfo(NoCulls,2)=TotParts

            ELSE

                VecSlot=TotWalkers+1
                do i=1,TotWalkers

!Add clone of walker, at the same determinant, to the end of the list
                    CurrentDets(:,VecSlot)=CurrentDets(:,i)
                    CurrentSign(VecSlot)=CurrentSign(i)
                    IF(.not.tRegenDiagHEls) CurrentH(VecSlot)=CurrentH(i)
!                    CurrentIC(VecSlot)=CurrentIC(i)

                    VecSlot=VecSlot+1

                enddo

                TotWalkers=TotWalkers*2

                IF((VecSlot-1).ne.TotWalkers) THEN
                    WRITE(6,*) "Problem in doubling all particles..."
                    STOP "Problem in doubling all particles..."
                ENDIF

!CullInfo(:,2) is the new number of total walkers
                CullInfo(NoCulls,2)=TotWalkers

            ENDIF

        ENDIF

        RETURN

    END SUBROUTINE ThermostatParticlesPar

!A routine to annihilate particles in parallel. This involves separating hashes by abs(mod(hash,nProc)) to each node and annihilating there,       
!before sending back the annihilated particles to be removed from their original processors.
    SUBROUTINE AnnihilatePartPar(TotWalkersNew)
        INTEGER :: i,j,k,ToAnnihilateIndex,TotWalkersNew,ierr,error,sendcounts(nProcessors)
        INTEGER :: TotWalkersDet,InitialBlockIndex,FinalBlockIndex,ToAnnihilateOnProc,VecSlot
        INTEGER :: disps(nProcessors),recvcounts(nProcessors),recvdisps(nProcessors)!,AnnihilPart(nProcessors)
        INTEGER :: Minsendcounts,Maxsendcounts,DebugIter,SubListInds(2,nProcessors),MinProc,MinInd
        REAL*8 :: PopDensity(0:NEl)
        INTEGER , ALLOCATABLE :: TempExcitLevel(:)
        INTEGER(KIND=i2) :: HashCurr,MinBin,RangeofBins,NextBinBound,MinHash
        CHARACTER(len=*), PARAMETER :: this_routine='AnnihilatePartPar'
        INTEGER , ALLOCATABLE :: TempSign(:)                                                         !Temp array to hold sign of walkers when annihilating
        INTEGER(KIND=i2) , ALLOCATABLE :: TempHash(:)
        INTEGER :: TempSignTag=0,TempHashTag=0

!This is just to see if there are higher-weighted determinants that HF...
!        AllNoatHF=0
!        CALL MPI_AllReduce(NoatHF,AllNoatHF,1,MPI_INTEGER,MPI_SUM,MPI_COMM_WORLD,ierr)

!        DebugIter=0
!        IF(Iter.eq.DebugIter) THEN
!            WRITE(6,*) "Printing out annihilation debug info for Iteration: ",Iter,DebugIter
!        ENDIF

!        IF(TLocalAnnihilation) THEN
!!We need to calculate the approximate population density of each excitation level
!!ApproxExcitDets contains the approximate number of determinants in each excitation level
!!PartsinExcitlevel is the number of particles in each excitation level for the current iteration
!!PopDensity is simply the approximate population density of particles in a given excitation level
!            do i=0,NEl
!                PopDensity(i)=REAL(PartsinExcitLevel(i),dp)/ApproxExcitDets(i)
!            enddo
!            PartsinExcitLevel(:)=0  !Rezero for the next iteration
!!Allocate memory to hold the excitation levels. This is needed since the amount of local annihilation will be a function of
!!PopDensity which the particle is at. This means it needs to be taken with the hash.
!            ALLOCATE(TempExcitLevel(TotWalkersNew),stat=ierr)
!            TempExcitLevel(1:TotWalkersNew)=NewIC(1:TotWalkersNew)
!        ENDIF

!First, allocate memory to hold the signs and the hashes while we annihilate
        ALLOCATE(TempSign(TotWalkersNew),stat=ierr)
!Comment out the memallocs later
!        CALL LogMemAlloc('TempSign',TotWalkersNew,4,this_routine,TempSignTag,ierr)
        ALLOCATE(TempHash(TotWalkersNew),stat=ierr)
!        CALL LogMemAlloc('TempHash',TotWalkersNew,8,this_routine,TempHashTag,ierr)
        
!Temporary arrays, storing the signs and Hashes need ot be kept, as both these arrays are going to be mixed
        TempSign(1:TotWalkersNew)=NewSign(1:TotWalkersNew)
        TempHash(1:TotWalkersNew)=Hash2Array(1:TotWalkersNew)
    
!Create the arrays for index and process
        do i=1,TotWalkersNew
            IndexTable(i)=i
        enddo
        ProcessVec(1:TotWalkersNew)=iProcIndex

!        IF(Iter.eq.DebugIter) THEN
!            WRITE(6,*) TotWalkersNew
!            do i=1,TotWalkersNew
!                WRITE(6,*) i,Hash2Array(i),IndexTable(i),ProcessVec(i),NewSign(i)
!            enddo
!        ENDIF

        CALL set_timer(Sort_Time,30)
!Next, order the hash array, taking the index, CPU and sign with it...
        IF(.not.tAnnihilatebyRange) THEN
!Order the array by abs(mod(Hash,nProcessors)). This will result in a more load-balanced system
!             IF(TLocalAnnihilation) THEN
!If we are locally annihilating, then we need to take the excitation level of each walker with the hash
!                 CALL SortMod4I1LLong(TotWalkersNew,Hash2Array(1:TotWalkersNew),IndexTable(1:TotWalkersNew),ProcessVec(1:TotWalkersNew),TempExcitLevel(1:TotWalkersNew),NewSign(1:TotWalkersNew),nProcessors)
!             ELSE
!            CALL SortMod3I1LLong(TotWalkersNew,Hash2Array(1:TotWalkersNew),IndexTable(1:TotWalkersNew),ProcessVec(1:TotWalkersNew),NewSign(1:TotWalkersNew),nProcessors)
            CALL SortMod4ILong(TotWalkersNew,Hash2Array(1:TotWalkersNew),IndexTable(1:TotWalkersNew),ProcessVec(1:TotWalkersNew),NewSign(1:TotWalkersNew),nProcessors)
!             ENDIF
            CALL halt_timer(Sort_Time)

!Send counts is the size of each block of ordered dets which are going to each processor. This could be binary searched for extra speed
            j=1
            do i=0,nProcessors-1    !Search through all possible values of abs(mod(Hash,nProcessors))
                do while((abs(mod(Hash2Array(j),INT(nProcessors,8))).eq.i).and.(j.le.TotWalkersNew))
                    j=j+1 
                enddo
                sendcounts(i+1)=j-1
            enddo
        
        ELSE
!We can try to sort the hashes by range, which may result in worse load-balancing, but will remove the need for a second sort of the hashes once they have been sent to the correct processor.
!            CALL Sort3I1LLong(TotWalkersNew,Hash2Array(1:TotWalkersNew),IndexTable(1:TotWalkersNew),ProcessVec(1:TotWalkersNew),NewSign(1:TotWalkersNew))
            CALL Sort4ILong(TotWalkersNew,Hash2Array(1:TotWalkersNew),IndexTable(1:TotWalkersNew),ProcessVec(1:TotWalkersNew),NewSign(1:TotWalkersNew))
            CALL halt_timer(Sort_Time)
            IF(nProcessors.ne.1) THEN
!We also need to know the ranges of the hashes to send to each processor. Each range should be the same.
                Rangeofbins=INT(HUGE(Rangeofbins)/(nProcessors/2),8)
                MinBin=-HUGE(MinBin)
                NextBinBound=MinBin+Rangeofbins
!            WRITE(6,*) "Rangeofbins: ",Rangeofbins
!            WRITE(6,*) "MinBin: ",MinBin
!            WRITE(6,*) "NextBinBound: ",NextBinBound

!We need to find the indices for each block of hashes which are to be sent to each processor.
!Sendcounts is the size of each block of ordered dets which are going to each processors. This could be binary searched for extra speed.
                j=1
                do i=1,nProcessors    !Search through all possible values of the hashes
                    do while((Hash2Array(j).le.NextBinBound).and.(j.le.TotWalkersNew))
                        j=j+1
                    enddo
                    sendcounts(i)=j-1
                    IF(i.eq.nProcessors-1) THEN
!Make sure the final bin catches everything...
                        NextBinBound=HUGE(NextBinBound)
                    ELSE
                        NextBinBound=NextBinBound+Rangeofbins
                    ENDIF
                enddo
            ELSE
                sendcounts(1)=TotWalkersNew
            ENDIF

        ENDIF
        
!        IF(Iter.eq.DebugIter) THEN
!            WRITE(6,*) "***************"
!            WRITE(6,*) TotWalkersNew
!            do i=1,TotWalkersNew
!                WRITE(6,*) Hash2Array(i),abs(mod(Hash2Array(i),nProcessors)),IndexTable(i),ProcessVec(i),NewSign(i)
!            enddo
!        ENDIF
        
        IF(sendcounts(nProcessors).ne.TotWalkersNew) THEN
            WRITE(6,*) "SENDCOUNTS is: ",sendcounts(:)
            WRITE(6,*) "TOTWALKERSNEW is: ",TotWalkersNew
            CALL FLUSH(6)
            CALL Stop_All("AnnihilatePartPar","Incorrect calculation of sendcounts")
        ENDIF

!Oops, we have calculated them cumulativly - undo this
        maxsendcounts=sendcounts(1)
        minsendcounts=sendcounts(1)     !Find max & min sendcounts, so that load-balancing can be checked
!        WRITE(6,*) maxsendcounts,minsendcounts
        do i=2,nProcessors
            do j=1,i-1
                sendcounts(i)=sendcounts(i)-sendcounts(j)
            enddo
            IF(sendcounts(i).gt.maxsendcounts) THEN
                maxsendcounts=sendcounts(i)
            ELSEIF(sendcounts(i).lt.minsendcounts) THEN
                minsendcounts=sendcounts(i)
            ENDIF
        enddo
        
!The disps however do want to be cumulative - this is the array indexing the start of the data block
        disps(1)=0      !Starting element is always the first element
        do i=2,nProcessors
            disps(i)=disps(i-1)+sendcounts(i-1)
        enddo
        
!        IF(Iter.eq.DebugIter) THEN
!            WRITE(6,*) "SENDCOUNTS: "
!            WRITE(6,*) sendcounts(:)
!            WRITE(6,*) "DISPS: "
!            WRITE(6,*) disps(:)
!            CALL FLUSH(6)
!        ENDIF

!We now need to calculate the recvcounts and recvdisps - this is a job for AlltoAll
        recvcounts(1:nProcessors)=0
!Put a barrier here so all processes synchronise
!        CALL MPIBarrier(error)
        CALL set_timer(Comms_Time,30)

        CALL MPIAlltoAllI(sendcounts,1,recvcounts,1,error)

!We can now get recvdisps from recvcounts in the same way we obtained disps from sendcounts
        recvdisps(1)=0
        do i=2,nProcessors
            recvdisps(i)=recvdisps(i-1)+recvcounts(i-1)
        enddo

        MaxIndex=recvdisps(nProcessors)+recvcounts(nProcessors)
!Max index is the largest occupied index in the array of hashes to be ordered in each processor 
        IF(MaxIndex.gt.(0.95*MaxWalkersAnnihil)) THEN
            CALL Warning("AnnihilatePartPar","Maximum index of annihilation array is close to maximum length. Increase MemoryFacAnnihil")
        ENDIF
!Uncomment this if you want to write out load-balancing statistics.
!        AnnihilPart(:)=0
!        CALL MPI_Gather(MaxIndex,1,MPI_INTEGER,AnnihilPart,1,MPI_INTEGER,root,MPI_COMM_WORLD,error)
!        IF(iProcIndex.eq.root) THEN
!            WRITE(13,"(I10)",advance='no') Iter
!            do i=1,nProcessors
!                WRITE(13,"(I10)",advance='no') AnnihilPart(i)
!            enddo
!            WRITE(13,"(A)") ""
!            CALL FLUSH(13)
!        ENDIF

!        IF(Iter.eq.DebugIter) THEN
!            WRITE(6,*) "RECVCOUNTS: "
!            WRITE(6,*) recvcounts(:)
!            WRITE(6,*) "RECVDISPS: "
!            WRITE(6,*) recvdisps(:),MaxIndex
!            CALL FLUSH(6)
!        ENDIF

!Insert a load-balance check here...maybe find the s.d. of the sendcounts array - maybe just check the range first.
!        IF(TotWalkersNew.gt.200) THEN
!            IF((Maxsendcounts-Minsendcounts).gt.(TotWalkersNew/3)) THEN
!                WRITE(6,"(A,I12)") "**WARNING** Parallel annihilation not optimally balanced on this node, for iter = ",Iter
!                WRITE(6,*) "Sendcounts is: ",sendcounts(:)
!!                CALL FLUSH(6)
!            ENDIF
!        ENDIF
        
!Now send the chunks of hashes to the corresponding processors
        CALL MPIAlltoAllvI8(Hash2Array(1:TotWalkersNew),sendcounts,disps,HashArray(1:MaxIndex),recvcounts,recvdisps,error)        

!The signs of the hashes, index and CPU also need to be taken with them.
        CALL MPIAlltoAllvI(NewSign(1:TotWalkersNew),sendcounts,disps,CurrentSign,recvcounts,recvdisps,error)
        CALL MPIAlltoAllvI(IndexTable(1:TotWalkersNew),sendcounts,disps,Index2Table,recvcounts,recvdisps,error)
        CALL MPIAlltoAllvI(ProcessVec(1:TotWalkersNew),sendcounts,disps,Process2Vec,recvcounts,recvdisps,error)
!        IF(TLocalAnnihilation) THEN
!!If we are locally annihilating, then we need to take the excitation level of the particle with us.
!!We can send the information to CurrentIC - this is where the final information will be stored, but currently, it is redundant.
!            CALL MPI_AlltoAllv(TempExcitLevel(1:TotWalkersNew),sendcounts,disps,MPI_INTEGER,CurrentIC,recvcounts,recvdisps,MPI_INTEGER,MPI_COMM_WORLD,error)
!        ENDIF
        CALL halt_timer(Comms_Time)
        
!        IF(Iter.eq.DebugIter) THEN
!            WRITE(6,*) "AFTER DIVISION:   - No. on processor is: ",MaxIndex
!            do i=1,MaxIndex
!                WRITE(6,*) HashArray(i),abs(mod(HashArray(i),nProcessors)),Index2Table(i),Process2Vec(i),CurrentSign(i)
!            enddo
!            CALL FLUSH(6)
!        ENDIF

!Now we need to perform the actual annihilation, running through all the particles and calculating which ones want to be annihilated.
        CALL set_timer(Sort_Time,30)
        IF(.not.tAnnihilatebyrange) THEN
!The hashes now need to be sorted again - this time by their number
!This sorting would be redundant if we had initially sorted the hashes by range (ie tAnnihilatebyrange).
!            IF(TLocalAnnihilation) THEN
!If we are locally annihilating, then we need to take the excitation level with us.
!                CALL Sort4I1LLong(MaxIndex,HashArray(1:MaxIndex),Index2Table(1:MaxIndex),Process2Vec(1:MaxIndex),CurrentIC(1:MaxIndex),CurrentSign(1:MaxIndex))
!            ELSE
!                CALL Sort3I1LLong(MaxIndex,HashArray(1:MaxIndex),Index2Table(1:MaxIndex),Process2Vec(1:MaxIndex),CurrentSign(1:MaxIndex))
                CALL Sort4ILong(MaxIndex,HashArray(1:MaxIndex),Index2Table(1:MaxIndex),Process2Vec(1:MaxIndex),CurrentSign(1:MaxIndex))
!            ENDIF
        ELSE
!Here, because we have ordered the hashes initially numerically, we have a set of ordered lists. It is therefore easier to sort them.
!We have to work out how to run sequentially through the hashes, which are a set of nProc seperate ordered lists.
!We would need to have 2*nProc indices, since we will have a set of nProc disjoint ordered sublists.
!SubListInds(1,iProc)=index of current hash from processor iProc
!SubListInds(2,iProc)=index of final hash from processor iProc
!Indices can be obtained from recvcounts and recvdisps - recvcounts(iProc-1) is number of hashes from iProc
!recvdisps(iProc-1) is the displacement to the start of the hashes from iProc
            do i=1,nProcessors-1
                SubListInds(1,i)=recvdisps(i)+1
                SubListInds(2,i)=recvdisps(i+1)
            enddo
            SubListInds(1,nProcessors)=recvdisps(nProcessors)+1
            SubListInds(2,nProcessors)=MaxIndex
!            WRITE(6,*) "SubListInds(1,:) ", SubListInds(1,:)
!            WRITE(6,*) "SubListInds(2,:) ", SubListInds(2,:)
!            WRITE(6,*) "Original hash list is: "
!            do i=1,MaxIndex
!                WRITE(6,*) HashArray(i)
!            enddo
!            WRITE(6,*) "**************"
!Reorder the lists so that they are in numerical order.
            j=1
            do while(j.le.MaxIndex)
                do i=1,nProcessors
                    IF(SubListInds(1,i).le.SubListInds(2,i)) THEN
!This block still has hashes which want to be sorted
                        MinHash=HashArray(SubListInds(1,i))
                        MinProc=i
                        MinInd=SubListInds(1,i)
                        EXIT
                    ENDIF
!                    IF(i.eq.nProcessors) THEN
!                        WRITE(6,*) "ERROR HERE!!"
!                        CALL FLUSH(6)
!                    ENDIF
                enddo
                IF(MinHash.ne.HashCurr) THEN
                    do i=MinProc+1,nProcessors
                        IF((SubListInds(1,i).le.SubListInds(2,i)).and.(HashArray(SubListInds(1,i)).lt.MinHash)) THEN
                            MinHash=HashArray(SubListInds(1,i))
                            MinProc=i
                            MinInd=SubListInds(1,i)
                            IF(MinHash.eq.HashCurr) THEN
                                EXIT
                            ENDIF
                        ENDIF
                    enddo
                ENDIF
!Next smallest hash is MinHash - move the ordered elements into the other array.
                Hash2Array(j)=MinHash
                IndexTable(j)=Index2Table(MinInd)
                ProcessVec(j)=Process2Vec(MinInd)
                NewSign(j)=CurrentSign(MinInd)
                HashCurr=MinHash
!Move through the block
                j=j+1
                SubListInds(1,MinProc)=SubListInds(1,MinProc)+1
            enddo

            IF((j-1).ne.MaxIndex) THEN
                CALL Stop_All(this_routine,"Error here in the merge sort algorithm")
            ENDIF

!Need to copy the lists back to the original array
            do i=1,MaxIndex
                Index2Table(i)=IndexTable(i)
                Process2Vec(i)=ProcessVec(i)
                CurrentSign(i)=NewSign(i)
                HashArray(i)=Hash2Array(i)
            enddo
                
!            Index2Table(1:MaxIndex)=IndexTable(1:MaxIndex)
!            Process2Vec(1:MaxIndex)=ProcessVec(1:MaxIndex)
!            CurrentSign(1:MaxIndex)=NewSign(1:MaxIndex)
!            HashArray(1:MaxIndex)=Hash2Array(1:MaxIndex)
                    
        ENDIF

        CALL halt_timer(Sort_Time)

!        IF(Iter.eq.DebugIter) THEN
!            WRITE(6,*) "AFTER DIVISION & ORDERING:   - No. on processor is: ",MaxIndex
!            do i=1,MaxIndex
!                WRITE(6,*) HashArray(i),abs(mod(HashArray(i),nProcessors)),Index2Table(i),Process2Vec(i),CurrentSign(i)
!            enddo
!            CALL FLUSH(6)
!        ENDIF

!Work out the index of the particles which want to be annihilated
        j=1
        ToAnnihilateIndex=1
        do while(j.le.MaxIndex)
            TotWalkersDet=0
            InitialBlockIndex=j
            FinalBlockIndex=j-1         !Start at j-1 since we are increasing FinalBlockIndex even with the first det in the next loop
            HashCurr=HashArray(j)
            do while((HashArray(j).eq.HashCurr).and.(j.le.MaxIndex))
!First loop counts walkers in the block - TotWalkersDet is then the residual sign of walkers on that determinant
                IF(CurrentSign(j).eq.1) THEN
                    TotWalkersDet=TotWalkersDet+1
                ELSE
                    TotWalkersDet=TotWalkersDet-1
                ENDIF
                FinalBlockIndex=FinalBlockIndex+1
                j=j+1
            enddo

!            IF(TotWalkersDet.gt.AllNoatHF) THEN
!                WRITE(6,"(A,I20,2I7)") "High-weighted Det: ",HashCurr,TotWalkersDet,INT(AllSumNoatHF,4)
!            ENDIF
     
!            IF(Iter.eq.DebugIter) THEN
!                WRITE(6,*) "Common block of dets found from ",InitialBlockIndex," ==> ",FinalBlockIndex
!                WRITE(6,*) "Sum of signs in block is: ",TotWalkersDet
!                CALL FLUSH(6)
!            ENDIF

!            IF(TLocalAnnihilation) THEN
!!This is an attempt to approximate the expected annihilation rates when the occupancy of a determinant is only 1.
!                IF(InitialBlockIndex.eq.FinalBlockIndex) THEN
!!The occupancy of the determinant is only one
!!The walker is at an excitation level of CurrentIC(InitialBlockIndex). The only parameter the local annihilation depends on is the population 
!!density of that excitation level, stored in PopDensity
!                    IF(AttemptLocalAnn(PopDensity(CurrentIC(InitialBlockIndex)))) THEN
!!Particle is killed, even though it is the lone occupier of the determinant
!                        TotWalkersDet=0     !By setting TotWalkersDet to zero, it will kill the particle in the next section
!                        LocalAnn=LocalAnn+1 !Keep a track of the number of particles locally annihilated
!!                        IF(HashCurr.eq.HFHash) THEN
!!                            WRITE(6,*) "HF Determinant particle locally annihilated"
!!                        ENDIF
!                    ENDIF
!                ENDIF
!            ENDIF
        
            do k=InitialBlockIndex,FinalBlockIndex
!Second run through the block of same determinants marks walkers for annihilation
                IF(TotWalkersDet.eq.0) THEN
!All walkers in block want to be annihilated from now on.
                    IndexTable(ToAnnihilateIndex)=Index2Table(k)
                    ProcessVec(ToAnnihilateIndex)=Process2Vec(k)
!                    Hash2Array(ToAnnihilateIndex)=HashArray(k)     !This is not strictly needed - remove after checking
!                    NewSign(ToAnnihilateIndex)=CurrentSign(k)       !This is also need needed, but useful for checking
!                    IF(Iter.eq.DebugIter) WRITE(6,*) "Annihilating from if block 1",j,k
                    ToAnnihilateIndex=ToAnnihilateIndex+1
!                    IF(HashCurr.eq.HFHash) THEN
!                        WRITE(6,*) "HF Determinant particle annihilated"
!                    ENDIF
                ELSEIF((TotWalkersDet.lt.0).and.(CurrentSign(k).eq.1)) THEN
!Annihilate if block has a net negative walker count, and current walker is positive
                    IndexTable(ToAnnihilateIndex)=Index2Table(k)
                    ProcessVec(ToAnnihilateIndex)=Process2Vec(k)
!                    Hash2Array(ToAnnihilateIndex)=HashArray(k)     !This is not strictly needed - remove after checking
!                    NewSign(ToAnnihilateIndex)=CurrentSign(k)       !This is also need needed, but useful for checking
!                    IF(Iter.eq.DebugIter) WRITE(6,*) "Annihilating from if block 2",j,k
                    ToAnnihilateIndex=ToAnnihilateIndex+1
!                    IF(HashCurr.eq.HFHash) THEN
!                        WRITE(6,*) "HF Determinant particle annihilated"
!                    ENDIF
                ELSEIF((TotWalkersDet.gt.0).and.(CurrentSign(k).eq.-1)) THEN
!Annihilate if block has a net positive walker count, and current walker is negative
                    IndexTable(ToAnnihilateIndex)=Index2Table(k)
                    ProcessVec(ToAnnihilateIndex)=Process2Vec(k)
!                    Hash2Array(ToAnnihilateIndex)=HashArray(k)     !This is not strictly needed - remove after checking
!                    NewSign(ToAnnihilateIndex)=CurrentSign(k)       !This is also need needed, but useful for checking
!                    IF(Iter.eq.DebugIter) WRITE(6,*) "Annihilating from if block 3",j,k
                    ToAnnihilateIndex=ToAnnihilateIndex+1
!                    IF(HashCurr.eq.HFHash) THEN
!                        WRITE(6,*) "HF Determinant particle annihilated"
!                    ENDIF
                ELSE
!If net walkers is positive, and we have a positive walkers, then remove one from the net positive walkers and continue through the block
                    IF(CurrentSign(k).eq.1) THEN
                        TotWalkersDet=TotWalkersDet-1
                    ELSE
                        TotWalkersDet=TotWalkersDet+1
                    ENDIF
                ENDIF
            enddo
        
!            j=j+1   !Increment counter

        enddo

        ToAnnihilateIndex=ToAnnihilateIndex-1   !ToAnnihilateIndex now tells us the total number of particles to annihilate from the list on this processor
!        IF(Iter.eq.DebugIter) THEN
!            WRITE(6,*) "Number of particles to annihilate from hashes on this processor: ",ToAnnihilateIndex
!            CALL FLUSH(6)
!        ENDIF

!The annihilation is complete - particles to be annihilated are stored in IndexTable and need to be sent back to their original processor
!To know which processor that is, we need to order the particles to be annihilated in terms of their CPU, i.e. ProcessVec(1:ToAnnihilateIndex)
!Is the list already ordered according to CPU? Is this further sort even necessary?

        IF(ToAnnihilateIndex.gt.1) THEN
            CALL set_timer(Sort_Time,30)
!Do not actually have to take indextable, hash2array or newsign with it...
            CALL Sort2IILongI(ToAnnihilateIndex,ProcessVec(1:ToAnnihilateIndex),IndexTable(1:ToAnnihilateIndex),Hash2Array(1:ToAnnihilateIndex),NewSign(1:ToAnnihilateIndex))
!            CALL Sort2IILongL(ToAnnihilateIndex,ProcessVec(1:ToAnnihilateIndex),IndexTable(1:ToAnnihilateIndex),Hash2Array(1:ToAnnihilateIndex),NewSign(1:ToAnnihilateIndex))
            CALL halt_timer(Sort_Time)
        ENDIF

!We now need to regenerate sendcounts and disps
        sendcounts(1:nProcessors)=0
        do i=1,ToAnnihilateIndex
            IF(ProcessVec(i).gt.(nProcessors-1)) THEN
                CALL Stop_All("AnnihilatePartPar","Annihilation error")
            ENDIF
            sendcounts(ProcessVec(i)+1)=sendcounts(ProcessVec(i)+1)+1
        enddo
!The disps however do want to be cumulative
        disps(1)=0      !Starting element is always the first element
        do i=2,nProcessors
            disps(i)=disps(i-1)+sendcounts(i-1)
        enddo

!We now need to calculate the recvcounts and recvdisps - this is a job for AlltoAll
        recvcounts(1:nProcessors)=0
!Put a barrier here so all processes synchronise
!        CALL MPIBarrier(error)
        CALL set_timer(Comms_Time,30)

        CALL MPIAlltoAllI(sendcounts,1,recvcounts,1,error)

!We can now get recvdisps from recvcounts in the same way we obtained disps from sendcounts
        recvdisps(1)=0
        do i=2,nProcessors
            recvdisps(i)=recvdisps(i-1)+recvcounts(i-1)
        enddo

        ToAnnihilateonProc=recvdisps(nProcessors)+recvcounts(nProcessors)
        
!        IF(Iter.eq.DebugIter) THEN
!            WRITE(6,*) "FOR RETURN OF ANNIHILATED PARTICLES, SENDCOUNTS: ",sendcounts(:)
!            WRITE(6,*) "DISPS: ",disps(:)
!            WRITE(6,*) "RECVCOUNTS: ",recvcounts(:)
!            WRITE(6,*) "RECVDISPS: ",recvdisps(:)
!            WRITE(6,*) "ToAnnihilateOnProc: ",ToAnnihilateonProc
!            CALL FLUSH(6)
!        ENDIF

!Perform another matrix transpose of the annihilation data using MPI_AlltoAllv, to send the data back to its correct Processor
!The signs of the hashes, index and CPU also need to be taken with them. (CPU does not need to be taken - every element of CPU should be equal to the rank of the processor+1)
!Hash also does not need to be taken, but will be taken as a precaution
!        CALL MPI_AlltoAllv(Hash2Array(1:TotWalkersNew),sendcounts,disps,MPI_DOUBLE_PRECISION,HashArray,recvcounts,recvdisps,mpilongintegertype,MPI_COMM_WORLD,error)        
!        IF(error.ne.MPI_SUCCESS) THEN
!            WRITE(6,*) "Error in sending back annihilated particles"
!            CALL Stop_All("AnnihilatePartPar","Error in sending back annihilated particles")
!        ENDIF
!        CALL MPI_AlltoAllv(NewSign(1:TotWalkersNew),sendcounts,disps,MPI_LOGICAL,CurrentSign,recvcounts,recvdisps,MPI_LOGICAL,MPI_COMM_WORLD,error)
!        IF(error.ne.MPI_SUCCESS) THEN
!            WRITE(6,*) "Error in sending back annihilated particles"
!            CALL Stop_All("AnnihilatePartPar","Error in sending back annihilated particles")
!        ENDIF
!        CALL MPI_AlltoAllv(IndexTable(1:TotWalkersNew),sendcounts,disps,MPI_INTEGER,Index2Table,recvcounts,recvdisps,MPI_INTEGER,MPI_COMM_WORLD,error)
        CALL MPIAlltoAllvI(IndexTable(1:ToAnnihilateonProc),sendcounts,disps,Index2Table,recvcounts,recvdisps,error)
!        IF(error.ne.MPI_SUCCESS) THEN
!            WRITE(6,*) "Error in sending back annihilated particles"
!            CALL Stop_All("AnnihilatePartPar","Error in sending back annihilated particles")
!        ENDIF
!        CALL MPI_AlltoAllv(ProcessVec(1:TotWalkersNew),sendcounts,disps,MPI_INTEGER,Process2Vec,recvcounts,recvdisps,MPI_INTEGER,MPI_COMM_WORLD,error)
!        IF(error.ne.MPI_SUCCESS) THEN
!            WRITE(6,*) "Error in sending back annihilated particles"
!            CALL Stop_All("AnnihilatePartPar","Error in sending back annihilated particles")
!        ENDIF
        CALL halt_timer(Comms_Time)

!TEST
!        do i=1,ToAnnihilateonProc
!            IF(Process2Vec(i).ne.(iProcIndex)) THEN
!                CALL Stop_All("AnnihilatePartPar","AlltoAllv performed incorrectly")
!            ENDIF
!        enddo

!Index2Table now is a list, of length "ToAnnihilateonProc", of walkers which should NOT be transferred to the next array. 
!Order the list according to this index (Hash and sign does not need to be sorted, but will for debugging purposes)
        CALL set_timer(Sort_Time,30)
        CALL SORTIILongI(ToAnnihilateonProc,Index2Table(1:ToAnnihilateonProc),HashArray(1:ToAnnihilateonProc),CurrentSign(1:ToAnnihilateonProc))
!        CALL SORTIILongL(ToAnnihilateonProc,Index2Table(1:ToAnnihilateonProc),HashArray(1:ToAnnihilateonProc),CurrentSign(1:ToAnnihilateonProc))
        CALL halt_timer(Sort_Time)

!        IF(Iter.eq.DebugIter) THEN
!            WRITE(6,*) "Number of hashes originally on processor which need to be removed=",ToAnnihilateonProc
!            WRITE(6,*) "To annihilate from processor: "
!            do i=1,ToAnnihilateonProc
!                WRITE(6,*) Index2Table(i),HashArray(i),CurrentSign(i)
!            enddo
!        ENDIF

!TEST - do the hashes and signs match the ones that are returned?
!        do i=1,ToAnnihilateonProc
!            IF(TempHash(Index2Table(i)).ne.(HashArray(i))) THEN
!                CALL Stop_All("AnnihilatePartPar","Incorrect Hash returned")
!            ENDIF
!            IF(TempSign(Index2Table(i))) THEN
!                IF(.not.CurrentSign(i)) THEN
!                    CALL Stop_All("AnnihilatePartPar","Incorrect Sign returned")
!                ENDIF
!            ELSE
!                IF(CurrentSign(i)) THEN
!                    CALL Stop_All("AnnihilatePartPar","Incorrect Sign returned")
!                ENDIF
!            ENDIF
!        enddo
        

        IF(ToAnnihilateonProc.ne.0) THEN
!Copy across the data, apart from ones which have an index given by the indicies in Index2Table(1:ToAnnihilateonProc)
            VecSlot=1       !VecSlot is the index in the final array of TotWalkers
            i=1             !i is the index in the original array of TotWalkersNew
            do j=1,ToAnnihilateonProc
!Loop over all particles to be annihilated
!                IF(Iter.eq.DebugIter) WRITE(6,*) Index2Table(j)
                do while(i.lt.Index2Table(j))
!Copy accross all particles less than this number
                    CurrentDets(:,VecSlot)=NewDets(:,i)
!                    CurrentIC(VecSlot)=NewIC(i)
                    IF(.not.tRegenDiagHEls) CurrentH(VecSlot)=NewH(i)
                    IF(.not.TRegenExcitgens) CALL CopyExitgenPar(NewExcits(i),CurrentExcits(VecSlot),.true.)
                    HashArray(VecSlot)=TempHash(i)
                    CurrentSign(VecSlot)=TempSign(i)
                    i=i+1
                    VecSlot=VecSlot+1
                enddo
                IF(.not.TRegenExcitgens) CALL DissociateExitgen(NewExcits(i))    !Destroy particles if not copying accross
                i=i+1
            enddo

!Now need to copy accross the residual - from Index2Table(ToAnnihilateonProc) to TotWalkersNew
            do i=Index2Table(ToAnnihilateonProc)+1,TotWalkersNew
                CurrentDets(:,VecSlot)=NewDets(:,i)
!                CurrentIC(VecSlot)=NewIC(i)
                IF(.not.tRegenDiagHEls) CurrentH(VecSlot)=NewH(i)
                IF(.not.TRegenExcitgens) CALL CopyExitgenPar(NewExcits(i),CurrentExcits(VecSlot),.true.)
                HashArray(VecSlot)=TempHash(i)
                CurrentSign(VecSlot)=TempSign(i)
                VecSlot=VecSlot+1
            enddo

        ELSE
!No particles annihilated
            VecSlot=1
            do i=1,TotWalkersNew
                CurrentDets(:,VecSlot)=NewDets(:,i)
!                CurrentIC(VecSlot)=NewIC(i)
                IF(.not.tRegenDiagHEls) CurrentH(VecSlot)=NewH(i)
                IF(.not.TRegenExcitgens) CALL CopyExitgenPar(NewExcits(i),CurrentExcits(VecSlot),.true.)
                HashArray(VecSlot)=TempHash(i)
                CurrentSign(VecSlot)=TempSign(i)
                VecSlot=VecSlot+1
            enddo
        ENDIF
                
        TotWalkers=VecSlot-1

!        IF(Iter.eq.DebugIter) THEN
!            WRITE(6,*) "FINAL CONFIGURATION: "
!            do i=1,TotWalkers
!                WRITE(6,*) i,HashArray(i),CurrentSign(i)
!            enddo
!        ENDIF

        IF((TotWalkersNew-TotWalkers).ne.ToAnnihilateonProc) THEN
            WRITE(6,*) TotWalkers,TotWalkersNew,ToAnnihilateonProc,Iter
            CALL FLUSH(6)
            CALL Stop_All("AnnihilatePartPar","Problem with numbers when annihilating")
        ENDIF

        DEALLOCATE(TempSign)
!        CALL LogMemDealloc(this_routine,TempSignTag)
        DEALLOCATE(TempHash)
!        CALL LogMemDealloc(this_routine,TempHashTag)
!        IF(TLocalAnnihilation) THEN
!            DEALLOCATE(TempExcitLevel)
!        ENDIF
        
        RETURN

    END SUBROUTINE AnnihilatePartPar

!This routine gets a random excitation for when we want to generate the excitation generator on the fly, then chuck it.
    SUBROUTINE GetPartRandExcitPar(DetCurr,iLutDet,nJ,IC,Frz,Prob,iCount,ExcitLevel,Ex,tParity)
        use GenRandSymExcitNUMod , only : GenRandSymExcitNU
        INTEGER :: DetCurr(NEl),nJ(NEl),IC,Frz,iCount,iMaxExcit,nStore(6),MemLength,ierr
        INTEGER :: Excitlevel,Ex(2,2),iLutDet(0:NIfD)
        REAL*8 :: Prob
        LOGICAL :: tParity
        INTEGER , ALLOCATABLE :: ExcitGenTemp(:)

        IF(tNonUniRandExcits) THEN
!Generate non-uniform random excitations
            CALL GenRandSymExcitNU(DetCurr,iLutDet,nJ,pDoubles,IC,Ex,tParity,exFlag,Prob)

        ELSE
            IF(ExcitLevel.eq.0) THEN
!            CALL GenRandSymExcitIt3(DetCurr,HFExcit%ExcitData,nJ,Seed,IC,Frz,Prob,iCount)
                CALL GenRandSymExcitIt4(DetCurr,HFExcit%ExcitData,nJ,0,IC,Frz,Prob,iCount,Ex,tParity)
                RETURN
            ENDIF
                
!Need to generate excitation generator to find excitation.
!Setup excit generators for this determinant 
            iMaxExcit=0
            nStore(1:6)=0
            CALL GenSymExcitIt2(DetCurr,NEl,G1,nBasis,nBasisMax,.TRUE.,MemLength,nJ,iMaxExcit,0,nStore,3)
            ALLOCATE(ExcitGenTemp(MemLength),stat=ierr)
            IF(ierr.ne.0) CALL Stop_All("SetupExcitGen","Problem allocating excitation generator")
            ExcitGenTemp(1)=0
            CALL GenSymExcitIt2(DetCurr,NEl,G1,nBasis,nBasisMax,.TRUE.,ExcitGenTemp,nJ,iMaxExcit,0,nStore,3)

!Now generate random excitation
!        CALL GenRandSymExcitIt3(DetCurr,ExcitGenTemp,nJ,Seed,IC,Frz,Prob,iCount)
            CALL GenRandSymExcitIt4(DetCurr,ExcitGenTemp,nJ,0,IC,Frz,Prob,iCount,Ex,tParity)

!Deallocate when finished
            DEALLOCATE(ExcitGenTemp)
        ENDIF

        RETURN

    END SUBROUTINE GetPartRandExcitPar

!This will set up the initial walker distribution proportially to the MP1 wavevector.
    SUBROUTINE InitWalkersMP1Par()
        use SystemData , only : tAssumeSizeExcitgen
        use symexcit3 , only : GenExcitations3,CountExcitations3 
        INTEGER :: HFConn,error,ierr,MemoryAlloc,VecSlot,nJ(NEl),nStore(6),iExcit,i,j,WalkersonHF,HFPointer,ExcitLevel,VecInd
        REAL*8 :: SumMP1Compts,MP2Energy,Compt,r,FracPart,TempTotWalkers,TempTotParts
        TYPE(HElement) :: Hij,Hjj,Fjj
        INTEGER , ALLOCATABLE :: MP1Dets(:,:), ExcitgenTemp(:)
        INTEGER , ALLOCATABLE :: MP1Sign(:)
        REAL*8 , ALLOCATABLE :: MP1Comps(:),MP1CompsNonCum(:)
        INTEGER :: MP1DetsTag,MP1SignTag,MP1CompsTag,SumWalkersonHF,ExcitLength,iMaxExcit,IntParts,MP1CompsNonCumTag
        CHARACTER(len=*), PARAMETER :: this_routine='InitWalkersMP1Par'
        LOGICAL :: First,TurnBackAssumeExGen
        INTEGER :: ExcitMat3(2,2),nSingles,nDoubles
        LOGICAL :: tParity,tAllExcitFound

    
        IF(tHub.and.tReal) THEN
            CALL Stop_All(this_routine,"Cannot initialise walkers in MP1 for real space hubbard calculations.")
        ENDIF
!Set the maximum number of walkers allowed
        MaxWalkersPart=NINT(MemoryFacPart*InitWalkers)
!        WRITE(6,"(A,F14.5)") "Memory Factor for walkers is: ",MemoryFacPart
        WRITE(6,"(A,I14)") "Memory allocated for a maximum particle/det number per node of: ",MaxWalkersPart
        IF(tRotoAnnihil) THEN
            MaxSpawned=NINT(MemoryFacSpawn*InitWalkers)
!            WRITE(6,"(A,F14.5)") "Memory Factor for arrays used for spawning is: ",MemoryFacSpawn
            WRITE(6,"(A,I14)") "Memory allocated for a maximum particle number per node for spawning of: ",MaxSpawned
        ELSE
            MaxWalkersAnnihil=NINT(MemoryFacAnnihil*InitWalkers)
!            WRITE(6,"(A,F14.5)") "Memory Factor for arrays used for annihilation is: ",MemoryFacAnnihil
            WRITE(6,"(A,I14)") "Memory allocated for a maximum particle number per node for annihilation of: ",MaxWalkersAnnihil
        ENDIF

!Put a barrier here so all processes synchronise
        CALL MPI_Barrier(MPI_COMM_WORLD,error)
!Allocate memory to hold walkers
        ALLOCATE(WalkVecDets(0:NIfTot,MaxWalkersPart),stat=ierr)
        CALL LogMemAlloc('WalkVecDets',MaxWalkersPart*(NIfTot+1),4,this_routine,WalkVecDetsTag,ierr)
        WalkVecDets(0:NIfTot,1:MaxWalkersPart)=0
        IF(tRotoAnnihil) THEN
            ALLOCATE(WalkVecSign(MaxWalkersPart),stat=ierr)
            CALL LogMemAlloc('WalkVecSign',MaxWalkersPart,4,this_routine,WalkVecSignTag,ierr)
        ELSE
            ALLOCATE(WalkVec2Dets(0:NIfTot,MaxWalkersPart),stat=ierr)
            CALL LogMemAlloc('WalkVec2Dets',MaxWalkersPart*(NIfTot+1),4,this_routine,WalkVec2DetsTag,ierr)
            WalkVec2Dets(0:NIfTot,1:MaxWalkersPart)=0
            ALLOCATE(WalkVecSign(MaxWalkersAnnihil),stat=ierr)
            CALL LogMemAlloc('WalkVecSign',MaxWalkersAnnihil,4,this_routine,WalkVecSignTag,ierr)
            ALLOCATE(WalkVec2Sign(MaxWalkersAnnihil),stat=ierr)
            CALL LogMemAlloc('WalkVec2Sign',MaxWalkersAnnihil,4,this_routine,WalkVec2SignTag,ierr)
            WalkVec2Sign(:)=0
        ENDIF
        WalkVecSign(:)=0

!        ALLOCATE(WalkVecIC(MaxWalkersPart),stat=ierr)
!        CALL LogMemAlloc('WalkVecIC',MaxWalkersPart,4,this_routine,WalkVecICTag,ierr)
!        ALLOCATE(WalkVec2IC(MaxWalkersPart),stat=ierr)
!        CALL LogMemAlloc('WalkVec2IC',MaxWalkersPart,4,this_routine,WalkVec2ICTag,ierr)
        IF(.not.tRegenDiagHEls) THEN
            ALLOCATE(WalkVecH(MaxWalkersPart),stat=ierr)
            CALL LogMemAlloc('WalkVecH',MaxWalkersPart,8,this_routine,WalkVecHTag,ierr)
            WalkVecH(:)=0.d0
            IF(.not.tRotoAnnihil) THEN
                ALLOCATE(WalkVec2H(MaxWalkersPart),stat=ierr)
                CALL LogMemAlloc('WalkVec2H',MaxWalkersPart,8,this_routine,WalkVec2HTag,ierr)
                WalkVec2H(:)=0.d0
            ENDIF
        ELSE
            IF(tRotoAnnihil) THEN
                WRITE(6,"(A,F14.6,A)") "Diagonal H-Elements will not be stored. This will *save* ",REAL(MaxWalkersPart*4*2,dp)/1048576.D0," Mb/Processor"
            ELSE
                WRITE(6,"(A,F14.6,A)") "Diagonal H-Elements will not be stored. This will *save* ",REAL(MaxWalkersPart*4*4,dp)/1048576.D0," Mb/Processor"
            ENDIF
        ENDIF
        
        IF(tRotoAnnihil) THEN
            MemoryAlloc=(NIfTot+1+3)*MaxWalkersPart*4    !Memory Allocated in bytes
            IF(tRegenDiagHEls) MemoryAlloc=MemoryAlloc-(MaxWalkersPart*8)
        ELSE
            MemoryAlloc=((2*MaxWalkersAnnihil)+(((2*(NIfTot+1))+4)*MaxWalkersPart))*4    !Memory Allocated in bytes
            IF(tRegenDiagHEls) MemoryAlloc=MemoryAlloc-(MaxWalkersPart*16)
        ENDIF


        IF(tRotoAnnihil) THEN
            
            WRITE(6,"(A,I12,A)") " Spawning vectors allowing for a total of ",MaxSpawned," particles to be spawned in any one iteration."
            ALLOCATE(SpawnVec(0:NIfTot,MaxSpawned),stat=ierr)
            CALL LogMemAlloc('SpawnVec',MaxSpawned*(NIfTot+1),4,this_routine,SpawnVecTag,ierr)
            SpawnVec(:,:)=0
            ALLOCATE(SpawnVec2(0:NIfTot,MaxSpawned),stat=ierr)
            CALL LogMemAlloc('SpawnVec2',MaxSpawned*(NIfTot+1),4,this_routine,SpawnVec2Tag,ierr)
            SpawnVec2(:,:)=0
            ALLOCATE(SpawnSignVec(0:MaxSpawned),stat=ierr)
            CALL LogMemAlloc('SpawnSignVec',MaxSpawned+1,4,this_routine,SpawnSignVecTag,ierr)
            SpawnSignVec(:)=0
            ALLOCATE(SpawnSignVec2(0:MaxSpawned),stat=ierr)
            CALL LogMemAlloc('SpawnSignVec2',MaxSpawned+1,4,this_routine,SpawnSignVec2Tag,ierr)
            SpawnSignVec2(:)=0
            
            SpawnedParts=>SpawnVec
            SpawnedParts2=>SpawnVec2
            SpawnedSign=>SpawnSignVec
            SpawnedSign2=>SpawnSignVec2

            MemoryAlloc=MemoryAlloc+(((MaxSpawned+1)*2)+(2*MaxSpawned*(1+NIfTot)))*4

        ELSEIF(.not.TNoAnnihil) THEN
            ALLOCATE(HashArray(MaxWalkersAnnihil),stat=ierr)
            CALL LogMemAlloc('HashArray',MaxWalkersAnnihil,8,this_routine,HashArrayTag,ierr)
            HashArray(:)=0
            ALLOCATE(Hash2Array(MaxWalkersAnnihil),stat=ierr)
            CALL LogMemAlloc('Hash2Array',MaxWalkersAnnihil,8,this_routine,Hash2ArrayTag,ierr)
            Hash2Array(:)=0
            ALLOCATE(IndexTable(MaxWalkersAnnihil),stat=ierr)
            CALL LogMemAlloc('IndexTable',MaxWalkersAnnihil,4,this_routine,IndexTableTag,ierr)
            IndexTable(1:MaxWalkersAnnihil)=0
            ALLOCATE(Index2Table(MaxWalkersAnnihil),stat=ierr)
            CALL LogMemAlloc('Index2Table',MaxWalkersAnnihil,4,this_routine,Index2TableTag,ierr)
            Index2Table(1:MaxWalkersAnnihil)=0
            ALLOCATE(ProcessVec(MaxWalkersAnnihil),stat=ierr)
            CALL LogMemAlloc('ProcessVec',MaxWalkersAnnihil,4,this_routine,ProcessVecTag,ierr)
            ProcessVec(1:MaxWalkersAnnihil)=0
            ALLOCATE(Process2Vec(MaxWalkersAnnihil),stat=ierr)
            CALL LogMemAlloc('Process2Vec',MaxWalkersAnnihil,4,this_routine,Process2VecTag,ierr)
            Process2Vec(1:MaxWalkersAnnihil)=0

            MemoryAlloc=MemoryAlloc+32*MaxWalkersAnnihil
        ENDIF

!Allocate pointers to the correct walker arrays
        CurrentDets=>WalkVecDets
        CurrentSign=>WalkVecSign
        IF(.not.tRegenDiagHEls) THEN
            CurrentH=>WalkVecH
            NewH=>WalkVec2H
        ENDIF
        NewDets=>WalkVec2Dets
        NewSign=>WalkVec2Sign

!Now calculate MP1 components - allocate memory for doubles
        IF(tNoSpinSymExcitgens) THEN
            exflag=3
            CALL CountExcitations3(HFDet,exflag,nSingles,nDoubles)
            HFConn=nSingles+nDoubles+1
        ELSE
            CALL GetSymExcitCount(HFExcit%ExcitData,HFConn)
            HFConn=HFConn+1     !Add on one for the HF Det itself
        ENDIF


        ALLOCATE(MP1Comps(HFConn),stat=ierr)    !This will store the cumulative absolute values of the mp1 wavevector components
        CALL LogMemAlloc('MP1Comps',HFConn,8,this_routine,MP1CompsTag,ierr)
        MP1Comps=0.d0
        ALLOCATE(MP1Dets(NEl,HFConn),stat=ierr)
        CALL LogMemAlloc('MP1Dets',HFConn*NEl,4,this_routine,MP1DetsTag,ierr)
        MP1Dets(1:NEl,1:HFConn)=0
        ALLOCATE(MP1Sign(HFConn),stat=ierr)
        CALL LogMemAlloc('MP1Sign',HFConn,4,this_routine,MP1SignTag,ierr)
        MP1Sign(:)=0
        ALLOCATE(MP1CompsNonCum(HFConn),stat=ierr)
        CALL LogMemAlloc('MP1CompsNonCum',HFConn,8,this_routine,MP1CompsNonCumTag,ierr)
        MP1CompsNonCum(:)=0.D0
        
!HF Compt. of MP1 is 1
        MP1Dets(1:NEl,1)=HFDet(1:NEl)
        MP1Comps(1)=1.D0
        MP1Sign(1)=1
        MP1CompsNonCum(1)=1.D0      !These are the components of the MP1 wavevector - not stored cumulatively as in MP1Comps

        SumMP1Compts=1.D0   !Initialise the sum of the MP1 wavevector components
        VecSlot=2           !This is the next free slot in the MP1 arrays
        MP2Energy=0.D0      !Calculate the MP2 energy as we go, since the shift will be set to this

!If tAssumeSizeExcitgens is on, then we cannot enumerate all determinants. Regenerate HF excitgen, turning of tAssumeSizeExcitgen if on.
        IF(tAssumeSizeExcitgen) THEN
            TurnBackAssumeExGen=.true.
            tAssumeSizeExcitgen=.false.
        ELSE
            TurnBackAssumeExGen=.false.
        ENDIF

!Setup excit generators for HF Determinant
        IF(tNoSpinSymExcitgens) THEN

            tAllExcitFound=.false.
            ExcitMat3(:,:)=0
! exflag of 2 means only generate double excitations from the HF determinant.
            exflag=2

            do while (.not.tAllExcitFound)
                CALL GenExcitations3(HFDet,iLutHF,nJ,exflag,ExcitMat3,tParity,tAllExcitFound)
                IF(tAllExcitFound) EXIT

                Hij = get_helement (HFDet, nJ, 2, ExcitMat3, tParity)
                CALL GetH0Element(nJ,NEl,Arr,nBasis,ECore,Fjj)
!                WRITE(6,"(4I5,2G25.10)") nJ(:),real(Hij%v,dp),(Fii-(REAL(Fjj%v,dp)))

                Compt=real(Hij%v,dp)/(Fii-(REAL(Fjj%v,dp)))
                IF(Compt.lt.0.D0) THEN
                    MP1Sign(VecSlot)=-1
                ELSE
                    MP1Sign(VecSlot)=1
                ENDIF
                MP1Dets(1:NEl,VecSlot)=nJ(:)
                MP1Comps(VecSlot)=MP1Comps(VecSlot-1)+abs(Compt)
                MP1CompsNonCum(VecSlot)=abs(Compt)
                SumMP1Compts=SumMP1Compts+abs(Compt)
                MP2Energy=MP2Energy+((real(Hij%v,dp))**2)/(Fii-(REAL(Fjj%v,dp)))

                VecSlot=VecSlot+1

            enddo

        ELSE

            iMaxExcit=0

            nStore(1:6)=0
            CALL GenSymExcitIt2(HFDet,NEl,G1,nBasis,nBasisMax,.TRUE.,ExcitLength,nJ,iMaxExcit,0,nStore,2)
            ALLOCATE(ExcitGenTemp(ExcitLength),stat=ierr)
            IF(ierr.ne.0) CALL Stop_All("InitWalkersMP1","Problem allocating excitation generator")
            ExcitGenTemp(1)=0
            CALL GenSymExcitIt2(HFDet,NEl,G1,nBasis,nBasisMax,.TRUE.,ExcitGenTemp,nJ,iMaxExcit,0,nStore,2)

            do while(.true.)
!Generate double excitations
                CALL GenSymExcitIt2(HFDet,NEl,G1,nBasis,nBasisMax,.false.,ExcitGenTemp,nJ,iExcit,0,nStore,2)
                IF(IsNullDet(nJ)) EXIT
                IF(iExcit.ne.2) THEN
                    CALL Stop_All("InitWalkersMP1","Error - excitations other than doubles being generated in MP1 wavevector code")
                ENDIF

                Hij = get_helement (HFDet, nJ, iExcit)
                CALL GetH0Element(nJ,NEl,Arr,nBasis,ECore,Fjj)
!                WRITE(6,"(8I5,2G25.10)") nJ(:),real(Hij%v,dp),(Fii-(REAL(Fjj%v,dp)))

                Compt=real(Hij%v,dp)/(Fii-(REAL(Fjj%v,dp)))
                IF(Compt.lt.0.D0) THEN
                    MP1Sign(VecSlot)=-1
                ELSE
                    MP1Sign(VecSlot)=1
                ENDIF
                MP1Dets(1:NEl,VecSlot)=nJ(:)
                MP1Comps(VecSlot)=MP1Comps(VecSlot-1)+abs(Compt)
                MP1CompsNonCum(VecSlot)=abs(Compt)
                SumMP1Compts=SumMP1Compts+abs(Compt)
                MP2Energy=MP2Energy+((real(Hij%v,dp))**2)/(Fii-(REAL(Fjj%v,dp)))

                VecSlot=VecSlot+1

            enddo

            DEALLOCATE(ExcitGenTemp)

        ENDIF


        WRITE(6,"(A,F15.7,A)") "Sum of absolute components of MP1 wavefunction is ",SumMP1Compts," with the HF being 1."

        VecSlot=VecSlot-1

!Total components is VecSlot
        IF(MP1Comps(VecSlot).ne.SumMP1Compts) THEN
            CALL Stop_All("InitWalkersMP1","Error in calculating sum of MP1 components")
        ENDIF
!        WRITE(6,*) VecSlot,HFConn,SumMP1Compts,ExcitLength

!        DiagSft=MP2Energy
        MP2Energy=MP2Energy+Hii
        WRITE(6,"(A,F16.7,A,F16.7)") "MP2 energy is ",MP2Energy,", but the initial shift has been set to: ",DiagSft

!        do i=1,VecSlot
!            WRITE(6,"(I5,3G20.10)") i,MP1Comps(i),MP1CompsNonCum(i),MP1CompsNonCum(i)/SumMP1Compts*REAL(InitWalkers,dp)
!        enddo

        WalkersonHF=0       !Find the number of walkers we are assigning to HF

        IF(tRotoAnnihil) THEN
!Here, we simply run through the MP1 components and then assign |amp|/sum{amps} x InitWalkers

            VecInd=1
            TotParts=0
            do j=1,VecSlot

                FracPart=MP1CompsNonCum(j)/SumMP1Compts*REAL(InitWalkers,dp)
                IntParts=INT(FracPart)
                FracPart=FracPart-REAL(IntParts)
!Determine whether we want to stochastically create another particle
                r = genrand_real2_dSFMT() 
                IF(FracPart.gt.r) THEN
                    IntParts=IntParts+1
                ENDIF

                IF(IntParts.gt.0) THEN

                    IF(j.eq.1) THEN
                        WalkersonHF=IntParts
                        CurrentDets(0:NIfTot,VecInd)=iLutHF(:)
                        CurrentSign(VecInd)=IntParts*MP1Sign(j)
                        TotParts=TotParts+IntParts
                        IF(.not.tRegenDiagHEls) THEN
                            CurrentH(VecInd)=0.D0
                        ENDIF
                    ELSE
!We are at a double excitation - we need to calculate most of this information...
                        CALL EncodeBitDet(MP1Dets(1:NEl,j),CurrentDets(0:NIfTot,VecInd))
                        CurrentSign(VecInd)=IntParts*MP1Sign(j)
                        TotParts=TotParts+IntParts
                        IF(.not.tRegenDiagHEls) THEN
                            Hjj = get_helement (MP1Dets(:,j), MP1Dets(:,1), 0)
                            CurrentH(VecInd)=real(Hjj%v,dp)-Hii
                        ENDIF
                    ENDIF
                    VecInd=VecInd+1
                ENDIF

            enddo

            TotWalkers=VecInd-1

!A reduced determinant representation could be created more easily by stochastically choosing amplitudes and running over excitations, rather than walkers.
            WRITE(6,*) "Ordering all walkers for rotoannihilation..."
            IF(tRegenDiagHEls) THEN
                CALL SortBitDets(TotWalkers,CurrentDets(:,1:TotWalkers), &
                                 CurrentSign(1:TotWalkers))
            ELSE
                CALL SortBitDetswH(TotWalkers,CurrentDets(:,1:TotWalkers), &
                         CurrentSign(1:TotWalkers),CurrentH(1:TotWalkers))
            ENDIF
            
        ELSE
                        
            do j=1,InitWalkers

                i=1

                r = genrand_real2_dSFMT() 
                r=r*SumMP1Compts       !Choose the double that this walker wants to be put...
                do while(r.gt.MP1Comps(i))

                    i=i+1

                    IF(i.gt.VecSlot) THEN
                        CALL Stop_All("InitWalkersMP1","Assigning walkers stochastically has been performed incorrectly")
                    ENDIF

                enddo

                IF(i.eq.1) THEN
!If we are at HF, then we do not need to calculate the information for the walker        
                    WalkersonHF=WalkersonHF+1
                    CurrentDets(0:NIfTot,j)=iLutHF(:)
                    CurrentSign(j)=1
                    IF(.not.tRegenDiagHEls) THEN
                        CurrentH(j)=0.D0
                    ENDIF
                    IF(.not.TNoAnnihil) THEN
                        HashArray(j)=HFHash
                    ENDIF
                ELSE
!We are at a double excitation - we need to calculate most of this information...
                    CALL EncodeBitDet(MP1Dets(1:NEl,i),CurrentDets(0:NIfTot,j))
                    CurrentSign(j)=MP1Sign(i)
                    IF(.not.tRegenDiagHEls) THEN
                        Hjj = get_helement (MP1Dets(:,i), MP1Dets(:,i), 0)
                        CurrentH(j)=real(Hjj%v,dp)-Hii
                    ENDIF
                    IF(.not.TNoAnnihil) THEN
                        HashArray(j)=CreateHash(MP1Dets(1:NEl,i))
                    ENDIF
                    
                ENDIF

            enddo

        ENDIF
        
        CALL MPI_Reduce(WalkersonHF,SumWalkersonHF,1,MPI_INTEGER,MPI_SUM,Root,MPI_COMM_WORLD,error)
        TempTotParts=REAL(TotParts,dp)
        CALL MPI_Reduce(TempTotParts,AllTotParts,1,MPI_DOUBLE_PRECISION,MPI_SUM,Root,MPI_COMM_WORLD,error)

        IF(iProcIndex.eq.Root) THEN
            IF(tRotoAnnihil) THEN
                WRITE(6,"(A,I12,A,I12,A)") "Out of ",TotParts*nProcessors," initial walkers allocated, ",SumWalkersonHF," of them are situated on the HF determinant."
            ELSE
                WRITE(6,"(A,I12,A,I12,A)") "Out of ",InitWalkers*nProcessors," initial walkers allocated, ",SumWalkersonHF," of them are situated on the HF determinant."
                TotParts=InitWalkers
                AllTotParts=REAL(InitWalkers*nProcessors,dp)
            ENDIF
        ENDIF
        AllNoatHF=SumWalkersonHF
        AllNoatDoubs=INT(AllTotParts)-SumWalkersonHF

!Deallocate MP1 data
        DEALLOCATE(MP1Comps)
        CALL LogMemDealloc(this_routine,MP1CompsTag)
        DEALLOCATE(MP1Dets)
        CALL LogMemDealloc(this_routine,MP1DetsTag)
        DEALLOCATE(MP1Sign)
        CALL LogMemDealloc(this_routine,MP1SignTag)
        DEALLOCATE(MP1CompsNonCum)
        CALL LogMemDealloc(this_routine,MP1CompsNonCumTag)

!We have finished enumerating all determinants from HF - turn back on assume size excitgen if it was off.
        IF(TurnBackAssumeExGen) THEN
            tAssumeSizeExcitgen=.true.
        ENDIF

        WRITE(6,"(A,F14.6,A)") "Initial memory (without excitgens + temp arrays) consists of : ",REAL(MemoryAlloc,dp)/1048576.D0," Mb/Processor"
        WRITE(6,*) "Initial memory allocation sucessful..."
        CALL FLUSH(6)

!Put a barrier here so all processes synchronise
        CALL MPI_Barrier(MPI_COMM_WORLD,error)
        WRITE(6,"(A)") "Excitation generators will not be stored, but regenerated each time they are needed..."
        WRITE(6,"(A,F14.6,A)") "Temp Arrays for annihilation cannot be more than : ",REAL(MaxWalkersPart*12,dp)/1048576.D0," Mb/Processor"
        CALL FLUSH(6)
        
        IF(tRotoAnnihil) THEN
            TotWalkersOld=TotWalkers
            TempTotWalkers=REAL(TotWalkers,dp)
            CALL MPI_Reduce(TempTotWalkers,AllTotWalkers,1,MPI_DOUBLE_PRECISION,MPI_SUM,root,MPI_COMM_WORLD,error)
            AllTotWalkersOld=AllTotWalkers
            AllTotPartsOld=AllTotParts
        ELSE
!TotWalkers contains the number of current walkers at each step
            TotWalkers=InitWalkers
            TotWalkersOld=InitWalkers
!Initialise global variables for calculation on the root node
            IF(iProcIndex.eq.root) THEN
                AllTotWalkers=REAL(InitWalkers*nProcessors,dp)
                AllTotWalkersOld=REAL(InitWalkers*nProcessors,dp)
            ENDIF
        ENDIF

        RETURN

    END SUBROUTINE InitWalkersMP1Par

! This is called if tListDets is set, and will read a list of NAllowedDetList determinants in natural order from the SpawnOnlyDets file, 
! store them in AllowedDetList (compressed), and only allow spawning at these determinants.
    SUBROUTINE ReadSpawnListDets()
        use Parallel, only : MPIIBCast_Scal,MPIIBCast
        LOGICAL :: exists
        INTEGER :: i,nI(NEl),ierr

        IF(iProcIndex.eq.Root) THEN

            INQUIRE(FILE='SpawnOnlyDets',EXIST=exists)
            IF(.not.exists) THEN
                CALL Stop_All('ReadSpawnListDets',"No SpawnOnlyDets file to read in allowed determinants...")
            ENDIF

            WRITE(6,*) "Reading in the allowed determinant list from SpawnOnlyDets..."
            OPEN(17,FILE='SpawnOnlyDets',Status='old')

            NAllowedDetList=0
                
            do while(.true.)

                READ(17,*,END=199) nI(1:NEl)
!                WRITE(6,*) nI

                NAllowedDetList=NAllowedDetList+1
                    
            enddo

199         CONTINUE
        ENDIF

        CALL MPIIBCast_Scal(NAllowedDetList,Root)
        WRITE(6,*) NAllowedDetList, " determinants read in from SpawnOnlyDets file..."

        ALLOCATE(AllowedDetList(0:NIfTot,NAllowedDetList),stat=ierr)
        IF(ierr.ne.0) THEN
            CALL Stop_All("ReadSpawnListDets","Error allocating AllowedDetList array")
        ENDIF

        IF(iProcIndex.eq.Root) THEN
            REWIND(17)

            do i=1,NAllowedDetList
                READ(17,*) nI(1:NEl)
                CALL EncodeBitDet(nI,AllowedDetList(0:NIfTot,i))
!                WRITE(6,*) AllowedDetList(0:NIfTot,i)
            enddo

            CLOSE(17)
        ENDIF

        CALL MPIIBCast(AllowedDetList,NAllowedDetList*(NIfTot+1),Root)
!        do i=1,NAllowedDetList
!            CALL DecodeBitDet(nI,AllowedDetList(0:NIfTot,i))
!            WRITE(6,*) nI(:)
!        enddo

    END SUBROUTINE ReadSpawnListDets

!This routine simply reduces the histogrammed determinants, and prints out their population for the given iteration
    SUBROUTINE WriteHistogrammedDets()
        INTEGER :: AllWeightatDets(NoAutoDets),error,k
        
!First, collate the information onto the root
        AllWeightatDets(:)=0
        CALL MPI_Reduce(WeightatDets(1:NoAutoDets),AllWeightatDets(1:NoAutoDets),NoAutoDets,MPI_INTEGER,MPI_SUM,root,MPI_COMM_WORLD,error)

        IF(iProcIndex.eq.root) THEN
            WRITE(44,"(2I8)",advance='no') Iter,AllWeightatDets(1)
            do k=2,NoAutoDets-1
                WRITE(44,"(I8)",advance='no') AllWeightatDets(k)
            enddo
            WRITE(44,"(I8)") AllWeightatDets(NoAutoDets)
        ENDIF
        WeightatDets(:)=0   !Rezero the array for the next iteration
    END SUBROUTINE WriteHistogrammedDets
    
    
